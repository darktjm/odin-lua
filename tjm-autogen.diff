diff -ruNx autom4te.cache -x 'config*' pkg/dg/dg-yacc.c pkg/dg/dg-yacc.c
--- pkg/dg/dg-yacc.c	1969-12-31 18:00:00.000000000 -0600
+++ pkg/dg/dg-yacc.c	2016-09-08 11:04:04.401619998 -0500
@@ -0,0 +1,1835 @@
+/* A Bison parser, made by GNU Bison 3.0.4.  */
+
+/* Bison implementation for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "3.0.4"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 1 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:339  */
+
+#include "inc/GMC.h"
+extern int num_ParseErrors;
+tp_Nod YY_Parse() {tp_Nod Nod;
+num_ParseErrors = 0; Init_Lex(); Init_ConstructTree();
+(void)yyparse(); Nod = End_ConstructTree();
+return Nod;}
+void yyerror(char*  s)  
+{num_ParseErrors++; ParseError(s);}
+int yylex() {return YY_Lex();}
+
+#line 78 "y.tab.c" /* yacc.c:339  */
+
+# ifndef YY_NULLPTR
+#  if defined __cplusplus && 201103L <= __cplusplus
+#   define YY_NULLPTR nullptr
+#  else
+#   define YY_NULLPTR 0
+#  endif
+# endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* In a future release of Bison, this section will be replaced
+   by #include "y.tab.h".  */
+#ifndef YY_YY_Y_TAB_H_INCLUDED
+# define YY_YY_Y_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    TOK_BANNER = 2,
+    TOK_NEEDS = 3,
+    TOK_Word = 4,
+    TOK_Colon = 5,
+    TOK_Plus = 6,
+    TOK_Equals = 7,
+    TOK_LeftParen = 8,
+    TOK_RightParen = 9,
+    TOK_Percent = 10,
+    TOK_Slash = 11,
+    TOK_Semicolon = 12,
+    TOK_Question = 13,
+    TOK_LeftAngle = 14,
+    TOK_RightAngle = 15,
+    TOK_Ampersand = 16,
+    TOK_At = 17,
+    TOK_Asterisk = 18,
+    TOK_Dollar = 19
+  };
+#endif
+/* Tokens.  */
+#define TOK_BANNER 2
+#define TOK_NEEDS 3
+#define TOK_Word 4
+#define TOK_Colon 5
+#define TOK_Plus 6
+#define TOK_Equals 7
+#define TOK_LeftParen 8
+#define TOK_RightParen 9
+#define TOK_Percent 10
+#define TOK_Slash 11
+#define TOK_Semicolon 12
+#define TOK_Question 13
+#define TOK_LeftAngle 14
+#define TOK_RightAngle 15
+#define TOK_Ampersand 16
+#define TOK_At 17
+#define TOK_Asterisk 18
+#define TOK_Dollar 19
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef int YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE yylval;
+
+int yyparse (void);
+
+#endif /* !YY_YY_Y_TAB_H_INCLUDED  */
+
+/* Copy the second part of user declarations.  */
+
+#line 169 "y.tab.c" /* yacc.c:358  */
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#else
+typedef signed char yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(Msgid) Msgid
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE
+# if (defined __GNUC__                                               \
+      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
+     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
+#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
+# else
+#  define YY_ATTRIBUTE(Spec) /* empty */
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE_PURE
+# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
+#endif
+
+#ifndef YY_ATTRIBUTE_UNUSED
+# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
+#endif
+
+#if !defined _Noreturn \
+     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
+# if defined _MSC_VER && 1200 <= _MSC_VER
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(E) ((void) (E))
+#else
+# define YYUSE(E) /* empty */
+#endif
+
+#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
+    _Pragma ("GCC diagnostic push") \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+    _Pragma ("GCC diagnostic pop")
+#else
+# define YY_INITIAL_VALUE(Value) Value
+#endif
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
+#endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's 'empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+             && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
+    do                                                                  \
+      {                                                                 \
+        YYSIZE_T yynewbytes;                                            \
+        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
+        Stack = &yyptr->Stack_alloc;                                    \
+        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / sizeof (*yyptr);                          \
+      }                                                                 \
+    while (0)
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from SRC to DST.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+#  else
+#   define YYCOPY(Dst, Src, Count)              \
+      do                                        \
+        {                                       \
+          YYSIZE_T yyi;                         \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
+        }                                       \
+      while (0)
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  20
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   123
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  21
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  31
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  69
+/* YYNSTATES -- Number of states.  */
+#define YYNSTATES  113
+
+/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
+   by yylex, with out-of-bounds checking.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   257
+
+#define YYTRANSLATE(YYX)                                                \
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, without out-of-bounds checking.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     3,     4,     5,     6,     7,     8,     9,    10,
+      11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2
+};
+
+#if YYDEBUG
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,    36,    36,    40,    44,    47,    49,    52,    57,    63,
+      69,    75,    84,    87,    91,    94,   100,   102,   106,   111,
+     116,   123,   126,   130,   134,   138,   142,   145,   149,   151,
+     155,   158,   162,   164,   168,   171,   175,   181,   187,   189,
+     191,   194,   199,   205,   207,   210,   216,   219,   221,   223,
+     225,   227,   230,   235,   238,   241,   243,   247,   250,   252,
+     258,   260,   264,   269,   272,   276,   278,   282,   284,   287
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || 0
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "TOK_BANNER", "TOK_NEEDS", "TOK_Word",
+  "TOK_Colon", "TOK_Plus", "TOK_Equals", "TOK_LeftParen", "TOK_RightParen",
+  "TOK_Percent", "TOK_Slash", "TOK_Semicolon", "TOK_Question",
+  "TOK_LeftAngle", "TOK_RightAngle", "TOK_Ampersand", "TOK_At",
+  "TOK_Asterisk", "TOK_Dollar", "$accept", "xDerivationGraph",
+  "xDerivationGraph_1", "xDGEntry", "xDGEntry_1", "xSourceType",
+  "xSourceType_1", "xParameterType", "xObjectType", "xForeignObjectType",
+  "xDesc", "xSuperType", "xArgs", "xArgs_1", "xNeeds", "xNeeds_1",
+  "xResults", "xResults_1", "xResult", "xForeignResult", "xArg",
+  "xFileArg", "xOdinExpr1", "xRoot", "xOperation", "xOperation_1",
+  "xParameterValues", "xParameterValues_1", "xParameterValue", "xVarWord",
+  "TOK_Wordleaf", YY_NULLPTR
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[NUM] -- (External) token number corresponding to the
+   (internal) symbol number NUM (which must be that of a token).  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,     2,     3,     4,     5,     6,     7,     8,
+       9,    10,    11,    12,    13,    14,    15,    16,    17,    18,
+      19
+};
+# endif
+
+#define YYPACT_NINF -79
+
+#define yypact_value_is_default(Yystate) \
+  (!!((Yystate) == (-79)))
+
+#define YYTABLE_NINF -1
+
+#define yytable_value_is_error(Yytable_value) \
+  0
+
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+static const yytype_int8 yypact[] =
+{
+      39,    13,   -79,    13,    13,    13,    13,    38,    43,   -79,
+      53,    13,    13,    11,   -79,   -79,   -79,   -79,   -79,    13,
+     -79,    39,    52,    61,    56,    63,    84,   -79,    13,    69,
+      57,   -79,    33,   -79,   -79,    68,   -79,    72,    71,   -79,
+      76,    74,    21,    21,   -79,   -79,    95,   -79,   -79,   -79,
+      57,    80,   -79,   -79,   -79,    57,   -79,    72,    37,   -79,
+     102,   -79,   -79,     5,   -79,    21,    21,    89,    90,   -79,
+      57,   -79,    83,   -79,   -79,   -79,   -79,    72,    37,   -79,
+     -79,   -79,   -79,   -79,   -79,    57,   -79,   -79,    72,   -79,
+      91,    94,   -79,    57,   -79,   -79,   109,   -79,   107,   -79,
+     -79,   -79,   -79,    13,   108,   110,    72,   -79,    98,   -79,
+     -79,    13,   -79
+};
+
+  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+     Performed when YYTABLE does not specify something else to do.  Zero
+     means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       5,     0,    69,     0,     0,    17,     0,     0,     2,     4,
+       0,     0,     0,     0,     6,    19,    18,    15,    16,     0,
+       1,     5,     0,     0,    22,     0,     0,    14,     0,    29,
+      25,    27,    39,    38,    67,     0,     3,     0,     0,    21,
+       0,     0,     0,    50,    49,    48,     0,    43,    47,    68,
+       0,     0,    26,    41,    40,     0,     7,     0,     0,    46,
+       0,    52,    51,     0,    42,     0,    58,    61,    55,    44,
+      28,    31,     0,    66,    10,    65,     9,     0,     8,    24,
+      13,    45,    54,    59,    57,     0,    53,    60,     0,    30,
+       0,     0,    12,    62,    64,    56,     0,    11,    32,    35,
+      33,    23,    63,     0,     0,     0,     0,    34,    19,    36,
+      37,     0,    20
+};
+
+  /* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -79,   -79,   -79,   100,   -79,   -79,   -79,    14,   -24,   -79,
+      20,    41,   -79,   -79,   -79,   -79,   -79,   -79,    24,   -79,
+     -21,   -28,    82,   -79,   -79,   -79,   -79,   -79,   -78,   -18,
+       0
+};
+
+  /* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     7,     8,     9,    78,    10,    17,    11,    12,   105,
+      23,    80,    29,    30,    51,    70,    97,    98,    99,   100,
+      31,    32,    46,    47,    69,    86,    87,    93,    74,    33,
+      34
+};
+
+  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule whose
+     number is the opposite.  If YYTABLE_NINF, syntax error.  */
+static const yytype_uint8 yytable[] =
+{
+      13,    14,    45,    15,    16,    18,    19,    94,    48,    52,
+       2,    24,    24,    56,    26,   102,     2,    45,     2,    24,
+      26,    13,    68,    48,    61,    62,     2,    73,    49,    71,
+      27,    28,    25,    76,    79,    82,    68,    75,    20,    35,
+      44,    28,     1,     3,     2,     3,     4,    83,    84,    89,
+      53,    54,    77,    91,    79,    44,    21,    73,     5,     6,
+      67,    22,     2,    16,    95,    73,    26,    75,    37,    38,
+      39,    40,   104,    50,    67,    75,    55,    28,     3,     2,
+       3,     4,   104,    41,    59,    42,    43,    57,    72,     2,
+       3,     4,    58,    41,    28,    42,    43,    85,    88,    90,
+      96,     3,    63,   108,    28,    64,    65,    66,     3,    63,
+     101,   112,    81,    65,    66,   103,   106,   111,   109,    92,
+     110,    36,   107,    60
+};
+
+static const yytype_uint8 yycheck[] =
+{
+       0,     1,    26,     3,     4,     5,     6,    85,    26,    30,
+       5,    11,    12,    37,     9,    93,     5,    41,     5,    19,
+       9,    21,    46,    41,    42,    43,     5,    55,    28,    50,
+      19,    20,    12,    57,    58,    63,    60,    55,     0,    19,
+      26,    20,     3,     6,     5,     6,     7,    65,    66,    70,
+      17,    18,    15,    77,    78,    41,    13,    85,    19,    20,
+      46,     8,     5,    63,    88,    93,     9,    85,    16,     8,
+      14,     8,    96,     4,    60,    93,     8,    20,     6,     5,
+       6,     7,   106,     9,    10,    11,    12,    16,     8,     5,
+       6,     7,    16,     9,    20,    11,    12,     8,     8,    16,
+       9,     6,     7,   103,    20,    10,    11,    12,     6,     7,
+      16,   111,    10,    11,    12,     6,     9,    19,    10,    78,
+      10,    21,    98,    41
+};
+
+  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+     symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     3,     5,     6,     7,    19,    20,    22,    23,    24,
+      26,    28,    29,    51,    51,    51,    51,    27,    51,    51,
+       0,    13,     8,    31,    51,    31,     9,    19,    20,    33,
+      34,    41,    42,    50,    51,    31,    24,    16,     8,    14,
+       8,     9,    11,    12,    28,    29,    43,    44,    50,    51,
+       4,    35,    41,    17,    18,     8,    29,    16,    16,    10,
+      43,    50,    50,     7,    10,    11,    12,    28,    29,    45,
+      36,    41,     8,    42,    49,    50,    29,    15,    25,    29,
+      32,    10,    42,    50,    50,     8,    46,    47,     8,    41,
+      16,    29,    32,    48,    49,    29,     9,    37,    38,    39,
+      40,    16,    49,     6,    29,    30,     9,    39,    51,    10,
+      10,    19,    51
+};
+
+  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    21,    22,    23,    23,    24,    24,    24,    24,    24,
+      24,    24,    25,    25,    26,    26,    27,    27,    28,    29,
+      30,    31,    31,    32,    32,    33,    34,    34,    35,    35,
+      36,    36,    37,    37,    38,    38,    39,    40,    41,    41,
+      41,    41,    42,    43,    43,    43,    44,    44,    44,    44,
+      44,    44,    44,    45,    45,    45,    45,    45,    45,    45,
+      46,    46,    47,    48,    48,    49,    49,    50,    50,    51
+};
+
+  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     1,     3,     1,     0,     2,     4,     5,     5,
+       5,     6,     2,     1,     2,     2,     1,     0,     2,     2,
+       4,     2,     1,     3,     1,     1,     2,     1,     2,     0,
+       2,     1,     1,     1,     2,     1,     3,     3,     1,     1,
+       2,     2,     3,     1,     2,     3,     2,     1,     1,     1,
+       1,     2,     2,     2,     2,     1,     3,     2,     1,     2,
+       1,     0,     2,     2,     1,     1,     1,     1,     2,     1
+};
+
+
+#define yyerrok         (yyerrstatus = 0)
+#define yyclearin       (yychar = YYEMPTY)
+#define YYEMPTY         (-2)
+#define YYEOF           0
+
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                                  \
+do                                                              \
+  if (yychar == YYEMPTY)                                        \
+    {                                                           \
+      yychar = (Token);                                         \
+      yylval = (Value);                                         \
+      YYPOPSTACK (yylen);                                       \
+      yystate = *yyssp;                                         \
+      goto yybackup;                                            \
+    }                                                           \
+  else                                                          \
+    {                                                           \
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;                                                  \
+    }                                                           \
+while (0)
+
+/* Error token number */
+#define YYTERROR        1
+#define YYERRCODE       256
+
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)                        \
+do {                                            \
+  if (yydebug)                                  \
+    YYFPRINTF Args;                             \
+} while (0)
+
+/* This macro is provided for backward compatibility. */
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif
+
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+do {                                                                      \
+  if (yydebug)                                                            \
+    {                                                                     \
+      YYFPRINTF (stderr, "%s ", Title);                                   \
+      yy_symbol_print (stderr,                                            \
+                  Type, Value); \
+      YYFPRINTF (stderr, "\n");                                           \
+    }                                                                     \
+} while (0)
+
+
+/*----------------------------------------.
+| Print this symbol's value on YYOUTPUT.  |
+`----------------------------------------*/
+
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  FILE *yyo = yyoutput;
+  YYUSE (yyo);
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+  YYUSE (yytype);
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  YYFPRINTF (yyoutput, "%s %s (",
+             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)                            \
+do {                                                            \
+  if (yydebug)                                                  \
+    yy_stack_print ((Bottom), (Top));                           \
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+static void
+yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)
+{
+  unsigned long int yylno = yyrline[yyrule];
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+             yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr,
+                       yystos[yyssp[yyi + 1 - yynrhs]],
+                       &(yyvsp[(yyi + 1) - (yynrhs)])
+                                              );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)          \
+do {                                    \
+  if (yydebug)                          \
+    yy_reduce_print (yyssp, yyvsp, Rule); \
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+yystrlen (const char *yystr)
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+        switch (*++yyp)
+          {
+          case '\'':
+          case ',':
+            goto do_not_strip_quotes;
+
+          case '\\':
+            if (*++yyp != '\\')
+              goto do_not_strip_quotes;
+            /* Fall through.  */
+          default:
+            if (yyres)
+              yyres[yyn] = *yyp;
+            yyn++;
+            break;
+
+          case '"':
+            if (yyres)
+              yyres[yyn] = '\0';
+            return yyn;
+          }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = YY_NULLPTR;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                {
+                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
+                  if (! (yysize <= yysize1
+                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                    return 2;
+                  yysize = yysize1;
+                }
+              }
+        }
+    }
+
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
+
+  {
+    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
+    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+      return 2;
+    yysize = yysize1;
+  }
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
+}
+#endif /* YYERROR_VERBOSE */
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+{
+  YYUSE (yyvaluep);
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+}
+
+
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+int
+yyparse (void)
+{
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       'yyss': related to states.
+       'yyvs': related to semantic values.
+
+       Refer to the stacks through separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yyssp = yyss = yyssa;
+  yyvsp = yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+        /* Give user a chance to reallocate the stack.  Use copies of
+           these so that the &'s don't force the real ones into
+           memory.  */
+        YYSTYPE *yyvs1 = yyvs;
+        yytype_int16 *yyss1 = yyss;
+
+        /* Each stack pointer address is followed by the size of the
+           data in use in that stack, in bytes.  This used to be a
+           conditional around just the two extra args, but that might
+           be undefined if yyoverflow is a macro.  */
+        yyoverflow (YY_("memory exhausted"),
+                    &yyss1, yysize * sizeof (*yyssp),
+                    &yyvs1, yysize * sizeof (*yyvsp),
+                    &yystacksize);
+
+        yyss = yyss1;
+        yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+        goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+        yystacksize = YYMAXDEPTH;
+
+      {
+        yytype_int16 *yyss1 = yyss;
+        union yyalloc *yyptr =
+          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+        if (! yyptr)
+          goto yyexhaustedlab;
+        YYSTACK_RELOCATE (yyss_alloc, yyss);
+        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+        if (yyss1 != yyssa)
+          YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+                  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+        YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = yylex ();
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     '$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 2:
+#line 36 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(1,1);}
+#line 1327 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 3:
+#line 42 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1333 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 5:
+#line 47 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(0,0);}
+#line 1339 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 6:
+#line 50 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(2,1);}
+#line 1345 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 7:
+#line 55 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(3,2);}
+#line 1351 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 8:
+#line 61 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(5,3);}
+#line 1357 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 9:
+#line 67 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(4,3);}
+#line 1363 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 10:
+#line 73 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(7,3);}
+#line 1369 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 11:
+#line 80 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(6,4);}
+#line 1375 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 12:
+#line 85 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1381 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 14:
+#line 92 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(8,1);}
+#line 1387 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 15:
+#line 95 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(9,1);}
+#line 1393 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 17:
+#line 102 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(0,0);}
+#line 1399 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 20:
+#line 119 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1405 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 22:
+#line 126 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(10,1);}
+#line 1411 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 23:
+#line 132 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(11,1);}
+#line 1417 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 25:
+#line 138 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(12,1);}
+#line 1423 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 26:
+#line 143 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1429 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 28:
+#line 150 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(13,1);}
+#line 1435 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 29:
+#line 151 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(13,0);}
+#line 1441 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 30:
+#line 156 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1447 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 32:
+#line 162 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(16,1);}
+#line 1453 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 33:
+#line 164 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(16,1);}
+#line 1459 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 34:
+#line 169 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1465 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 37:
+#line 183 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(17,1);}
+#line 1471 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 40:
+#line 192 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(14,1);}
+#line 1477 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 41:
+#line 195 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(15,1);}
+#line 1483 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 42:
+#line 201 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(18,1);}
+#line 1489 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 44:
+#line 208 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1495 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 46:
+#line 217 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(21,0);}
+#line 1501 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 48:
+#line 221 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(19,1);}
+#line 1507 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 49:
+#line 223 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(20,1);}
+#line 1513 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 50:
+#line 225 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(22,0);}
+#line 1519 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 51:
+#line 228 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(23,1);}
+#line 1525 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 52:
+#line 231 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(30,1);}
+#line 1531 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 53:
+#line 236 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(24,2);}
+#line 1537 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 54:
+#line 239 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(25,1);}
+#line 1543 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 55:
+#line 241 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(27,1);}
+#line 1549 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 56:
+#line 245 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(28,2);}
+#line 1555 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 57:
+#line 248 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(31,1);}
+#line 1561 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 58:
+#line 250 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(32,0);}
+#line 1567 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 59:
+#line 253 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(30,1);}
+#line 1573 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 61:
+#line 260 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(0,0);}
+#line 1579 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 62:
+#line 265 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(26,1);}
+#line 1585 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 63:
+#line 270 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1591 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 68:
+#line 285 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(33,1);}
+#line 1597 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 69:
+#line 287 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1646  */
+    {Action(34,-1);}
+#line 1603 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+
+#line 1607 "y.tab.c" /* yacc.c:1646  */
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now 'shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*--------------------------------------.
+| yyerrlab -- here on detecting error.  |
+`--------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+         error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+          /* Return failure if at end of input.  */
+          if (yychar == YYEOF)
+            YYABORT;
+        }
+      else
+        {
+          yydestruct ("Error: discarding",
+                      yytoken, &yylval);
+          yychar = YYEMPTY;
+        }
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+        {
+          yyn += YYTERROR;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+            {
+              yyn = yytable[yyn];
+              if (0 < yyn)
+                break;
+            }
+        }
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+        YYABORT;
+
+
+      yydestruct ("Error: popping",
+                  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined yyoverflow || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
+    }
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+                  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  return yyresult;
+}
+#line 289 "/home/darktjm/.ODIN/darktjm/FILES/b/l/drvgrf.ygi.3811171.y" /* yacc.c:1906  */
+
diff -ruNx autom4te.cache -x 'config*' pkg/dg/inc/Func.hh pkg/dg/inc/Func.hh
--- pkg/dg/inc/Func.hh	1969-12-31 18:00:00.000000000 -0600
+++ pkg/dg/inc/Func.hh	2016-09-08 11:04:04.458619281 -0500
@@ -0,0 +1,235 @@
+/* pkg/dg/dg-analyze.c */
+extern boolean Is_Output(tp_FilTyp, tp_Tool);
+extern void Make_DrvEdgs(void);
+extern void Make_PrmTypLsts(void);
+extern void Set_FTClasses(void);
+/* pkg/dg/dg-build.c */
+extern void Init_InpSpcs(void);
+extern void Build_DerivationGraph(tp_FileName, tp_Package);
+extern char *C_Esc(const char *);
+extern void Write_DerivationGraph(void);
+/* pkg/dg/dg-edg.c */
+extern void Clear_EdgFlags(void);
+extern tp_FilTyp EqvEdg_FilTyp(tp_EqvEdg);
+extern tp_EqvEdg EqvEdg_Next(tp_EqvEdg);
+extern tp_FilTyp EqvEdg_FrmFilTyp(tp_EqvEdg);
+extern tp_EqvEdg EqvEdg_FrmNext(tp_EqvEdg);
+extern tp_FilTyp CastEdg_FilTyp(tp_CastEdg);
+extern tp_CastEdg CastEdg_Next(tp_CastEdg);
+extern tp_FilTyp DrvEdg_FrmFilTyp(tp_DrvEdg);
+extern tp_DrvEdg DrvEdg_FrmNext(tp_DrvEdg);
+extern tp_DrvEdg DrvEdg_Next(tp_DrvEdg);
+extern void Add_InpEdg(tp_InpSpc, tp_InpKind, boolean, tp_Tool);
+extern void Add_HomInpEdg(tp_InpSpc, tp_Tool);
+extern boolean HasInput(tp_Tool);
+extern void Set_SystemTool_InpKinds(tp_Tool, tp_InpKind);
+extern void Set_SystemTool_InpKind(tp_Tool, int, tp_InpKind);
+extern tp_FilTyp MemEdg_FilTyp(tp_MemEdg);
+extern void Add_MemEdg(tp_FilTyp, tp_FilTyp);
+extern void Add_EqvEdg(tp_FilTyp, tp_FilTyp);
+extern void Add_CastEdg(tp_FilTyp, tp_FilTyp);
+extern void Add_DrvEdg(tp_FilTyp, tp_FilTyp);
+extern tp_PrmTypLst DrvEdg_PrmTypLst(tp_DrvEdg);
+extern void Print_DrvEdg(tp_FilDsc, tp_DrvEdg);
+extern void Print_MemEdgs(tp_FilDsc, tp_MemEdg);
+extern void Write_Edgs(FILE *, FILE *);
+/* pkg/dg/dg-envvar.c */
+extern void Init_EnvVars(void);
+extern tp_EnvVar Lookup_EnvVar(tp_Str);
+extern tp_Desc EnvVar_Desc(tp_EnvVar);
+extern void Set_EnvVar_Desc(tp_EnvVar, tp_Desc, boolean);
+extern void Set_EnvVar_Default(tp_EnvVar, tp_Str, boolean);
+extern tp_EnvVarLst EnvVarLst_Next(tp_EnvVarLst);
+extern tp_EnvVarLst Make_EnvVarLst(tp_EnvVar);
+extern tp_EnvVarLst Union_EnvVarLst(tp_EnvVarLst, tp_EnvVarLst);
+extern void Print_EnvVarLst(tp_FilDsc, tp_EnvVarLst);
+extern void Write_EnvVars(FILE *, FILE *);
+extern void Write_ENV(void);
+extern tp_InpSpc New_InpSpc(void);
+extern void Write_InpSpcs(FILE *, FILE *);
+/* pkg/dg/dg-filtyp.c */
+extern void Init_FilTyps(void);
+extern void Set_Tool(tp_FilTyp, tp_Tool);
+extern tp_Desc FilTyp_Desc(tp_FilTyp);
+extern void Set_FilTyp_Desc(tp_FilTyp, tp_Desc, boolean);
+extern tp_FilTyp Create_StructFilTyp(tp_Package, tp_FTName);
+extern tp_FilTyp Create_OutputFilTyp(tp_Package, tp_Package, tp_FTName);
+extern tp_FilTyp Lookup_FilTyp(tp_FTName);
+extern tp_FilTyp Lookup_SecOrdFilTyp(tp_FTName, tp_FilTyp);
+extern tp_SrcTyp Lookup_SrcTyp(tp_Pattern, boolean);
+extern void Set_SrcTyp_FilTyp(tp_SrcTyp, tp_FilTyp);
+extern tp_FilTyp SrcTyp_FilTyp(tp_SrcTyp);
+extern tp_FilTyp Key_FilTyp(tp_Key);
+extern void Clear_FilTypFlags(void);
+extern void Print_Info(tp_FilDsc);
+extern void Print_FilTyp(tp_FilDsc, tp_FilTyp);
+extern void Write_FilTyps(FILE *, FILE *);
+/* pkg/dg/dg-main.c */
+extern int main(int, char **);
+/* pkg/dg/dg-prmtyp.c */
+extern void Init_PrmTyps(void);
+extern tp_PTName PrmTyp_PTName(tp_PrmTyp);
+extern tp_Desc PrmTyp_Desc(tp_PrmTyp);
+extern void Set_PrmTyp_Desc(tp_PrmTyp, tp_Desc, boolean);
+extern tp_FilTyp PrmTyp_FilTyp(tp_PrmTyp);
+extern void Set_PrmTyp_FilTyp(tp_PrmTyp, tp_FilTyp);
+extern tp_PrmTyp Lookup_PrmTyp(tp_PTName);
+extern void Print_PrmTyp(tp_FilDsc, tp_PrmTyp);
+extern tp_PrmTypLst PrmTypLst_Next(tp_PrmTypLst);
+extern tp_PrmTypLst Make_PrmTypLst(tp_PrmTyp);
+extern tp_PrmTypLst Union_PrmTypLst(tp_PrmTypLst, tp_PrmTypLst);
+extern void Print_PrmTypLst(tp_FilDsc, tp_PrmTypLst);
+extern void Write_PrmTyps(FILE *, FILE *);
+/* pkg/dg/dg-tool.c */
+extern tp_Tool New_Tool(void);
+extern void Init_Tools(void);
+extern tp_EnvVarLst Tool_EnvVarLst(tp_Tool);
+extern void Set_Tool_EnvVarLst(tp_Tool, tp_EnvVarLst);
+extern void Clear_ToolFlags(void);
+extern tp_Str Tool_Name(tp_Tool);
+extern boolean IsDummy_Tool(tp_Tool);
+extern void Write_Tools(FILE *, FILE *);
+/* pkg/dg/dg-valid.c */
+extern void Validate_DerivationGraph(void);
+/* pkg/dg/dg-yylex.c */
+extern void Init_Parse(void);
+extern void ParseError(tp_Str);
+extern void Init_Lex(void);
+extern void EndLex(void);
+extern int YY_Lex(void);
+extern void YY_Unparse(tp_Str, tp_Nod);
+/* pkg/dg/dg-yacc.c */
+extern tp_Nod YY_Parse(void);
+extern void yyerror(char *);
+extern int yylex(void);
+extern int yyparse(void);
+/* pkg/dg/if-drvpth.c */
+extern void AppendDrvPth(tp_DrvPth *, tp_DrvPth);
+extern tp_DrvPth FilTyp_Cast_DrvPth(tp_FilTyp);
+extern tp_DrvPth FilTyp_Eqv_DrvPth(tp_FilTyp);
+extern tp_DrvPth FilTyp_Drv_DrvPth(tp_FilTyp, tp_DrvEdg);
+extern void Ret_DrvPth(tp_DrvPth);
+extern tp_DPType DrvPth_DPType(tp_DrvPth);
+extern tp_FKind DrvPth_FKind(tp_DrvPth);
+extern tp_FilTyp DrvPth_FilTyp(tp_DrvPth);
+extern tp_DrvEdg DrvPth_DrvEdg(tp_DrvPth);
+extern tp_DrvPth DrvPth_Next(tp_DrvPth);
+/* pkg/dg/if-ft.c */
+extern boolean IsPntr_FKind(tp_FKind);
+extern boolean CanPntrHo_FKind(tp_FKind);
+extern boolean IsATgt_FKind(tp_FKind);
+extern boolean IsVTgt_FKind(tp_FKind);
+extern boolean IsATgtText_FKind(tp_FKind);
+extern boolean IsVTgtText_FKind(tp_FKind);
+extern boolean IsExternal_Tool(tp_Tool);
+extern tp_MemEdg FilTyp_MemEdg(tp_FilTyp);
+extern tp_CastEdg FilTyp_CastEdg(tp_FilTyp);
+extern tp_PrmTypLst FilTyp_MapPrmTypLst(tp_FilTyp);
+extern tp_FilTyp FilTyp_ArgFilTyp(tp_FilTyp);
+extern tp_Tool FilTyp_Tool(tp_FilTyp);
+extern tp_FTName FilTyp_ShortFTName(tp_FilTyp);
+extern tp_FTName FilTyp_FTName(tp_FilTyp);
+extern boolean IsCopy_FilTyp(tp_FilTyp);
+extern boolean IsGrouping_FilTyp(tp_FilTyp);
+extern boolean IsGroupingInput_FilTyp(tp_FilTyp);
+extern boolean IsSecOrd_FilTyp(tp_FilTyp);
+extern boolean IsRecurse_FilTyp(tp_FilTyp);
+extern boolean IsExec_FilTyp(tp_FilTyp);
+extern boolean IsVoid_FilTyp(tp_FilTyp);
+extern boolean IsAtmc_FilTyp(tp_FilTyp);
+extern boolean IsPntr_FilTyp(tp_FilTyp);
+extern boolean IsList_FilTyp(tp_FilTyp);
+extern boolean IsDrvDir_FilTyp(tp_FilTyp);
+extern boolean IsStruct_FilTyp(tp_FilTyp);
+extern boolean IsStructMem_FilTyp(tp_FilTyp);
+extern boolean IsGeneric_FilTyp(tp_FilTyp);
+extern boolean IsPipe_FilTyp(tp_FilTyp);
+/* pkg/dg/if-lvl.c */
+extern boolean IsSubType(tp_FilTyp, tp_FilTyp);
+extern void Do_Search(tp_DrvPth *, boolean *, tp_FKind, tp_FilTyp, tp_FilTyp);
+/* pkg/odin/if-err.c */
+extern void Init_Err(void);
+extern void Set_IPC_Err(boolean);
+extern void Set_ErrFile(tp_FileName, boolean, tp_FilDsc);
+extern void Save_ErrFile(tp_FileName *, boolean *, tp_FilDsc *);
+extern boolean IsErr(void);
+extern void Reset_Err(void);
+extern void Increment_Errors(void);
+extern int Num_Errors(void);
+extern void SysCallError(tp_FilDsc, char *);
+extern void FatalError(char *, char *, int);
+extern void SystemError(char *, ...);
+extern void Local_ErrMessage(tp_Str);
+extern void fatal_err(char *);
+/* pkg/odin/if-file.c */
+extern void Set_ModeMask(tp_FileName);
+extern void MakePlnFile(boolean *, tp_FileName);
+extern void MakeDirFile(boolean *, tp_FileName);
+extern void GetWorkingDir(boolean *, tp_Str);
+extern void ChangeDir(boolean *, tp_FileName);
+extern boolean IsExecutable(tp_FileName);
+extern void MakeExecutable(tp_FileName);
+extern void MakeReadOnly(boolean *, tp_FileName);
+extern void SymLink(boolean *, tp_FileName, tp_FileName);
+extern void FileName_SymLinkFileName(tp_FileName, tp_FileName);
+extern boolean IsDirectory_FileName(tp_FileName);
+extern boolean Exists(tp_FileName);
+extern boolean Empty(tp_FileName);
+extern void FileSize(boolean *, int *, tp_FileName);
+extern void Remove(tp_FileName);
+extern void RemoveDir(tp_FileName);
+extern void Rename(boolean *, tp_FileName, tp_FileName);
+/* pkg/odin/if-io.c */
+extern void Init_IO(void);
+extern boolean GetIsTTY(void);
+extern tp_FilDsc FileName_CFilDsc(tp_FileName);
+extern tp_FilDsc FileName_WFilDsc(tp_FileName, boolean);
+extern tp_FilDsc FileName_WBFilDsc(tp_FileName, boolean);
+extern tp_FilDsc FileName_AFilDsc(tp_FileName, boolean);
+extern tp_FilDsc FileName_RFilDsc(tp_FileName, boolean);
+extern tp_FilDsc FileName_RWFilDsc(tp_FileName, boolean);
+extern tp_FilDsc FileName_RWBFilDsc(tp_FileName, boolean);
+extern void Flush(tp_FilDsc);
+extern void Rewind(tp_FilDsc);
+extern void Unwind(tp_FilDsc);
+extern void Close(tp_FilDsc);
+extern boolean EndOfFile(tp_FilDsc);
+extern void Write(tp_FilDsc, tp_Str);
+extern void Writech(tp_FilDsc, char);
+extern void WriteInt(tp_FilDsc, int);
+extern void Writeln(tp_FilDsc, const char *);
+extern void WriteLine(tp_FilDsc, tp_Str);
+extern int Readch(tp_FilDsc);
+extern tp_Str Readln(tp_Str, tp_FilDsc);
+extern tp_Str ReadLine(tp_Str, tp_FilDsc);
+extern boolean Equal(tp_FilDsc, tp_FilDsc);
+extern void FileCopy(tp_FilDsc, tp_FilDsc);
+/* pkg/odin/if-nod.c */
+extern tp_Nod New_Nod(void);
+extern void Ret_Nod(tp_Nod);
+extern tp_NodTyp Nod_NodTyp(tp_Nod);
+extern void Set_Nod_NodTyp(tp_Nod, tp_NodTyp);
+extern tp_Nod Nod_FirstSon(tp_Nod);
+extern void Set_Nod_FirstSon(tp_Nod, tp_Nod);
+extern tp_Nod Nod_Brother(tp_Nod);
+extern void Set_Nod_Brother(tp_Nod, tp_Nod);
+extern int Nod_NumSons(tp_Nod);
+extern tp_Nod Nod_Son(int, tp_Nod);
+extern tp_Sym Nod_Sym(tp_Nod);
+extern void Set_Nod_Sym(tp_Nod, tp_Sym);
+extern void Push_SymStack(tp_Sym);
+extern void Init_ConstructTree(void);
+extern tp_Nod End_ConstructTree(void);
+extern void Action(int, int);
+/* pkg/odin/if-symbol.c */
+extern tp_Str GetEnv(tp_Str);
+extern tp_Str Malloc_Str(const char *);
+extern boolean Is_EmptyStr(tp_Str);
+extern int Str_PosInt(tp_Str);
+extern tp_Str Tail(tp_Str);
+extern void StrShift(tp_Str, int);
+extern tp_Sym Str_Sym(tp_Str);
+extern tp_Str Sym_Str(tp_Sym);
+extern int Sym_Att(tp_Sym);
+extern void Set_Sym_Att(tp_Sym, int);
+extern void Write_Syms(tp_FilDsc);
diff -ruNx autom4te.cache -x 'config*' pkg/dg/inc/NodTyp_.h pkg/dg/inc/NodTyp_.h
--- pkg/dg/inc/NodTyp_.h	1969-12-31 18:00:00.000000000 -0600
+++ pkg/dg/inc/NodTyp_.h	2016-09-08 11:03:50.039800550 -0500
@@ -0,0 +1,39 @@
+#ifndef TP_YYNODTYP
+#define TP_YYNODTYP
+
+#define NOD_DrvGrf 1
+#define NOD_Banner 2
+#define NOD_SrcDcl 3
+#define NOD_PrmDcl 4
+#define NOD_ObjDcl 5
+#define NOD_ToolDcl 6
+#define NOD_VarDcl 7
+#define NOD_Prefix 8
+#define NOD_Suffix 9
+#define NOD_Hidden 10
+#define NOD_BaseSupertype 11
+#define NOD_Args 12
+#define NOD_Needs 13
+#define NOD_NameInput 14
+#define NOD_ErrOKInput 15
+#define NOD_Results 16
+#define NOD_ForeignResult 17
+#define NOD_OdinExpr 18
+#define NOD_DrvInput 19
+#define NOD_PrmInput 20
+#define NOD_EmptyFile 21
+#define NOD_AbsRoot 22
+#define NOD_AbsFile 23
+#define NOD_PrmOpr 24
+#define NOD_AplOpr 25
+#define NOD_PrmVals 26
+#define NOD_DrvOpr 27
+#define NOD_SecOrdDrvOpr 28
+#define NOD_Oprs 29
+#define NOD_VirSelOpr 30
+#define NOD_SelOpr 31
+#define NOD_DirOpr 32
+#define NOD_VarWord 33
+#define NOD_Word 34
+
+#endif
diff -ruNx autom4te.cache -x 'config*' pkg/dg/inc/TokTyp_.h pkg/dg/inc/TokTyp_.h
--- pkg/dg/inc/TokTyp_.h	1969-12-31 18:00:00.000000000 -0600
+++ pkg/dg/inc/TokTyp_.h	2016-09-08 11:03:50.043800500 -0500
@@ -0,0 +1,25 @@
+#ifndef TP_YYTOKTYP
+#define TP_YYTOKTYP
+
+#define TOK_EOF 0
+#define TOK_ERR 1
+#define TOK_BANNER 2
+#define TOK_NEEDS 3
+#define TOK_Word 4
+#define TOK_Colon 5
+#define TOK_Plus 6
+#define TOK_Equals 7
+#define TOK_LeftParen 8
+#define TOK_RightParen 9
+#define TOK_Percent 10
+#define TOK_Slash 11
+#define TOK_Semicolon 12
+#define TOK_Question 13
+#define TOK_LeftAngle 14
+#define TOK_RightAngle 15
+#define TOK_Ampersand 16
+#define TOK_At 17
+#define TOK_Asterisk 18
+#define TOK_Dollar 19
+
+#endif
diff -ruNx autom4te.cache -x 'config*' pkg/odin/boot/default-dg.c pkg/odin/boot/default-dg.c
--- pkg/odin/boot/default-dg.c	1969-12-31 18:00:00.000000000 -0600
+++ pkg/odin/boot/default-dg.c	2016-09-08 11:04:02.958638139 -0500
@@ -0,0 +1,3785 @@
+char *DG_Version = "1.16.10";
+char *Banner = "";
+#include "inc/GMC.h"
+#include "inc/SrcTyp.h"
+extern tps_SrcTyp _SrcTypS [];
+#include "inc/FilTyp.h"
+extern tps_FilTyp _FilTypS [];
+#include "inc/PrmTyp.h"
+extern tps_PrmTyp _PrmTypS [];
+#include "inc/EnvVar.h"
+extern tps_EnvVar _EnvVarS [];
+#include "inc/EnvVarLst.h"
+extern tps_EnvVarLst _EnvVarLstS [];
+#include "inc/Tool.h"
+extern tps_Tool _ToolS [];
+#include "inc/InpEdg.h"
+extern tps_InpEdg _InpEdgS [];
+#include "inc/MemEdg.h"
+extern tps_MemEdg _MemEdgS [];
+#include "inc/EqvEdg.h"
+extern tps_EqvEdg _EqvEdgS [];
+#include "inc/CastEdg.h"
+extern tps_CastEdg _CastEdgS [];
+#include "inc/DrvEdg.h"
+extern tps_DrvEdg _DrvEdgS [];
+#include "inc/PrmTypLst.h"
+extern tps_PrmTypLst _PrmTypLstS [];
+#include "inc/InpSpc.h"
+extern tps_InpSpc _InpSpcS [];
+int num_SrcTypS = 39;
+tps_SrcTyp _SrcTypS [39] = {
+  {"s.", 1, &_FilTypS[91]},
+  {".tex.vtd", 0, &_FilTypS[292]},
+  {".c++.sm", 0, &_FilTypS[161]},
+  {".cxx.sm", 0, &_FilTypS[161]},
+  {".cc.sm", 0, &_FilTypS[161]},
+  {"odi.SM", 0, &_FilTypS[177]},
+  {".C.sm", 0, &_FilTypS[161]},
+  {".c.sm", 0, &_FilTypS[135]},
+  {".roff", 0, &_FilTypS[268]},
+  {",eqn", 0, &_FilTypS[266]},
+  {".IDL", 0, &_FilTypS[216]},
+  {".bib", 0, &_FilTypS[286]},
+  {".bst", 0, &_FilTypS[289]},
+  {".c++", 0, &_FilTypS[160]},
+  {".cls", 0, &_FilTypS[288]},
+  {".cxx", 0, &_FilTypS[160]},
+  {".exe", 0, &_FilTypS[134]},
+  {".idl", 0, &_FilTypS[216]},
+  {".pdf", 0, &_FilTypS[291]},
+  {".sty", 0, &_FilTypS[287]},
+  {".tbl", 0, &_FilTypS[267]},
+  {".tex", 0, &_FilTypS[285]},
+  {".ygi", 0, &_FilTypS[197]},
+  {",re", 0, &_FilTypS[363]},
+  {",vw", 0, &_FilTypS[92]},
+  {".SM", 0, &_FilTypS[161]},
+  {".cc", 0, &_FilTypS[160]},
+  {".dg", 0, &_FilTypS[206]},
+  {".ps", 0, &_FilTypS[290]},
+  {".sm", 0, &_FilTypS[114]},
+  {",c", 0, &_FilTypS[155]},
+  {",v", 0, &_FilTypS[90]},
+  {".C", 0, &_FilTypS[160]},
+  {".a", 0, &_FilTypS[113]},
+  {".c", 0, &_FilTypS[133]},
+  {".f", 0, &_FilTypS[186]},
+  {".l", 0, &_FilTypS[188]},
+  {".o", 0, &_FilTypS[112]},
+  {".y", 0, &_FilTypS[190]} };
+int num_FilTypS = 367;
+tps_FilTyp _FilTypS [367] = {
+  {1, ":noinput", "", 3, 0, 0, 0, 0, 0, &_DrvEdgS[11], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 0},
+  {1, "OBJECT", "", 3, 0, 0, 0, &_EqvEdgS[191], 0, &_DrvEdgS[70], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 1},
+  {2, "FILE", "", 3, 0, 0, 0, 0, &_CastEdgS[0], &_DrvEdgS[113], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 2},
+  {3, "LIST", "", 3, 0, 0, 0, 0, &_CastEdgS[1], &_DrvEdgS[119], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 3},
+  {4, "VOID", "", 3, 0, 0, 0, 0, &_CastEdgS[2], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 4},
+  {5, "REFERENCE", "", 3, 0, 0, 0, 0, &_CastEdgS[3], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 5},
+  {6, "EXECUTABLE", "", 3, 0, 0, 0, 0, &_CastEdgS[4], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 6},
+  {7, "GENERIC", "", 3, 0, 0, 0, 0, &_CastEdgS[5], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 7},
+  {8, "PIPE", "", 3, 0, 0, 0, 0, &_CastEdgS[6], 0, &_PrmTypLstS[930], 0, 0, 0, 0, 0, 0, 8},
+  {9, "DERIVED-DIRECTORY", "", 3, 0, 0, 0, 0, &_CastEdgS[7], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 9},
+  {2, "odin*expand_hooks", "", 3, 0, &_ToolS[21], 0, &_EqvEdgS[11], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 10},
+  {5, "odin*targets_ptr", "", 3, 0, &_ToolS[8], 0, &_EqvEdgS[0], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 11},
+  {2, "odin*targets", "", 3, 0, &_ToolS[12], 0, &_EqvEdgS[3], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 12},
+  {3, "odin*act_tgt.list", "", 3, 0, &_ToolS[13], 0, &_EqvEdgS[4], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 13},
+  {3, "odin*vir_tgt.list", "", 3, 0, &_ToolS[14], 0, &_EqvEdgS[5], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 14},
+  {9, "odin*vir_dir", "", 3, 0, &_ToolS[15], 0, &_EqvEdgS[6], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 15},
+  {4, "odin*copy", "", 3, 0, &_ToolS[16], 0, &_EqvEdgS[7], 0, 0, &_PrmTypLstS[931], 1, 0, 0, 0, 0, 0, 16},
+  {3, "odin*prm_values", "", 3, 0, &_ToolS[22], 0, &_EqvEdgS[12], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 17},
+  {3, "odin*view_spec", "", 3, 0, &_ToolS[39], 0, &_EqvEdgS[29], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 18},
+  {5, "first", "first object in a list", 2, 0, 0, 0, 0, &_CastEdgS[22], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 19},
+  {5, "odin*apply", "", 3, 0, &_ToolS[41], 0, &_EqvEdgS[31], 0, 0, &_PrmTypLstS[932], 0, 1, 0, 0, 0, 0, 20},
+  {2, "odin*abstract", "the abstract object of an instance", 2, 0, 0, 0, 0, &_CastEdgS[49], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 21},
+  {5, "targets_ptr", "pointer to the targets file", 2, 0, 0, 0, 0, &_CastEdgS[8], &_DrvEdgS[31], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 22},
+  {3, "targets_inc", "directly nested target definitions", 2, 0, 0, 0, 0, &_CastEdgS[10], &_DrvEdgS[89], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 23},
+  {3, "all_targets_inc", "all nested target definitions", 2, 0, 0, 0, 0, &_CastEdgS[11], 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 24},
+  {2, "targets", "target definitions from an Odinfile", 2, 0, 0, 0, 0, &_CastEdgS[12], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 25},
+  {2, "vtd", "Virtual target definition file", 1, 0, 0, 0, 0, &_CastEdgS[13], 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 26},
+  {3, "act_tgt.list", "actual targets", 2, 0, 0, 0, 0, &_CastEdgS[14], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 27},
+  {3, "vir_tgt.list", "virtual targets", 2, 0, 0, 0, 0, &_CastEdgS[15], &_DrvEdgS[29], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 28},
+  {9, "vir_dir", "a virtual directory", 2, 0, 0, 0, 0, &_CastEdgS[16], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 29},
+  {2, "atmc_prm_data", "file containing parameter data", 2, 0, 0, 0, 0, &_CastEdgS[17], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 30},
+  {3, "cmpd_prm_data", "file containing parameter data", 2, 0, 0, 0, 0, &_CastEdgS[18], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 31},
+  {4, "copy", "copy", 2, 0, 0, 0, 0, &_CastEdgS[19], 0, &_PrmTypLstS[931], 0, 0, 0, 0, 0, 0, 32},
+  {3, "copy_cmd", "copy command", 2, 0, 0, 0, 0, &_CastEdgS[20], 0, &_PrmTypLstS[933], 0, 0, 0, 0, 0, 0, 33},
+  {3, "prm_values", "list of parameter values", 2, 0, 0, 0, 0, &_CastEdgS[21], 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 34},
+  {2, "expand_hooks", "expand hooks", 2, 0, 0, 0, 0, &_CastEdgS[23], 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 35},
+  {3, "nested_hooks", "nested hooks", 2, 0, 0, 0, 0, &_CastEdgS[24], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 36},
+  {2, "hook_values.of", "Odinfile containing hook values", 2, 0, 0, 0, 0, &_CastEdgS[25], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 37},
+  {2, "err", "errors", 1, 0, 0, 0, 0, &_CastEdgS[26], &_DrvEdgS[28], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 38},
+  {2, "warn", "warnings", 1, 0, 0, 0, 0, &_CastEdgS[27], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 39},
+  {5, "dir", "directory of a file", 1, 0, 0, 0, 0, &_CastEdgS[28], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 40},
+  {2, "name", "name of a file", 1, 0, 0, 0, 0, &_CastEdgS[29], 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 41},
+  {2, "names", "names of the elements of a list", 1, 0, 0, 0, 0, &_CastEdgS[30], 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 42},
+  {2, "filename", "filename of a file", 1, 0, 0, 0, 0, &_CastEdgS[31], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 43},
+  {2, "ls", "filenames of the elements of a list", 1, 0, 0, 0, 0, &_CastEdgS[32], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 44},
+  {2, "cat", "concatenation of the contents of the elements of a list", 1, 0, 0, 0, 0, &_CastEdgS[33], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 45},
+  {3, "union", "list union", 1, 0, 0, 0, 0, &_CastEdgS[34], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 46},
+  {2, "label", "label of a file", 1, 0, 0, 0, 0, &_CastEdgS[35], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 47},
+  {2, "labels", "labels of the elements of a list", 1, 0, 0, 0, 0, &_CastEdgS[36], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 48},
+  {2, "id", "id of an object", 2, 0, 0, 0, 0, &_CastEdgS[37], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 49},
+  {3, "depend", "source dependencies", 1, 0, 0, 0, 0, &_CastEdgS[38], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 50},
+  {2, "source_names", "source components of a system model", 2, 0, 0, 0, 0, &_CastEdgS[39], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 51},
+  {2, "operation_names", "operation components of a system model", 2, 0, 0, 0, 0, &_CastEdgS[40], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 52},
+  {3, "view_spec", "view specification", 2, 0, 0, 0, 0, &_CastEdgS[41], &_DrvEdgS[86], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 53},
+  {3, "view", "view derived from a view specification", 2, 0, 0, 0, 0, &_CastEdgS[42], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 54},
+  {5, "apply", "apply operations from a file", 2, 0, 0, 0, 0, &_CastEdgS[43], 0, &_PrmTypLstS[932], 0, 1, 0, 0, 0, 0, 55},
+  {6, "odin_help", "top level help for odin", 2, 0, 0, 0, 0, &_CastEdgS[44], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 56},
+  {2, "prefix_help", "list of known prefixes", 2, 0, 0, 0, 0, &_CastEdgS[45], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 57},
+  {2, "suffix_help", "list of known suffixes", 2, 0, 0, 0, 0, &_CastEdgS[46], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 58},
+  {2, "drv_help", "applicable derivation types", 2, 0, 0, 0, 0, &_CastEdgS[47], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 59},
+  {2, "prm_help", "applicable parameter types", 2, 0, 0, 0, 0, &_CastEdgS[48], 0, &_PrmTypLstS[934], 0, 0, 0, 0, 0, 0, 60},
+  {3, "odin*targets_inc", "", 3, 0, &_ToolS[9], 0, &_EqvEdgS[1], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 61},
+  {3, "odin*all_targets_inc", "", 3, 0, &_ToolS[10], 0, &_EqvEdgS[2], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 62},
+  {3, "map", "", 2, &_FilTypS[24], &_ToolS[11], 0, 0, &_CastEdgS[50], 0, &_PrmTypLstS[239], 0, 0, 1, 0, 0, 0, 63},
+  {3, "odin*copy_cmd", "", 3, 0, &_ToolS[17], 0, &_EqvEdgS[8], 0, 0, &_PrmTypLstS[933], 0, 0, 0, 0, 0, 0, 64},
+  {10, "odin*nested_hooks*composite", "", 3, 0, &_ToolS[20], &_MemEdgS[0], 0, 0, &_DrvEdgS[88], &_PrmTypLstS[239], 0, 0, 1, 0, 0, 0, 65},
+  {3, "odin*nested_hooks", "", 3, 0, &_ToolS[18], 0, &_EqvEdgS[9], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 66},
+  {2, "odin*hook_values.of", "", 3, 0, &_ToolS[19], 0, &_EqvEdgS[10], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 67},
+  {5, "odin*first", "", 3, 0, &_ToolS[23], 0, &_EqvEdgS[13], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 68},
+  {2, "odin*err", "", 3, 0, &_ToolS[24], 0, &_EqvEdgS[14], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 69},
+  {2, "odin*warn", "", 3, 0, &_ToolS[25], 0, &_EqvEdgS[15], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 70},
+  {5, "odin*dir", "", 3, 0, &_ToolS[26], 0, &_EqvEdgS[16], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 71},
+  {2, "odin*name", "", 3, 0, &_ToolS[27], 0, &_EqvEdgS[17], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 72},
+  {2, "odin*names", "", 3, 0, &_ToolS[28], 0, &_EqvEdgS[18], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 73},
+  {2, "odin*filename", "", 3, 0, &_ToolS[29], 0, &_EqvEdgS[19], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 74},
+  {2, "odin*ls", "", 3, 0, &_ToolS[30], 0, &_EqvEdgS[20], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 75},
+  {2, "odin*cat", "", 3, 0, &_ToolS[31], 0, &_EqvEdgS[21], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 76},
+  {3, "odin*union", "", 3, 0, &_ToolS[32], 0, &_EqvEdgS[22], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 77},
+  {2, "odin*label", "", 3, 0, &_ToolS[33], 0, &_EqvEdgS[23], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 78},
+  {2, "odin*labels", "", 3, 0, &_ToolS[34], 0, &_EqvEdgS[24], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 79},
+  {2, "odin*id", "", 3, 0, &_ToolS[35], 0, &_EqvEdgS[25], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 80},
+  {3, "odin*depend", "", 3, 0, &_ToolS[36], 0, &_EqvEdgS[26], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 81},
+  {2, "odin*source_names", "", 3, 0, &_ToolS[37], 0, &_EqvEdgS[27], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 82},
+  {2, "odin*operation_names", "", 3, 0, &_ToolS[38], 0, &_EqvEdgS[28], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 83},
+  {3, "odin*view", "", 3, 0, &_ToolS[40], 0, &_EqvEdgS[30], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 84},
+  {6, "odin*odin_help", "", 3, 0, &_ToolS[42], 0, &_EqvEdgS[32], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 85},
+  {2, "odin*prefix_help", "", 3, 0, &_ToolS[43], 0, &_EqvEdgS[33], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 86},
+  {2, "odin*suffix_help", "", 3, 0, &_ToolS[44], 0, &_EqvEdgS[34], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 87},
+  {2, "odin*drv_help", "", 3, 0, &_ToolS[45], 0, &_EqvEdgS[35], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 88},
+  {2, "odin*prm_help", "", 3, 0, &_ToolS[46], 0, &_EqvEdgS[36], 0, 0, &_PrmTypLstS[934], 0, 0, 0, 0, 0, 0, 89},
+  {2, ",v", "RCS version control file", 1, 0, 0, 0, 0, &_CastEdgS[51], &_DrvEdgS[121], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 90},
+  {2, "sccs", "SCCS version control file", 1, 0, 0, 0, 0, &_CastEdgS[52], &_DrvEdgS[123], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 91},
+  {2, ",vw", "a view-path system model", 1, 0, 0, 0, 0, &_CastEdgS[53], &_DrvEdgS[127], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 92},
+  {2, "view.source.spec", "specification of all possible source files in the view", 2, 0, 0, 0, 0, &_CastEdgS[54], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 93},
+  {7, "view.names", "names of files in the view", 2, 0, 0, 0, &_EqvEdgS[37], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 94},
+  {2, "vw.of", "odinfile containing the view versions", 2, 0, 0, 0, 0, &_CastEdgS[55], &_DrvEdgS[124], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 95},
+  {7, "sccs.co", "version from a version control file", 2, 0, 0, 0, &_EqvEdgS[38], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 96},
+  {7, "co", "version from a version control file", 2, 0, 0, 0, &_EqvEdgS[39], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 97},
+  {2, "try.co", "co if possible", 2, 0, 0, 0, 0, &_CastEdgS[57], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 98},
+  {5, "vw.dir", "a directory containing the view versions", 2, 0, 0, 0, 0, &_CastEdgS[58], 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 99},
+  {2, "sccs.log", "log file", 1, 0, 0, 0, &_EqvEdgS[41], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 100},
+  {2, "log", "log file", 1, 0, 0, 0, 0, &_CastEdgS[59], 0, &_PrmTypLstS[959], 0, 0, 0, 0, 0, 0, 101},
+  {2, "vc*log", "", 3, 0, &_ToolS[47], 0, &_EqvEdgS[42], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 102},
+  {7, "vc*co", "", 3, 0, &_ToolS[48], 0, &_EqvEdgS[43], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 103},
+  {7, "vc*sccs.co", "", 3, 0, &_ToolS[49], 0, &_EqvEdgS[44], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 104},
+  {2, "vc*sccs.log", "", 3, 0, &_ToolS[50], 0, &_EqvEdgS[45], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 105},
+  {2, "vc*view.source.spec", "", 3, 0, &_ToolS[51], 0, &_EqvEdgS[46], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 106},
+  {7, "vc*view.names", "", 3, 0, &_ToolS[52], 0, &_EqvEdgS[47], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 107},
+  {2, "vc*vw.of", "", 3, 0, &_ToolS[53], 0, &_EqvEdgS[48], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 108},
+  {3, "list", "read a list from a file", 2, 0, 0, 0, 0, &_CastEdgS[118], 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 109},
+  {3, "map", "", 2, &_FilTypS[98], &_ToolS[54], 0, 0, &_CastEdgS[60], 0, &_PrmTypLstS[239], 0, 0, 1, 0, 0, 0, 110},
+  {5, "vc*vw.dir", "", 3, 0, &_ToolS[55], 0, &_EqvEdgS[49], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 111},
+  {2, "o", "object module", 2, 0, 0, 0, 0, &_CastEdgS[61], 0, &_PrmTypLstS[477], 0, 0, 0, 0, 0, 0, 112},
+  {2, "a", "object library archive", 1, 0, 0, 0, 0, &_CastEdgS[68], 0, &_PrmTypLstS[544], 0, 1, 0, 0, 0, 0, 113},
+  {2, "sm", "system model of source code files", 1, 0, 0, 0, 0, &_CastEdgS[63], &_DrvEdgS[128], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 114},
+  {2, "o_src", "source code for object module", 2, 0, 0, 0, 0, &_CastEdgS[62], 0, &_PrmTypLstS[324], 0, 0, 0, 0, 0, 0, 115},
+  {3, "sm.list", "list of files in a system model", 2, 0, 0, 0, 0, &_CastEdgS[64], &_DrvEdgS[5], &_PrmTypLstS[544], 0, 1, 0, 0, 0, 0, 116},
+  {3, "code.list", "list of code files", 2, 0, 0, 0, 0, &_CastEdgS[65], &_DrvEdgS[4], &_PrmTypLstS[544], 0, 1, 0, 0, 0, 0, 117},
+  {2, "libraries.view_desc", "library view description", 2, 0, 0, 0, 0, &_CastEdgS[66], &_DrvEdgS[6], &_PrmTypLstS[966], 0, 0, 0, 0, 0, 0, 118},
+  {2, "o_of", "odinfile containing the object modules", 2, 0, 0, 0, 0, &_CastEdgS[67], &_DrvEdgS[2], &_PrmTypLstS[544], 0, 0, 0, 0, 0, 0, 119},
+  {2, "library_flags", "library command line flags", 2, 0, 0, 0, 0, &_CastEdgS[69], 0, &_PrmTypLstS[966], 0, 0, 0, 0, 0, 0, 120},
+  {3, "libraries", "library references", 2, 0, 0, 0, 0, &_CastEdgS[70], 0, &_PrmTypLstS[966], 0, 1, 0, 0, 0, 0, 121},
+  {3, "code*sm.list", "", 3, 0, &_ToolS[56], 0, &_EqvEdgS[50], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 122},
+  {3, "code*code.list", "", 3, 0, &_ToolS[57], 0, &_EqvEdgS[51], 0, 0, &_PrmTypLstS[544], 0, 1, 0, 0, 0, 0, 123},
+  {3, "recurse", "", 2, &_FilTypS[116], &_ToolS[58], 0, 0, &_CastEdgS[71], 0, &_PrmTypLstS[239], 0, 0, 1, 0, 0, 0, 124},
+  {2, "code*o_of", "", 3, 0, &_ToolS[59], 0, &_EqvEdgS[52], 0, 0, &_PrmTypLstS[544], 0, 0, 0, 0, 0, 0, 125},
+  {3, "map", "", 2, &_FilTypS[115], &_ToolS[60], 0, 0, &_CastEdgS[72], 0, &_PrmTypLstS[239], 0, 0, 1, 0, 0, 0, 126},
+  {3, "map", "", 2, &_FilTypS[112], &_ToolS[61], 0, 0, &_CastEdgS[73], 0, &_PrmTypLstS[239], 0, 0, 1, 0, 0, 0, 127},
+  {2, "code*a", "", 3, 0, &_ToolS[62], 0, &_EqvEdgS[53], 0, 0, &_PrmTypLstS[544], 0, 0, 0, 0, 0, 0, 128},
+  {10, "code*libraries.view_desc*composite", "", 3, 0, &_ToolS[65], &_MemEdgS[2], 0, 0, &_DrvEdgS[8], &_PrmTypLstS[966], 0, 0, 0, 0, 0, 0, 129},
+  {2, "code*libraries.view_desc", "", 3, 0, &_ToolS[63], 0, &_EqvEdgS[54], 0, 0, &_PrmTypLstS[966], 0, 0, 0, 0, 0, 0, 130},
+  {2, "code*library_flags", "", 3, 0, &_ToolS[64], 0, &_EqvEdgS[55], 0, 0, &_PrmTypLstS[966], 0, 0, 0, 0, 0, 0, 131},
+  {3, "code*libraries", "", 3, 0, &_ToolS[66], 0, &_EqvEdgS[56], 0, 0, &_PrmTypLstS[966], 0, 1, 0, 0, 0, 0, 132},
+  {2, "c", "C source code", 1, 0, 0, 0, &_EqvEdgS[57], &_CastEdgS[96], &_DrvEdgS[135], &_PrmTypLstS[324], 0, 0, 0, 0, 0, 0, 133},
+  {2, "exe", "executable binary", 1, 0, 0, 0, 0, &_CastEdgS[79], &_DrvEdgS[1], &_PrmTypLstS[833], 0, 0, 0, 0, 0, 0, 134},
+  {2, "c.sm", "system model for a C program", 1, 0, 0, 0, 0, &_CastEdgS[74], &_DrvEdgS[136], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 135},
+  {3, "c.one.list", "list of a single C file", 2, 0, 0, 0, &_EqvEdgS[58], 0, &_DrvEdgS[178], &_PrmTypLstS[324], 0, 1, 0, 0, 0, 0, 136},
+  {3, "c.exe.list", "list of files in a C system", 2, 0, 0, 0, 0, &_CastEdgS[75], 0, &_PrmTypLstS[324], 0, 1, 0, 0, 0, 0, 137},
+  {3, "c.sm.list", "list of files in a C system model", 2, 0, 0, 0, &_EqvEdgS[60], 0, &_DrvEdgS[179], &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 138},
+  {2, "c_inc.view_desc", "view description of C-style included files", 2, 0, 0, 0, 0, &_CastEdgS[76], &_DrvEdgS[85], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 139},
+  {3, "c_inc", "list of potential C-style included files", 2, 0, 0, 0, 0, &_CastEdgS[77], &_DrvEdgS[84], &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 140},
+  {3, "all_c_inc", "list of C-style transitively included files", 2, 0, 0, 0, 0, &_CastEdgS[78], 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 141},
+  {8, "fmt", "formatted version", 2, 0, 0, 0, &_EqvEdgS[62], 0, 0, &_PrmTypLstS[324], 0, 0, 0, 0, 0, 0, 142},
+  {2, "c.h", "C function declarations", 2, 0, 0, 0, 0, &_CastEdgS[80], 0, &_PrmTypLstS[324], 0, 0, 0, 0, 0, 0, 143},
+  {3, "cc*c.one.list", "", 3, 0, &_ToolS[67], 0, &_EqvEdgS[63], 0, 0, &_PrmTypLstS[324], 0, 1, 0, 0, 0, 0, 144},
+  {3, "cc*c.sm.list", "", 3, 0, &_ToolS[68], 0, &_EqvEdgS[64], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 145},
+  {2, "cc*c_inc.view_desc", "", 3, 0, &_ToolS[69], 0, &_EqvEdgS[65], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 146},
+  {3, "cc*c_inc", "", 3, 0, &_ToolS[70], 0, &_EqvEdgS[66], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 147},
+  {3, "cc*all_c_inc", "", 3, 0, &_ToolS[71], 0, &_EqvEdgS[67], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 148},
+  {3, "map", "", 2, &_FilTypS[141], &_ToolS[72], 0, 0, &_CastEdgS[81], 0, &_PrmTypLstS[239], 0, 0, 1, 0, 0, 0, 149},
+  {2, "cc*o", "", 3, 0, &_ToolS[73], 0, &_EqvEdgS[68], 0, 0, &_PrmTypLstS[456], 0, 0, 0, 0, 0, 0, 150},
+  {5, "lookup", "", 2, &_FilTypS[141], &_ToolS[74], 0, 0, &_CastEdgS[82], 0, &_PrmTypLstS[239], 0, 0, 1, 0, 0, 0, 151},
+  {2, "cc*exe", "", 3, 0, &_ToolS[75], 0, &_EqvEdgS[69], 0, 0, &_PrmTypLstS[833], 0, 0, 0, 0, 0, 0, 152},
+  {8, "cc*fmt", "", 3, 0, &_ToolS[76], 0, &_EqvEdgS[70], 0, 0, &_PrmTypLstS[324], 0, 0, 0, 0, 0, 0, 153},
+  {2, "cc*c.h", "", 3, 0, &_ToolS[77], 0, &_EqvEdgS[71], 0, 0, &_PrmTypLstS[324], 0, 0, 0, 0, 0, 0, 154},
+  {2, "cpp_in", "cpp input", 1, 0, 0, 0, 0, &_CastEdgS[83], &_DrvEdgS[137], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 155},
+  {8, "cpp", "output from cpp pre-processor", 2, 0, 0, 0, &_EqvEdgS[72], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 156},
+  {7, "gnc.cpp", "output from cpp pre-processor", 2, 0, 0, 0, &_EqvEdgS[73], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 157},
+  {8, "cpp*cpp", "", 3, 0, &_ToolS[78], 0, &_EqvEdgS[74], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 158},
+  {7, "cpp*gnc.cpp", "", 3, 0, &_ToolS[79], 0, &_EqvEdgS[75], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 159},
+  {2, "cxx", "C++ source code", 1, 0, 0, 0, &_EqvEdgS[76], 0, &_DrvEdgS[139], &_PrmTypLstS[264], 0, 0, 0, 0, 0, 0, 160},
+  {2, "cxx.sm", "system model for a C++ program", 1, 0, 0, 0, 0, &_CastEdgS[84], &_DrvEdgS[140], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 161},
+  {2, "cxx_inc.view_desc", "view description of C++ style included files", 2, 0, 0, 0, 0, &_CastEdgS[85], &_DrvEdgS[83], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 162},
+  {3, "cxx_inc", "list of potential C++ style included files", 2, 0, 0, 0, 0, &_CastEdgS[86], &_DrvEdgS[82], &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 163},
+  {3, "all_cxx_inc", "list of C++ style transitively included files", 2, 0, 0, 0, 0, &_CastEdgS[87], 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 164},
+  {3, "cxx.one.list", "list of a single C++ file", 2, 0, 0, 0, &_EqvEdgS[77], 0, &_DrvEdgS[180], &_PrmTypLstS[264], 0, 1, 0, 0, 0, 0, 165},
+  {3, "cxx.exe.list", "list of files in a C++ system", 2, 0, 0, 0, 0, &_CastEdgS[88], 0, &_PrmTypLstS[544], 0, 1, 0, 0, 0, 0, 166},
+  {3, "cxx.sm.list", "list of files in a C++ system model", 2, 0, 0, 0, &_EqvEdgS[79], 0, &_DrvEdgS[170], &_PrmTypLstS[544], 0, 1, 0, 0, 0, 0, 167},
+  {3, "cxx*cxx.one.list", "", 3, 0, &_ToolS[80], 0, &_EqvEdgS[81], 0, 0, &_PrmTypLstS[264], 0, 1, 0, 0, 0, 0, 168},
+  {3, "cxx*cxx.sm.list", "", 3, 0, &_ToolS[81], 0, &_EqvEdgS[82], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 169},
+  {2, "cxx*cxx_inc.view_desc", "", 3, 0, &_ToolS[82], 0, &_EqvEdgS[83], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 170},
+  {3, "cxx*cxx_inc", "", 3, 0, &_ToolS[83], 0, &_EqvEdgS[84], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 171},
+  {3, "cxx*all_cxx_inc", "", 3, 0, &_ToolS[84], 0, &_EqvEdgS[85], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 172},
+  {3, "map", "", 2, &_FilTypS[164], &_ToolS[85], 0, 0, &_CastEdgS[89], 0, &_PrmTypLstS[239], 0, 0, 1, 0, 0, 0, 173},
+  {2, "cxx*o", "", 3, 0, &_ToolS[86], 0, &_EqvEdgS[86], 0, 0, &_PrmTypLstS[410], 0, 0, 0, 0, 0, 0, 174},
+  {5, "lookup", "", 2, &_FilTypS[164], &_ToolS[87], 0, 0, &_CastEdgS[90], 0, &_PrmTypLstS[239], 0, 0, 1, 0, 0, 0, 175},
+  {2, "cxx*exe", "", 3, 0, &_ToolS[88], 0, &_EqvEdgS[87], 0, 0, &_PrmTypLstS[833], 0, 0, 0, 0, 0, 0, 176},
+  {2, "odi.cxx.sm", "system model for an ODI C++ program", 1, 0, 0, 0, 0, &_CastEdgS[91], &_DrvEdgS[141], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 177},
+  {3, "odi.cxx.sm.list", "list of files in a C++ system model", 2, 0, 0, 0, &_EqvEdgS[88], 0, &_DrvEdgS[182], &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 178},
+  {2, "schema.C", "ObjectStore schema source module", 2, 0, 0, 0, 0, &_CastEdgS[92], 0, &_PrmTypLstS[544], 0, 0, 0, 0, 0, 0, 179},
+  {2, "com_schema_standin", "compiled ObjectStore schema", 2, 0, 0, 0, 0, &_CastEdgS[93], 0, &_PrmTypLstS[523], 0, 0, 0, 0, 0, 0, 180},
+  {3, "odi*odi.cxx.sm.list", "", 3, 0, &_ToolS[89], 0, &_EqvEdgS[89], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 181},
+  {2, "odi*com_schema_standin", "", 3, 0, &_ToolS[90], 0, &_EqvEdgS[90], 0, 0, &_PrmTypLstS[523], 0, 0, 0, 0, 0, 0, 182},
+  {3, "map", "", 2, &_FilTypS[40], &_ToolS[91], 0, 0, &_CastEdgS[94], 0, &_PrmTypLstS[239], 0, 0, 1, 0, 0, 0, 183},
+  {2, "odi*schema.C", "", 3, 0, &_ToolS[92], 0, &_EqvEdgS[91], 0, 0, &_PrmTypLstS[544], 0, 0, 0, 0, 0, 0, 184},
+  {3, "odi*cxx.sm.list", "", 3, 0, &_ToolS[93], 0, &_EqvEdgS[92], 0, 0, &_PrmTypLstS[544], 0, 1, 0, 0, 0, 0, 185},
+  {2, "f", "Fortran77 source code", 1, 0, 0, 0, &_EqvEdgS[93], 0, &_DrvEdgS[142], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 186},
+  {2, "f77*o", "", 3, 0, &_ToolS[94], 0, &_EqvEdgS[94], 0, 0, &_PrmTypLstS[380], 0, 0, 0, 0, 0, 0, 187},
+  {2, "l", "scanner grammar", 1, 0, 0, 0, 0, &_CastEdgS[95], &_DrvEdgS[143], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 188},
+  {2, "lex*c", "", 3, 0, &_ToolS[95], 0, &_EqvEdgS[95], 0, 0, &_PrmTypLstS[309], 0, 0, 0, 0, 0, 0, 189},
+  {2, "y", "yacc input", 1, 0, 0, 0, 0, &_CastEdgS[97], &_DrvEdgS[147], &_PrmTypLstS[309], 0, 0, 0, 0, 0, 0, 190},
+  {2, "h", "header file", 1, 0, 0, 0, 0, &_CastEdgS[98], 0, &_PrmTypLstS[299], 0, 0, 0, 0, 0, 0, 191},
+  {2, "yacc.log", "yacc table listing", 2, 0, 0, 0, &_EqvEdgS[96], 0, 0, &_PrmTypLstS[299], 0, 0, 0, 0, 0, 0, 192},
+  {10, "yacc*c*composite", "", 3, 0, &_ToolS[99], &_MemEdgS[4], 0, 0, &_DrvEdgS[146], &_PrmTypLstS[299], 0, 0, 0, 0, 0, 0, 193},
+  {2, "yacc*c", "", 3, 0, &_ToolS[96], 0, &_EqvEdgS[97], 0, 0, &_PrmTypLstS[299], 0, 0, 0, 0, 0, 0, 194},
+  {2, "yacc*h", "", 3, 0, &_ToolS[97], 0, &_EqvEdgS[98], 0, 0, &_PrmTypLstS[299], 0, 0, 0, 0, 0, 0, 195},
+  {2, "yacc*yacc.log", "", 3, 0, &_ToolS[98], 0, &_EqvEdgS[99], 0, 0, &_PrmTypLstS[299], 0, 0, 0, 0, 0, 0, 196},
+  {2, "ygi", "input grammar for the Tregrm tree-building parser generator", 1, 0, 0, 0, 0, &_CastEdgS[99], &_DrvEdgS[152], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 197},
+  {2, "nod.h", "parser node types", 2, 0, 0, 0, &_EqvEdgS[100], 0, 0, &_PrmTypLstS[309], 0, 0, 0, 0, 0, 0, 198},
+  {2, "tok.h", "parser token types", 2, 0, 0, 0, &_EqvEdgS[101], 0, 0, &_PrmTypLstS[309], 0, 0, 0, 0, 0, 0, 199},
+  {2, "ygi.log", "Tregrm listing", 2, 0, 0, 0, &_EqvEdgS[102], 0, 0, &_PrmTypLstS[309], 0, 0, 0, 0, 0, 0, 200},
+  {10, "tregrm*y*composite", "", 3, 0, &_ToolS[104], &_MemEdgS[7], 0, 0, &_DrvEdgS[151], &_PrmTypLstS[309], 0, 0, 0, 0, 0, 0, 201},
+  {2, "tregrm*y", "", 3, 0, &_ToolS[100], 0, &_EqvEdgS[103], 0, 0, &_PrmTypLstS[309], 0, 0, 0, 0, 0, 0, 202},
+  {2, "tregrm*nod.h", "", 3, 0, &_ToolS[101], 0, &_EqvEdgS[104], 0, 0, &_PrmTypLstS[309], 0, 0, 0, 0, 0, 0, 203},
+  {2, "tregrm*tok.h", "", 3, 0, &_ToolS[102], 0, &_EqvEdgS[105], 0, 0, &_PrmTypLstS[309], 0, 0, 0, 0, 0, 0, 204},
+  {2, "tregrm*ygi.log", "", 3, 0, &_ToolS[103], 0, &_EqvEdgS[106], 0, 0, &_PrmTypLstS[309], 0, 0, 0, 0, 0, 0, 205},
+  {2, "dg", "Odin Derivation Graph", 1, 0, 0, 0, 0, &_CastEdgS[100], &_DrvEdgS[157], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 206},
+  {2, "dg.log", "Derivation Graph log", 1, 0, 0, 0, &_EqvEdgS[107], 0, 0, &_PrmTypLstS[274], 0, 0, 0, 0, 0, 0, 207},
+  {2, "dg.tab", "Derivation Graph tables", 1, 0, 0, 0, 0, &_CastEdgS[101], 0, &_PrmTypLstS[274], 0, 0, 0, 0, 0, 0, 208},
+  {2, "dg.env", "Derivation Graph environment variable definitions", 1, 0, 0, 0, 0, &_CastEdgS[102], 0, &_PrmTypLstS[274], 0, 0, 0, 0, 0, 0, 209},
+  {10, "dg*dg.log*composite", "", 3, 0, &_ToolS[109], &_MemEdgS[11], 0, 0, &_DrvEdgS[156], &_PrmTypLstS[274], 0, 0, 0, 0, 0, 0, 210},
+  {2, "dg*dg.log", "", 3, 0, &_ToolS[105], 0, &_EqvEdgS[108], 0, 0, &_PrmTypLstS[274], 0, 0, 0, 0, 0, 0, 211},
+  {2, "dg*c", "", 3, 0, &_ToolS[106], 0, &_EqvEdgS[109], 0, 0, &_PrmTypLstS[274], 0, 0, 0, 0, 0, 0, 212},
+  {2, "dg*dg.tab", "", 3, 0, &_ToolS[107], 0, &_EqvEdgS[110], 0, 0, &_PrmTypLstS[274], 0, 0, 0, 0, 0, 0, 213},
+  {2, "dg*dg.env", "", 3, 0, &_ToolS[108], 0, &_EqvEdgS[111], 0, 0, &_PrmTypLstS[274], 0, 0, 0, 0, 0, 0, 214},
+  {8, "regsub", "output from regsub substitution", 2, 0, 0, 0, &_EqvEdgS[187], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 215},
+  {2, "IDL", "C++ Interface Definition Language file", 2, 0, 0, 0, 0, &_CastEdgS[103], &_DrvEdgS[166], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 216},
+  {2, "idl_inc.view_desc", "view description of IDL-style included files", 2, 0, 0, 0, 0, &_CastEdgS[104], &_DrvEdgS[81], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 217},
+  {3, "idl_inc", "list of potential IDL-style included files", 2, 0, 0, 0, 0, &_CastEdgS[105], &_DrvEdgS[80], &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 218},
+  {3, "all_idl_inc", "list of IDL-style transitively included files", 2, 0, 0, 0, 0, &_CastEdgS[106], 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 219},
+  {9, "idl_h_dir", "header files", 1, 0, 0, 0, 0, &_CastEdgS[107], 0, &_PrmTypLstS[264], 0, 0, 0, 0, 0, 0, 220},
+  {2, "client.C", "client side class implementation", 2, 0, 0, 0, &_EqvEdgS[112], 0, 0, &_PrmTypLstS[264], 0, 0, 0, 0, 0, 0, 221},
+  {2, "sstub.c", "server stubs", 2, 0, 0, 0, &_EqvEdgS[113], 0, 0, &_PrmTypLstS[264], 0, 0, 0, 0, 0, 0, 222},
+  {2, "cstub.c", "client stubs", 2, 0, 0, 0, &_EqvEdgS[114], 0, 0, &_PrmTypLstS[264], 0, 0, 0, 0, 0, 0, 223},
+  {2, "epv.C", "Entry point vector for server", 2, 0, 0, 0, &_EqvEdgS[115], 0, 0, &_PrmTypLstS[264], 0, 0, 0, 0, 0, 0, 224},
+  {5, "idl.a", "library of idl generated routines", 1, 0, 0, 0, &_EqvEdgS[116], &_CastEdgS[108], 0, &_PrmTypLstS[477], 0, 1, 0, 0, 0, 0, 225},
+  {3, "idl_lib.list", "idl generated routines", 2, 0, 0, 0, &_EqvEdgS[117], 0, 0, &_PrmTypLstS[264], 0, 1, 0, 0, 0, 0, 226},
+  {2, "idl_targets", "header file and library targets for an idl file", 2, 0, 0, 0, 0, &_CastEdgS[109], 0, &_PrmTypLstS[477], 0, 0, 0, 0, 0, 0, 227},
+  {2, "idl*idl_inc.view_desc", "", 3, 0, &_ToolS[110], 0, &_EqvEdgS[118], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 228},
+  {3, "idl*idl_inc", "", 3, 0, &_ToolS[111], 0, &_EqvEdgS[119], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 229},
+  {3, "idl*all_idl_inc", "", 3, 0, &_ToolS[112], 0, &_EqvEdgS[120], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 230},
+  {3, "map", "", 2, &_FilTypS[219], &_ToolS[113], 0, 0, &_CastEdgS[110], 0, &_PrmTypLstS[239], 0, 0, 1, 0, 0, 0, 231},
+  {10, "idl*idl_h_dir*composite", "", 3, 0, &_ToolS[119], &_MemEdgS[15], 0, 0, &_DrvEdgS[164], &_PrmTypLstS[264], 0, 0, 0, 0, 0, 0, 232},
+  {9, "idl*idl_h_dir", "", 3, 0, &_ToolS[114], 0, &_EqvEdgS[121], 0, 0, &_PrmTypLstS[264], 0, 0, 0, 0, 0, 0, 233},
+  {2, "idl*client.C", "", 3, 0, &_ToolS[115], 0, &_EqvEdgS[122], 0, 0, &_PrmTypLstS[264], 0, 0, 0, 0, 0, 0, 234},
+  {2, "idl*epv.C", "", 3, 0, &_ToolS[116], 0, &_EqvEdgS[123], 0, 0, &_PrmTypLstS[264], 0, 0, 0, 0, 0, 0, 235},
+  {2, "idl*sstub.c", "", 3, 0, &_ToolS[117], 0, &_EqvEdgS[124], 0, 0, &_PrmTypLstS[264], 0, 0, 0, 0, 0, 0, 236},
+  {2, "idl*cstub.c", "", 3, 0, &_ToolS[118], 0, &_EqvEdgS[125], 0, 0, &_PrmTypLstS[264], 0, 0, 0, 0, 0, 0, 237},
+  {5, "lookup", "", 2, &_FilTypS[219], &_ToolS[120], 0, 0, &_CastEdgS[111], 0, &_PrmTypLstS[239], 0, 0, 1, 0, 0, 0, 238},
+  {3, "idl*idl_lib.list", "", 3, 0, &_ToolS[121], 0, &_EqvEdgS[126], 0, 0, &_PrmTypLstS[264], 0, 1, 0, 0, 0, 0, 239},
+  {5, "idl*idl.a", "", 3, 0, &_ToolS[122], 0, &_EqvEdgS[127], 0, 0, &_PrmTypLstS[477], 0, 1, 0, 0, 0, 0, 240},
+  {2, "idl*idl_targets", "", 3, 0, &_ToolS[123], 0, &_EqvEdgS[128], 0, 0, &_PrmTypLstS[477], 0, 0, 0, 0, 0, 0, 241},
+  {2, "profile", "execution profile", 1, 0, 0, 0, 0, &_CastEdgS[112], 0, &_PrmTypLstS[1016], 0, 0, 0, 0, 0, 0, 242},
+  {2, "prof*profile", "", 3, 0, &_ToolS[124], 0, &_EqvEdgS[129], 0, 0, &_PrmTypLstS[1016], 0, 0, 0, 0, 0, 0, 243},
+  {2, "ln", "local static semantic analysis of C code", 2, 0, 0, 0, 0, &_CastEdgS[113], 0, &_PrmTypLstS[343], 0, 0, 0, 0, 0, 0, 244},
+  {2, "lint1.log", "messages from first phase of lint", 2, 0, 0, 0, 0, &_CastEdgS[114], 0, &_PrmTypLstS[343], 0, 0, 0, 0, 0, 0, 245},
+  {2, "lint", "static semantic analysis of C code", 1, 0, 0, 0, 0, &_CastEdgS[115], 0, &_PrmTypLstS[1041], 0, 0, 0, 0, 0, 0, 246},
+  {10, "lint*ln*composite", "", 3, 0, &_ToolS[127], &_MemEdgS[20], 0, 0, &_DrvEdgS[130], &_PrmTypLstS[343], 0, 0, 0, 0, 0, 0, 247},
+  {2, "lint*ln", "", 3, 0, &_ToolS[125], 0, &_EqvEdgS[130], 0, 0, &_PrmTypLstS[343], 0, 0, 0, 0, 0, 0, 248},
+  {2, "lint*lint1.log", "", 3, 0, &_ToolS[126], 0, &_EqvEdgS[131], 0, 0, &_PrmTypLstS[343], 0, 0, 0, 0, 0, 0, 249},
+  {2, "lint*lint", "", 3, 0, &_ToolS[128], 0, &_EqvEdgS[132], 0, 0, &_PrmTypLstS[1041], 0, 0, 0, 0, 0, 0, 250},
+  {3, "map", "", 2, &_FilTypS[244], &_ToolS[129], 0, 0, &_CastEdgS[116], 0, &_PrmTypLstS[239], 0, 0, 1, 0, 0, 0, 251},
+  {3, "map", "", 2, &_FilTypS[245], &_ToolS[130], 0, 0, &_CastEdgS[117], 0, &_PrmTypLstS[239], 0, 0, 1, 0, 0, 0, 252},
+  {6, "redo", "redo this object step", 1, 0, 0, 0, 0, &_CastEdgS[119], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 253},
+  {6, "redo_errs", "redo all steps with errors", 1, 0, 0, 0, 0, &_CastEdgS[120], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 254},
+  {2, "boot_name", "name of the boot-strap file", 2, 0, 0, 0, 0, &_CastEdgS[121], &_DrvEdgS[79], &_PrmTypLstS[1053], 0, 0, 0, 0, 0, 0, 255},
+  {5, "boot", "boot-strap a file", 2, 0, 0, 0, 0, &_CastEdgS[122], 0, &_PrmTypLstS[1053], 0, 1, 0, 0, 0, 0, 256},
+  {2, "diff", "differences between two files", 1, 0, 0, 0, 0, &_CastEdgS[123], 0, &_PrmTypLstS[1065], 0, 0, 0, 0, 0, 0, 257},
+  {4, "rcp", "archive", 1, 0, 0, 0, 0, &_CastEdgS[124], 0, &_PrmTypLstS[1078], 0, 0, 0, 0, 0, 0, 258},
+  {3, "misc*list", "", 3, 0, &_ToolS[131], 0, &_EqvEdgS[133], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 259},
+  {6, "misc*redo", "", 3, 0, &_ToolS[132], 0, &_EqvEdgS[134], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 260},
+  {6, "misc*redo_errs", "", 3, 0, &_ToolS[133], 0, &_EqvEdgS[135], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 261},
+  {2, "misc*boot_name", "", 3, 0, &_ToolS[134], 0, &_EqvEdgS[136], 0, 0, &_PrmTypLstS[1053], 0, 0, 0, 0, 0, 0, 262},
+  {5, "misc*boot", "", 3, 0, &_ToolS[135], 0, &_EqvEdgS[137], 0, 0, &_PrmTypLstS[1053], 0, 1, 0, 0, 0, 0, 263},
+  {2, "misc*diff", "", 3, 0, &_ToolS[136], 0, &_EqvEdgS[138], 0, 0, &_PrmTypLstS[1065], 0, 0, 0, 0, 0, 0, 264},
+  {4, "misc*rcp", "", 3, 0, &_ToolS[137], 0, &_EqvEdgS[139], 0, 0, &_PrmTypLstS[1078], 0, 0, 0, 0, 0, 0, 265},
+  {2, "eqn_in", "eqn input", 1, 0, 0, 0, 0, &_CastEdgS[125], &_DrvEdgS[167], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 266},
+  {2, "tbl_in", "tbl input", 2, 0, 0, 0, 0, &_CastEdgS[126], &_DrvEdgS[76], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 267},
+  {2, "roff", "nroff/troff input", 1, 0, 0, 0, 0, &_CastEdgS[127], &_DrvEdgS[75], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 268},
+  {2, "so_inc_spec", "names of Nroff-style included files", 2, 0, 0, 0, 0, &_CastEdgS[128], &_DrvEdgS[78], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 269},
+  {3, "so_inc", "list of Nroff-style included files", 2, 0, 0, 0, 0, &_CastEdgS[129], &_DrvEdgS[77], &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 270},
+  {3, "all_so_inc", "list of Nroff-style transitively included files", 2, 0, 0, 0, 0, &_CastEdgS[130], 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 271},
+  {2, "eqn", "output from eqn", 1, 0, 0, 0, &_EqvEdgS[140], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 272},
+  {7, "gnc.eqn", "output from eqn", 1, 0, 0, 0, &_EqvEdgS[141], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 273},
+  {2, "tbl", "output from tbl", 1, 0, 0, 0, &_EqvEdgS[142], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 274},
+  {2, "nroff", "output from nroff", 1, 0, 0, 0, 0, &_CastEdgS[131], 0, &_PrmTypLstS[814], 0, 0, 0, 0, 0, 0, 275},
+  {2, "roff*so_inc_spec", "", 3, 0, &_ToolS[138], 0, &_EqvEdgS[143], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 276},
+  {3, "roff*so_inc", "", 3, 0, &_ToolS[139], 0, &_EqvEdgS[144], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 277},
+  {3, "roff*all_so_inc", "", 3, 0, &_ToolS[140], 0, &_EqvEdgS[145], 0, 0, &_PrmTypLstS[239], 0, 1, 0, 0, 0, 0, 278},
+  {3, "map", "", 2, &_FilTypS[271], &_ToolS[141], 0, 0, &_CastEdgS[132], 0, &_PrmTypLstS[239], 0, 0, 1, 0, 0, 0, 279},
+  {2, "roff*eqn", "", 3, 0, &_ToolS[142], 0, &_EqvEdgS[146], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 280},
+  {7, "roff*gnc.eqn", "", 3, 0, &_ToolS[143], 0, &_EqvEdgS[147], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 281},
+  {2, "roff*tbl", "", 3, 0, &_ToolS[144], 0, &_EqvEdgS[148], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 282},
+  {2, "roff*nroff", "", 3, 0, &_ToolS[145], 0, &_EqvEdgS[149], 0, 0, &_PrmTypLstS[814], 0, 0, 0, 0, 0, 0, 283},
+  {5, "lookup", "", 2, &_FilTypS[271], &_ToolS[146], 0, 0, &_CastEdgS[133], 0, &_PrmTypLstS[239], 0, 0, 1, 0, 0, 0, 284},
+  {2, "tex", "TeX formatter input", 1, 0, 0, 0, 0, &_CastEdgS[134], &_DrvEdgS[183], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 285},
+  {2, "bib", "Bibliographic data file", 1, 0, 0, 0, 0, &_CastEdgS[135], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 286},
+  {2, "sty", "Formatting style file", 1, 0, 0, 0, 0, &_CastEdgS[136], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 287},
+  {2, "cls", "Formatting style file", 1, 0, 0, 0, 0, &_CastEdgS[137], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 288},
+  {2, "bst", "Bibliographic style file", 1, 0, 0, 0, 0, &_CastEdgS[138], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 289},
+  {2, "ps", "Postscript file", 1, 0, 0, 0, 0, &_CastEdgS[139], 0, &_PrmTypLstS[885], 0, 0, 0, 0, 0, 0, 290},
+  {2, "pdf", "Portable Document Format file", 1, 0, 0, 0, 0, &_CastEdgS[140], 0, &_PrmTypLstS[802], 0, 1, 0, 0, 0, 0, 291},
+  {2, "tex.vtd", "Basis of a TeX formatted document", 1, 0, 0, 0, &_EqvEdgS[150], 0, &_DrvEdgS[177], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 292},
+  {2, "rootName", "Base name (no .tex suffix) of the root file", 2, 0, 0, 0, 0, &_CastEdgS[141], 0, &_PrmTypLstS[592], 0, 0, 0, 0, 0, 0, 293},
+  {2, "rootFileName", "Simple name of the TeX file to be used as the root", 2, 0, 0, 0, &_EqvEdgS[151], 0, 0, &_PrmTypLstS[592], 0, 0, 0, 0, 0, 0, 294},
+  {2, "texnames", "Text file containing local file names", 2, 0, 0, 0, 0, &_CastEdgS[143], &_DrvEdgS[23], &_PrmTypLstS[627], 0, 0, 0, 0, 0, 0, 295},
+  {2, "texsp", "Search path for the document basis", 2, 0, 0, 0, 0, &_CastEdgS[142], 0, &_PrmTypLstS[675], 0, 0, 0, 0, 0, 0, 296},
+  {2, "dvi", "Device independent format file", 2, 0, 0, 0, 0, &_CastEdgS[144], 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 297},
+  {2, "texpdf", "PDF created from TeX or LaTeX", 2, 0, 0, 0, 0, &_CastEdgS[145], 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 298},
+  {2, "tex.log", "TeX log file", 1, 0, 0, 0, 0, &_CastEdgS[146], 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 299},
+  {2, "citations", "Citation and bibliographic data commands", 2, 0, 0, 0, 0, &_CastEdgS[147], 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 300},
+  {2, "indexntry", "indexentry commands with page numbers", 2, 0, 0, 0, 0, &_CastEdgS[148], &_DrvEdgS[14], &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 301},
+  {9, "texauxout", "Auxiliary files potentially modified by TeX", 2, 0, 0, 0, 0, &_CastEdgS[149], 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 302},
+  {2, "texauxin.vtd", "Auxiliary files input to the formatting step", 2, 0, 0, 0, &_EqvEdgS[152], 0, 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 303},
+  {2, "texps", "PostScript created from TeX or LaTeX", 2, 0, 0, 0, &_EqvEdgS[153], 0, 0, &_PrmTypLstS[885], 0, 0, 0, 0, 0, 0, 304},
+  {2, "one_tex_vtd", "Singleton set of TeX formatter inputs", 2, 0, 0, 0, &_EqvEdgS[155], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 305},
+  {2, "tex*one_tex_vtd", "", 3, 0, &_ToolS[147], 0, &_EqvEdgS[154], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 306},
+  {10, "tex*rootName*composite", "", 3, 0, &_ToolS[150], &_MemEdgS[22], 0, 0, &_DrvEdgS[25], &_PrmTypLstS[592], 0, 0, 0, 0, 0, 0, 307},
+  {2, "tex*rootName", "", 3, 0, &_ToolS[148], 0, &_EqvEdgS[156], 0, 0, &_PrmTypLstS[592], 0, 0, 0, 0, 0, 0, 308},
+  {2, "tex*rootFileName", "", 3, 0, &_ToolS[149], 0, &_EqvEdgS[157], 0, 0, &_PrmTypLstS[592], 0, 0, 0, 0, 0, 0, 309},
+  {2, "tex*texsp", "", 3, 0, &_ToolS[151], 0, &_EqvEdgS[158], 0, 0, &_PrmTypLstS[675], 0, 0, 0, 0, 0, 0, 310},
+  {3, "texclose", "Names of all files transitively referenced", 2, 0, 0, 0, 0, &_CastEdgS[152], 0, &_PrmTypLstS[663], 0, 1, 0, 0, 0, 0, 311},
+  {3, "tex*texclose", "", 3, 0, &_ToolS[152], 0, &_EqvEdgS[159], 0, 0, &_PrmTypLstS[663], 0, 1, 0, 0, 0, 0, 312},
+  {3, "texfiles", "Accessible files referenced", 2, 0, 0, 0, 0, &_CastEdgS[155], &_DrvEdgS[21], &_PrmTypLstS[663], 0, 1, 0, 0, 0, 0, 313},
+  {3, "extract", "", 2, &_FilTypS[285], &_ToolS[153], 0, 0, &_CastEdgS[150], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 314},
+  {3, "map", "", 2, &_FilTypS[311], &_ToolS[154], 0, 0, &_CastEdgS[151], 0, &_PrmTypLstS[239], 0, 0, 1, 0, 0, 0, 315},
+  {3, "texbasis", "Document basis", 2, 0, 0, 0, 0, &_CastEdgS[153], 0, &_PrmTypLstS[712], 0, 1, 0, 0, 0, 0, 316},
+  {3, "tex*texbasis", "", 3, 0, &_ToolS[155], 0, &_EqvEdgS[160], 0, 0, &_PrmTypLstS[712], 0, 1, 0, 0, 0, 0, 317},
+  {2, "tex.view_desc", "View descriptor for basis files", 2, 0, 0, 0, 0, &_CastEdgS[154], &_DrvEdgS[22], &_PrmTypLstS[663], 0, 0, 0, 0, 0, 0, 318},
+  {2, "tex*tex.view_desc", "", 3, 0, &_ToolS[156], 0, &_EqvEdgS[161], 0, 0, &_PrmTypLstS[663], 0, 0, 0, 0, 0, 0, 319},
+  {2, "tex*texnames", "", 3, 0, &_ToolS[157], 0, &_EqvEdgS[162], 0, 0, &_PrmTypLstS[580], 0, 0, 0, 0, 0, 0, 320},
+  {3, "tex*texfiles", "", 3, 0, &_ToolS[158], 0, &_EqvEdgS[163], 0, 0, &_PrmTypLstS[663], 0, 1, 0, 0, 0, 0, 321},
+  {2, "fmtcmd", "Formatting command", 2, 0, 0, 0, 0, &_CastEdgS[156], 0, &_PrmTypLstS[1093], 0, 0, 0, 0, 0, 0, 322},
+  {2, "tex*fmtcmd", "", 3, 0, &_ToolS[159], 0, &_EqvEdgS[164], 0, 0, &_PrmTypLstS[1093], 0, 0, 0, 0, 0, 0, 323},
+  {10, "tex*dvi*composite", "", 3, 0, &_ToolS[166], &_MemEdgS[24], 0, 0, &_DrvEdgS[20], &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 324},
+  {2, "tex*dvi", "", 3, 0, &_ToolS[160], 0, &_EqvEdgS[165], 0, 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 325},
+  {2, "tex*texpdf", "", 3, 0, &_ToolS[161], 0, &_EqvEdgS[166], 0, 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 326},
+  {2, "tex*tex.log", "", 3, 0, &_ToolS[162], 0, &_EqvEdgS[167], 0, 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 327},
+  {2, "tex*citations", "", 3, 0, &_ToolS[163], 0, &_EqvEdgS[168], 0, 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 328},
+  {2, "tex*indexntry", "", 3, 0, &_ToolS[164], 0, &_EqvEdgS[169], 0, 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 329},
+  {9, "tex*texauxout", "", 3, 0, &_ToolS[165], 0, &_EqvEdgS[170], 0, 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 330},
+  {3, "extract", "", 2, &_FilTypS[287], &_ToolS[167], 0, 0, &_CastEdgS[157], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 331},
+  {3, "extract", "", 2, &_FilTypS[288], &_ToolS[168], 0, 0, &_CastEdgS[158], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 332},
+  {2, "tex.bbl", "TeX bibliographic reference file", 2, 0, 0, 0, 0, &_CastEdgS[161], 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 333},
+  {2, "tex*tex.bbl", "", 3, 0, &_ToolS[169], 0, &_EqvEdgS[171], 0, 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 334},
+  {3, "extract", "", 2, &_FilTypS[286], &_ToolS[170], 0, 0, &_CastEdgS[159], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 335},
+  {3, "extract", "", 2, &_FilTypS[289], &_ToolS[171], 0, 0, &_CastEdgS[160], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 336},
+  {10, "tex*tex.ind*composite", "", 3, 0, &_ToolS[174], &_MemEdgS[30], 0, 0, &_DrvEdgS[13], &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 337},
+  {2, "tex.ind", "TeX index file", 2, 0, 0, 0, 0, &_CastEdgS[162], 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 338},
+  {2, "tex*tex.ind", "", 3, 0, &_ToolS[172], 0, &_EqvEdgS[172], 0, 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 339},
+  {2, "tex.ilg", "Messages from makeindex", 1, 0, 0, 0, 0, &_CastEdgS[163], 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 340},
+  {2, "tex*tex.ilg", "", 3, 0, &_ToolS[173], 0, &_EqvEdgS[173], 0, 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 341},
+  {2, "tex*texauxin.vtd", "", 3, 0, &_ToolS[175], 0, &_EqvEdgS[174], 0, 0, &_PrmTypLstS[802], 0, 0, 0, 0, 0, 0, 342},
+  {2, "tex*texps", "", 3, 0, &_ToolS[176], 0, &_EqvEdgS[175], 0, 0, &_PrmTypLstS[885], 0, 0, 0, 0, 0, 0, 343},
+  {3, "extract", "", 2, &_FilTypS[290], &_ToolS[177], 0, 0, &_CastEdgS[164], 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 344},
+  {5, "refpdf", "Reference to a PDF file", 2, 0, 0, 0, &_EqvEdgS[177], &_CastEdgS[165], 0, &_PrmTypLstS[802], 0, 1, 0, 0, 0, 0, 345},
+  {5, "tex*refpdf", "", 3, 0, &_ToolS[178], 0, &_EqvEdgS[176], 0, 0, &_PrmTypLstS[802], 0, 1, 0, 0, 0, 0, 346},
+  {6, "dbx", "symbolic debugger run", 1, 0, 0, 0, 0, &_CastEdgS[166], 0, &_PrmTypLstS[1155], 0, 0, 0, 0, 0, 0, 347},
+  {6, "dbx*dbx", "", 3, 0, &_ToolS[179], 0, &_EqvEdgS[178], 0, 0, &_PrmTypLstS[1155], 0, 0, 0, 0, 0, 0, 348},
+  {6, "run", "execution of a command line", 2, 0, 0, 0, 0, &_CastEdgS[167], 0, &_PrmTypLstS[911], 0, 0, 0, 0, 0, 0, 349},
+  {8, "stdout", "standard output from a test run", 1, 0, 0, 0, &_EqvEdgS[179], 0, 0, &_PrmTypLstS[911], 0, 0, 0, 0, 0, 0, 350},
+  {9, "output", "output files from a test run", 1, 0, 0, 0, 0, &_CastEdgS[168], 0, &_PrmTypLstS[911], 0, 0, 0, 0, 0, 0, 351},
+  {6, "run.lua", "execution of Lua code", 2, 0, 0, 0, 0, &_CastEdgS[169], 0, &_PrmTypLstS[911], 0, 0, 0, 0, 0, 0, 352},
+  {8, "lua_stdout", "standard output from running Lua code", 1, 0, 0, 0, &_EqvEdgS[180], 0, 0, &_PrmTypLstS[899], 0, 0, 0, 0, 0, 0, 353},
+  {9, "lua_output", "output files from running Lua code", 1, 0, 0, 0, 0, &_CastEdgS[170], 0, &_PrmTypLstS[899], 0, 0, 0, 0, 0, 0, 354},
+  {6, "run*run", "", 3, 0, &_ToolS[180], 0, &_EqvEdgS[181], 0, 0, &_PrmTypLstS[911], 0, 0, 0, 0, 0, 0, 355},
+  {10, "run*stdout*composite", "", 3, 0, &_ToolS[183], &_MemEdgS[32], 0, 0, &_DrvEdgS[74], &_PrmTypLstS[911], 0, 0, 0, 0, 0, 0, 356},
+  {8, "run*stdout", "", 3, 0, &_ToolS[181], 0, &_EqvEdgS[182], 0, 0, &_PrmTypLstS[911], 0, 0, 0, 0, 0, 0, 357},
+  {9, "run*output", "", 3, 0, &_ToolS[182], 0, &_EqvEdgS[183], 0, 0, &_PrmTypLstS[911], 0, 0, 0, 0, 0, 0, 358},
+  {6, "run*run.lua", "", 3, 0, &_ToolS[184], 0, &_EqvEdgS[184], 0, 0, &_PrmTypLstS[911], 0, 0, 0, 0, 0, 0, 359},
+  {10, "run*lua_stdout*composite", "", 3, 0, &_ToolS[187], &_MemEdgS[34], 0, 0, &_DrvEdgS[72], &_PrmTypLstS[899], 0, 0, 0, 0, 0, 0, 360},
+  {8, "run*lua_stdout", "", 3, 0, &_ToolS[185], 0, &_EqvEdgS[185], 0, 0, &_PrmTypLstS[899], 0, 0, 0, 0, 0, 0, 361},
+  {9, "run*lua_output", "", 3, 0, &_ToolS[186], 0, &_EqvEdgS[186], 0, 0, &_PrmTypLstS[899], 0, 0, 0, 0, 0, 0, 362},
+  {2, "regsub_in", "regsub substitution input", 1, 0, 0, 0, 0, &_CastEdgS[171], &_DrvEdgS[169], &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 363},
+  {7, "gnc.regsub", "output from regsub substitution", 2, 0, 0, 0, &_EqvEdgS[188], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 364},
+  {8, "regsub*regsub", "", 3, 0, &_ToolS[188], 0, &_EqvEdgS[189], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 365},
+  {7, "regsub*gnc.regsub", "", 3, 0, &_ToolS[189], 0, &_EqvEdgS[190], 0, 0, &_PrmTypLstS[239], 0, 0, 0, 0, 0, 0, 366} };
+tp_FilTyp GenericFilTyp = &_FilTypS[7];
+tp_FilTyp PipeFilTyp = &_FilTypS[8];
+tp_FilTyp ListFilTyp = &_FilTypS[3];
+tp_FilTyp FileFilTyp = &_FilTypS[2];
+tp_FilTyp ObjectFilTyp = &_FilTypS[1];
+tp_FilTyp NoInputFilTyp = &_FilTypS[0];
+tp_FilTyp ExpandHooksFilTyp = &_FilTypS[10];
+tp_FilTyp TargetsPtrFilTyp = &_FilTypS[11];
+tp_FilTyp TargetsFilTyp = &_FilTypS[12];
+tp_FilTyp ActTargetsFilTyp = &_FilTypS[13];
+tp_FilTyp VirTargetsFilTyp = &_FilTypS[14];
+tp_FilTyp VirDirFilTyp = &_FilTypS[15];
+tp_FilTyp CopyFilTyp = &_FilTypS[16];
+tp_FilTyp PrmValuesFilTyp = &_FilTypS[17];
+tp_FilTyp ViewSpecFilTyp = &_FilTypS[18];
+tp_FilTyp FirstFilTyp = &_FilTypS[19];
+tp_FilTyp ApplyFilTyp = &_FilTypS[20];
+tp_FilTyp FatherFilTyp = &_FilTypS[21];
+int num_PrmTypS = 73;
+tps_PrmTyp _PrmTypS [73] = {
+  {"null", "ignored parameter type", 2, &_FilTypS[19], 0, 0, 0, 0},
+  {"hookvalue", "hook value", 2, &_FilTypS[19], 0, 0, 0, 1},
+  {"copy_dest", "where to copy", 2, &_FilTypS[19], 0, 0, 0, 2},
+  {"apply", "operations to apply", 2, &_FilTypS[19], 0, 0, 0, 3},
+  {"copy_dest_desc", "where to copy", 2, &_FilTypS[19], 0, 0, 0, 4},
+  {"depend", "dependency", 2, &_FilTypS[3], 0, 0, 0, 5},
+  {"prm_help", "derivation for which parameter types are applicable", 2, &_FilTypS[19], 0, 0, 0, 6},
+  {"date", "revision date", 1, &_FilTypS[19], 0, 0, 0, 7},
+  {"rev", "revision number", 1, &_FilTypS[19], 0, 0, 0, 8},
+  {"state", "revision state", 1, &_FilTypS[19], 0, 0, 0, 9},
+  {"who", "revision author", 1, &_FilTypS[19], 0, 0, 0, 10},
+  {"view_sp", "name of a directory in an view search path", 1, &_FilTypS[44], 0, 0, 0, 11},
+  {"lib", "a library name", 1, &_FilTypS[44], 0, 0, 0, 12},
+  {"lib_sp", "name of a directory in an library search path", 1, &_FilTypS[44], 0, 0, 0, 13},
+  {"define", "macro definition", 1, &_FilTypS[45], 0, 0, 0, 14},
+  {"debug", "debug switch", 1, &_FilTypS[19], 0, 0, 0, 15},
+  {"optimize", "optimization flag", 1, &_FilTypS[19], 0, 0, 0, 16},
+  {"prof", "profiling flag", 1, &_FilTypS[19], 0, 0, 0, 17},
+  {"eprof", "profiling flag for linking", 1, &_FilTypS[19], 0, 0, 0, 18},
+  {"cc_home", "directory containing the C compiler", 1, &_FilTypS[19], 0, 0, 0, 19},
+  {"cc", "name of the C compiler", 1, &_FilTypS[19], 0, 0, 0, 20},
+  {"cc_flags", "flags for cc", 1, &_FilTypS[45], 0, 0, 0, 21},
+  {"ld_flags", "flags for ld", 1, &_FilTypS[45], 0, 0, 0, 22},
+  {"inc_sp", "name of a directory in an include search path", 1, &_FilTypS[44], 0, 0, 0, 23},
+  {"ignore", "egrep expression for includes to ignore", 1, &_FilTypS[44], 0, 0, 0, 24},
+  {"purify", "purify flag", 1, &_FilTypS[45], 0, 0, 0, 25},
+  {"home", "home directory for relative pathnames", 2, &_FilTypS[19], 0, 0, 0, 26},
+  {"gnu", "use gnu tools", 1, &_FilTypS[19], 0, 0, 0, 27},
+  {"cxx", "name of the C++ compiler", 1, &_FilTypS[19], 0, 0, 0, 28},
+  {"cxx_flags", "flags for C++ compilation", 1, &_FilTypS[45], 0, 0, 0, 29},
+  {"schema_src", "ObjectStore schema source file", 1, &_FilTypS[3], 0, 0, 0, 30},
+  {"schema_dir", "ObjectStore schema directory", 1, &_FilTypS[19], 0, 0, 0, 31},
+  {"f77_home", "directory containing the C compiler", 1, &_FilTypS[19], 0, 0, 0, 32},
+  {"f77", "name of the C compiler", 1, &_FilTypS[19], 0, 0, 0, 33},
+  {"f77_flags", "flags for f77", 1, &_FilTypS[45], 0, 0, 0, 34},
+  {"array_bds", "array bound checking flag", 1, &_FilTypS[19], 0, 0, 0, 35},
+  {"yaccid", "entry point for lexical analyzer", 1, &_FilTypS[19], 0, 0, 0, 36},
+  {"sys5", "use Unix System V conventions", 1, &_FilTypS[19], 0, 0, 0, 37},
+  {"conflict_ok", "reduce/reduce and shift/reduce conflicts are OK", 1, &_FilTypS[19], 0, 0, 0, 38},
+  {"yacc", "name of the yacc compiler", 1, &_FilTypS[19], 0, 0, 0, 39},
+  {"yacc_flags", "flags for yacc", 1, &_FilTypS[45], 0, 0, 0, 40},
+  {"pkg", "name of a package or a file containing package names", 1, &_FilTypS[45], 0, 0, 0, 41},
+  {"prefix", "prefix to apply to all lines", 2, &_FilTypS[19], 0, 0, 0, 42},
+  {"subst", "regular expression substitution", 2, &_FilTypS[45], 0, 0, 0, 43},
+  {"idl_flags", "flags for idl", 1, &_FilTypS[45], 0, 0, 0, 44},
+  {"prof_data", "trace file", 1, &_FilTypS[3], 0, 0, 0, 45},
+  {"prof_flags", "prof flags", 1, &_FilTypS[45], 0, 0, 0, 46},
+  {"ln", "a lint library", 1, &_FilTypS[3], 0, 0, 0, 47},
+  {"stub", "stub to keep Lint quiet about unused functions", 1, &_FilTypS[3], 0, 0, 0, 48},
+  {"ignore_mesg", "message to ignore", 1, &_FilTypS[45], 0, 0, 0, 49},
+  {"global_ignore_mesg", "message to ignore in global second lint pass", 2, &_FilTypS[45], 0, 0, 0, 50},
+  {"lint_flags", "Lint flags", 1, &_FilTypS[45], 0, 0, 0, 51},
+  {"default", "default value", 1, &_FilTypS[19], 0, 0, 0, 52},
+  {"other", "another file", 1, &_FilTypS[19], 0, 0, 0, 53},
+  {"f_dest", "file destination", 1, &_FilTypS[19], 0, 0, 0, 54},
+  {"d_dest", "directory destination", 1, &_FilTypS[19], 0, 0, 0, 55},
+  {"mp", "macro package", 1, &_FilTypS[19], 0, 0, 0, 56},
+  {"tex", "Use plain TeX", 1, &_FilTypS[19], 0, 0, 0, 57},
+  {"latex", "Use LaTeX", 1, &_FilTypS[19], 0, 0, 0, 58},
+  {"texroot", "Name of the TeX document root", 1, &_FilTypS[19], 0, 0, 0, 59},
+  {"texsearch", "Directories to be searched first", 1, &_FilTypS[44], 0, 0, 0, 60},
+  {"dvips_flags", "Options for dvips", 1, &_FilTypS[44], 0, 0, 0, 61},
+  {"index_flags", "Options for makeindex", 1, &_FilTypS[44], 0, 0, 0, 62},
+  {"texsppt", "Parameter type for search path information", 2, &_FilTypS[19], 0, 0, 0, 63},
+  {"usepdf", "Produce PDF code", 2, &_FilTypS[19], 0, 0, 0, 64},
+  {"core", "core dump", 1, &_FilTypS[19], 0, 0, 0, 65},
+  {"cmd", "host command", 1, &_FilTypS[3], 0, 0, 0, 66},
+  {"cmdfile", "host command file", 1, &_FilTypS[3], 0, 0, 0, 67},
+  {"need", "run dependency", 1, &_FilTypS[3], 0, 0, 0, 68},
+  {"match", "regular expression to match", 2, &_FilTypS[45], 0, 0, 0, 69},
+  {"hide_match", "instead of showing matches, hide them", 2, &_FilTypS[19], 0, 0, 0, 70},
+  {"subst_only", "only include lines where substitutions were made", 2, &_FilTypS[19], 0, 0, 0, 71},
+  {"suffix", "suffix to apply to all lines", 2, &_FilTypS[19], 0, 0, 0, 72} };
+tp_PrmTyp NullPrmTyp = &_PrmTypS[0];
+tp_PrmTyp HookValPrmTyp = &_PrmTypS[1];
+tp_PrmTyp CopyDestPrmTyp = &_PrmTypS[2];
+tp_PrmTyp ApplyPrmTyp = &_PrmTypS[3];
+int num_PrmTypLstS = 1156;
+tps_PrmTypLst _PrmTypLstS [1156] = {
+  {0, 0},
+  {&_PrmTypS[2], 0},
+  {&_PrmTypS[4], 0},
+  {&_PrmTypS[3], 0},
+  {&_PrmTypS[6], 0},
+  {&_PrmTypS[7], 0},
+  {&_PrmTypS[8], 0},
+  {&_PrmTypS[7], &_PrmTypLstS[6]},
+  {&_PrmTypS[9], 0},
+  {&_PrmTypS[8], &_PrmTypLstS[8]},
+  {&_PrmTypS[7], &_PrmTypLstS[9]},
+  {&_PrmTypS[10], 0},
+  {&_PrmTypS[9], &_PrmTypLstS[11]},
+  {&_PrmTypS[8], &_PrmTypLstS[12]},
+  {&_PrmTypS[7], &_PrmTypLstS[13]},
+  {&_PrmTypS[11], 0},
+  {&_PrmTypS[12], 0},
+  {&_PrmTypS[13], 0},
+  {&_PrmTypS[12], &_PrmTypLstS[17]},
+  {&_PrmTypS[26], 0},
+  {&_PrmTypS[23], 0},
+  {&_PrmTypS[23], &_PrmTypLstS[19]},
+  {&_PrmTypS[24], 0},
+  {&_PrmTypS[24], &_PrmTypLstS[19]},
+  {&_PrmTypS[23], &_PrmTypLstS[23]},
+  {&_PrmTypS[19], 0},
+  {&_PrmTypS[19], &_PrmTypLstS[20]},
+  {&_PrmTypS[27], 0},
+  {&_PrmTypS[23], &_PrmTypLstS[27]},
+  {&_PrmTypS[19], &_PrmTypLstS[28]},
+  {&_PrmTypS[15], 0},
+  {&_PrmTypS[15], &_PrmTypLstS[29]},
+  {&_PrmTypS[17], 0},
+  {&_PrmTypS[17], &_PrmTypLstS[29]},
+  {&_PrmTypS[15], &_PrmTypLstS[33]},
+  {&_PrmTypS[16], 0},
+  {&_PrmTypS[16], &_PrmTypLstS[33]},
+  {&_PrmTypS[15], &_PrmTypLstS[36]},
+  {&_PrmTypS[14], 0},
+  {&_PrmTypS[14], &_PrmTypLstS[37]},
+  {&_PrmTypS[20], 0},
+  {&_PrmTypS[20], &_PrmTypLstS[28]},
+  {&_PrmTypS[19], &_PrmTypLstS[41]},
+  {&_PrmTypS[17], &_PrmTypLstS[42]},
+  {&_PrmTypS[16], &_PrmTypLstS[43]},
+  {&_PrmTypS[15], &_PrmTypLstS[44]},
+  {&_PrmTypS[14], &_PrmTypLstS[45]},
+  {&_PrmTypS[21], 0},
+  {&_PrmTypS[21], &_PrmTypLstS[28]},
+  {&_PrmTypS[20], &_PrmTypLstS[48]},
+  {&_PrmTypS[19], &_PrmTypLstS[49]},
+  {&_PrmTypS[17], &_PrmTypLstS[50]},
+  {&_PrmTypS[16], &_PrmTypLstS[51]},
+  {&_PrmTypS[15], &_PrmTypLstS[52]},
+  {&_PrmTypS[14], &_PrmTypLstS[53]},
+  {&_PrmTypS[19], &_PrmTypLstS[27]},
+  {&_PrmTypS[25], 0},
+  {&_PrmTypS[25], &_PrmTypLstS[27]},
+  {&_PrmTypS[19], &_PrmTypLstS[57]},
+  {&_PrmTypS[15], &_PrmTypLstS[58]},
+  {&_PrmTypS[17], &_PrmTypLstS[58]},
+  {&_PrmTypS[15], &_PrmTypLstS[60]},
+  {&_PrmTypS[18], 0},
+  {&_PrmTypS[18], &_PrmTypLstS[58]},
+  {&_PrmTypS[17], &_PrmTypLstS[63]},
+  {&_PrmTypS[15], &_PrmTypLstS[64]},
+  {&_PrmTypS[20], &_PrmTypLstS[57]},
+  {&_PrmTypS[19], &_PrmTypLstS[66]},
+  {&_PrmTypS[18], &_PrmTypLstS[67]},
+  {&_PrmTypS[17], &_PrmTypLstS[68]},
+  {&_PrmTypS[15], &_PrmTypLstS[69]},
+  {&_PrmTypS[22], 0},
+  {&_PrmTypS[22], &_PrmTypLstS[57]},
+  {&_PrmTypS[20], &_PrmTypLstS[72]},
+  {&_PrmTypS[19], &_PrmTypLstS[73]},
+  {&_PrmTypS[18], &_PrmTypLstS[74]},
+  {&_PrmTypS[17], &_PrmTypLstS[75]},
+  {&_PrmTypS[15], &_PrmTypLstS[76]},
+  {&_PrmTypS[14], &_PrmTypLstS[20]},
+  {&_PrmTypS[15], &_PrmTypLstS[28]},
+  {&_PrmTypS[17], &_PrmTypLstS[28]},
+  {&_PrmTypS[15], &_PrmTypLstS[80]},
+  {&_PrmTypS[16], &_PrmTypLstS[80]},
+  {&_PrmTypS[15], &_PrmTypLstS[82]},
+  {&_PrmTypS[14], &_PrmTypLstS[83]},
+  {&_PrmTypS[28], 0},
+  {&_PrmTypS[27], &_PrmTypLstS[85]},
+  {&_PrmTypS[23], &_PrmTypLstS[86]},
+  {&_PrmTypS[17], &_PrmTypLstS[87]},
+  {&_PrmTypS[16], &_PrmTypLstS[88]},
+  {&_PrmTypS[15], &_PrmTypLstS[89]},
+  {&_PrmTypS[14], &_PrmTypLstS[90]},
+  {&_PrmTypS[29], 0},
+  {&_PrmTypS[28], &_PrmTypLstS[92]},
+  {&_PrmTypS[27], &_PrmTypLstS[93]},
+  {&_PrmTypS[23], &_PrmTypLstS[94]},
+  {&_PrmTypS[17], &_PrmTypLstS[95]},
+  {&_PrmTypS[16], &_PrmTypLstS[96]},
+  {&_PrmTypS[15], &_PrmTypLstS[97]},
+  {&_PrmTypS[14], &_PrmTypLstS[98]},
+  {&_PrmTypS[14], &_PrmTypLstS[28]},
+  {&_PrmTypS[23], &_PrmTypLstS[57]},
+  {&_PrmTypS[14], &_PrmTypLstS[101]},
+  {&_PrmTypS[15], &_PrmTypLstS[101]},
+  {&_PrmTypS[14], &_PrmTypLstS[103]},
+  {&_PrmTypS[17], &_PrmTypLstS[101]},
+  {&_PrmTypS[15], &_PrmTypLstS[105]},
+  {&_PrmTypS[14], &_PrmTypLstS[106]},
+  {&_PrmTypS[18], &_PrmTypLstS[101]},
+  {&_PrmTypS[17], &_PrmTypLstS[108]},
+  {&_PrmTypS[15], &_PrmTypLstS[109]},
+  {&_PrmTypS[14], &_PrmTypLstS[110]},
+  {&_PrmTypS[25], &_PrmTypLstS[86]},
+  {&_PrmTypS[23], &_PrmTypLstS[112]},
+  {&_PrmTypS[18], &_PrmTypLstS[113]},
+  {&_PrmTypS[17], &_PrmTypLstS[114]},
+  {&_PrmTypS[15], &_PrmTypLstS[115]},
+  {&_PrmTypS[14], &_PrmTypLstS[116]},
+  {&_PrmTypS[22], &_PrmTypLstS[113]},
+  {&_PrmTypS[18], &_PrmTypLstS[118]},
+  {&_PrmTypS[17], &_PrmTypLstS[119]},
+  {&_PrmTypS[15], &_PrmTypLstS[120]},
+  {&_PrmTypS[14], &_PrmTypLstS[121]},
+  {&_PrmTypS[30], 0},
+  {&_PrmTypS[31], 0},
+  {&_PrmTypS[30], &_PrmTypLstS[124]},
+  {&_PrmTypS[23], &_PrmTypLstS[125]},
+  {&_PrmTypS[15], &_PrmTypLstS[32]},
+  {&_PrmTypS[32], 0},
+  {&_PrmTypS[17], &_PrmTypLstS[128]},
+  {&_PrmTypS[15], &_PrmTypLstS[129]},
+  {&_PrmTypS[33], 0},
+  {&_PrmTypS[32], &_PrmTypLstS[131]},
+  {&_PrmTypS[17], &_PrmTypLstS[132]},
+  {&_PrmTypS[15], &_PrmTypLstS[133]},
+  {&_PrmTypS[34], 0},
+  {&_PrmTypS[33], &_PrmTypLstS[135]},
+  {&_PrmTypS[32], &_PrmTypLstS[136]},
+  {&_PrmTypS[17], &_PrmTypLstS[137]},
+  {&_PrmTypS[15], &_PrmTypLstS[138]},
+  {&_PrmTypS[36], 0},
+  {&_PrmTypS[38], 0},
+  {&_PrmTypS[36], &_PrmTypLstS[141]},
+  {&_PrmTypS[37], 0},
+  {&_PrmTypS[37], &_PrmTypLstS[141]},
+  {&_PrmTypS[36], &_PrmTypLstS[144]},
+  {&_PrmTypS[27], &_PrmTypLstS[145]},
+  {&_PrmTypS[39], 0},
+  {&_PrmTypS[38], &_PrmTypLstS[147]},
+  {&_PrmTypS[37], &_PrmTypLstS[148]},
+  {&_PrmTypS[36], &_PrmTypLstS[149]},
+  {&_PrmTypS[27], &_PrmTypLstS[150]},
+  {&_PrmTypS[40], 0},
+  {&_PrmTypS[39], &_PrmTypLstS[152]},
+  {&_PrmTypS[38], &_PrmTypLstS[153]},
+  {&_PrmTypS[37], &_PrmTypLstS[154]},
+  {&_PrmTypS[36], &_PrmTypLstS[155]},
+  {&_PrmTypS[27], &_PrmTypLstS[156]},
+  {&_PrmTypS[41], 0},
+  {&_PrmTypS[44], 0},
+  {&_PrmTypS[23], &_PrmTypLstS[159]},
+  {&_PrmTypS[45], 0},
+  {&_PrmTypS[46], 0},
+  {&_PrmTypS[45], &_PrmTypLstS[162]},
+  {&_PrmTypS[51], 0},
+  {&_PrmTypS[23], &_PrmTypLstS[164]},
+  {&_PrmTypS[14], &_PrmTypLstS[165]},
+  {&_PrmTypS[49], 0},
+  {&_PrmTypS[49], &_PrmTypLstS[164]},
+  {&_PrmTypS[23], &_PrmTypLstS[168]},
+  {&_PrmTypS[14], &_PrmTypLstS[169]},
+  {&_PrmTypS[48], 0},
+  {&_PrmTypS[47], 0},
+  {&_PrmTypS[47], &_PrmTypLstS[171]},
+  {&_PrmTypS[48], &_PrmTypLstS[164]},
+  {&_PrmTypS[47], &_PrmTypLstS[174]},
+  {&_PrmTypS[48], &_PrmTypLstS[168]},
+  {&_PrmTypS[47], &_PrmTypLstS[176]},
+  {&_PrmTypS[50], 0},
+  {&_PrmTypS[50], &_PrmTypLstS[164]},
+  {&_PrmTypS[49], &_PrmTypLstS[179]},
+  {&_PrmTypS[48], &_PrmTypLstS[180]},
+  {&_PrmTypS[47], &_PrmTypLstS[181]},
+  {&_PrmTypS[52], 0},
+  {&_PrmTypS[53], 0},
+  {&_PrmTypS[54], 0},
+  {&_PrmTypS[55], 0},
+  {&_PrmTypS[54], &_PrmTypLstS[186]},
+  {&_PrmTypS[56], 0},
+  {&_PrmTypS[59], 0},
+  {&_PrmTypS[60], 0},
+  {&_PrmTypS[63], 0},
+  {&_PrmTypS[57], 0},
+  {&_PrmTypS[58], 0},
+  {&_PrmTypS[57], &_PrmTypLstS[193]},
+  {&_PrmTypS[64], 0},
+  {&_PrmTypS[58], &_PrmTypLstS[195]},
+  {&_PrmTypS[57], &_PrmTypLstS[196]},
+  {&_PrmTypS[62], 0},
+  {&_PrmTypS[61], 0},
+  {&_PrmTypS[65], 0},
+  {&_PrmTypS[27], &_PrmTypLstS[200]},
+  {&_PrmTypS[66], 0},
+  {&_PrmTypS[68], 0},
+  {&_PrmTypS[66], &_PrmTypLstS[203]},
+  {&_PrmTypS[67], 0},
+  {&_PrmTypS[66], &_PrmTypLstS[205]},
+  {&_PrmTypS[67], &_PrmTypLstS[203]},
+  {&_PrmTypS[66], &_PrmTypLstS[207]},
+  {&_PrmTypS[69], 0},
+  {&_PrmTypS[70], 0},
+  {&_PrmTypS[69], &_PrmTypLstS[210]},
+  {&_PrmTypS[43], 0},
+  {&_PrmTypS[43], &_PrmTypLstS[211]},
+  {&_PrmTypS[71], 0},
+  {&_PrmTypS[70], &_PrmTypLstS[214]},
+  {&_PrmTypS[69], &_PrmTypLstS[215]},
+  {&_PrmTypS[43], &_PrmTypLstS[216]},
+  {&_PrmTypS[42], 0},
+  {&_PrmTypS[42], &_PrmTypLstS[217]},
+  {&_PrmTypS[72], 0},
+  {&_PrmTypS[71], &_PrmTypLstS[220]},
+  {&_PrmTypS[70], &_PrmTypLstS[221]},
+  {&_PrmTypS[69], &_PrmTypLstS[222]},
+  {&_PrmTypS[43], &_PrmTypLstS[223]},
+  {&_PrmTypS[42], &_PrmTypLstS[224]},
+  {&_PrmTypS[14], &_PrmTypLstS[24]},
+  {&_PrmTypS[26], &_PrmTypLstS[225]},
+  {&_PrmTypS[24], &_PrmTypLstS[227]},
+  {&_PrmTypS[23], &_PrmTypLstS[228]},
+  {&_PrmTypS[14], &_PrmTypLstS[229]},
+  {&_PrmTypS[10], &_PrmTypLstS[230]},
+  {&_PrmTypS[9], &_PrmTypLstS[231]},
+  {&_PrmTypS[8], &_PrmTypLstS[232]},
+  {&_PrmTypS[7], &_PrmTypLstS[233]},
+  {&_PrmTypS[11], &_PrmTypLstS[230]},
+  {&_PrmTypS[10], &_PrmTypLstS[235]},
+  {&_PrmTypS[9], &_PrmTypLstS[236]},
+  {&_PrmTypS[8], &_PrmTypLstS[237]},
+  {&_PrmTypS[7], &_PrmTypLstS[238]},
+  {&_PrmTypS[51], &_PrmTypLstS[223]},
+  {&_PrmTypS[49], &_PrmTypLstS[240]},
+  {&_PrmTypS[43], &_PrmTypLstS[241]},
+  {&_PrmTypS[42], &_PrmTypLstS[242]},
+  {&_PrmTypS[26], &_PrmTypLstS[243]},
+  {&_PrmTypS[24], &_PrmTypLstS[244]},
+  {&_PrmTypS[23], &_PrmTypLstS[245]},
+  {&_PrmTypS[14], &_PrmTypLstS[246]},
+  {&_PrmTypS[11], &_PrmTypLstS[247]},
+  {&_PrmTypS[10], &_PrmTypLstS[248]},
+  {&_PrmTypS[9], &_PrmTypLstS[249]},
+  {&_PrmTypS[8], &_PrmTypLstS[250]},
+  {&_PrmTypS[7], &_PrmTypLstS[251]},
+  {&_PrmTypS[44], &_PrmTypLstS[223]},
+  {&_PrmTypS[43], &_PrmTypLstS[253]},
+  {&_PrmTypS[42], &_PrmTypLstS[254]},
+  {&_PrmTypS[26], &_PrmTypLstS[255]},
+  {&_PrmTypS[24], &_PrmTypLstS[256]},
+  {&_PrmTypS[23], &_PrmTypLstS[257]},
+  {&_PrmTypS[14], &_PrmTypLstS[258]},
+  {&_PrmTypS[11], &_PrmTypLstS[259]},
+  {&_PrmTypS[10], &_PrmTypLstS[260]},
+  {&_PrmTypS[9], &_PrmTypLstS[261]},
+  {&_PrmTypS[8], &_PrmTypLstS[262]},
+  {&_PrmTypS[7], &_PrmTypLstS[263]},
+  {&_PrmTypS[41], &_PrmTypLstS[225]},
+  {&_PrmTypS[26], &_PrmTypLstS[265]},
+  {&_PrmTypS[24], &_PrmTypLstS[266]},
+  {&_PrmTypS[23], &_PrmTypLstS[267]},
+  {&_PrmTypS[14], &_PrmTypLstS[268]},
+  {&_PrmTypS[11], &_PrmTypLstS[269]},
+  {&_PrmTypS[10], &_PrmTypLstS[270]},
+  {&_PrmTypS[9], &_PrmTypLstS[271]},
+  {&_PrmTypS[8], &_PrmTypLstS[272]},
+  {&_PrmTypS[7], &_PrmTypLstS[273]},
+  {&_PrmTypS[41], &_PrmTypLstS[255]},
+  {&_PrmTypS[26], &_PrmTypLstS[275]},
+  {&_PrmTypS[24], &_PrmTypLstS[276]},
+  {&_PrmTypS[23], &_PrmTypLstS[277]},
+  {&_PrmTypS[14], &_PrmTypLstS[278]},
+  {&_PrmTypS[11], &_PrmTypLstS[279]},
+  {&_PrmTypS[10], &_PrmTypLstS[280]},
+  {&_PrmTypS[9], &_PrmTypLstS[281]},
+  {&_PrmTypS[8], &_PrmTypLstS[282]},
+  {&_PrmTypS[7], &_PrmTypLstS[283]},
+  {&_PrmTypS[40], &_PrmTypLstS[225]},
+  {&_PrmTypS[39], &_PrmTypLstS[285]},
+  {&_PrmTypS[38], &_PrmTypLstS[286]},
+  {&_PrmTypS[37], &_PrmTypLstS[287]},
+  {&_PrmTypS[36], &_PrmTypLstS[288]},
+  {&_PrmTypS[27], &_PrmTypLstS[289]},
+  {&_PrmTypS[26], &_PrmTypLstS[290]},
+  {&_PrmTypS[24], &_PrmTypLstS[291]},
+  {&_PrmTypS[23], &_PrmTypLstS[292]},
+  {&_PrmTypS[14], &_PrmTypLstS[293]},
+  {&_PrmTypS[11], &_PrmTypLstS[294]},
+  {&_PrmTypS[10], &_PrmTypLstS[295]},
+  {&_PrmTypS[9], &_PrmTypLstS[296]},
+  {&_PrmTypS[8], &_PrmTypLstS[297]},
+  {&_PrmTypS[7], &_PrmTypLstS[298]},
+  {&_PrmTypS[36], &_PrmTypLstS[225]},
+  {&_PrmTypS[26], &_PrmTypLstS[300]},
+  {&_PrmTypS[24], &_PrmTypLstS[301]},
+  {&_PrmTypS[23], &_PrmTypLstS[302]},
+  {&_PrmTypS[14], &_PrmTypLstS[303]},
+  {&_PrmTypS[11], &_PrmTypLstS[304]},
+  {&_PrmTypS[10], &_PrmTypLstS[305]},
+  {&_PrmTypS[9], &_PrmTypLstS[306]},
+  {&_PrmTypS[8], &_PrmTypLstS[307]},
+  {&_PrmTypS[7], &_PrmTypLstS[308]},
+  {&_PrmTypS[40], &_PrmTypLstS[275]},
+  {&_PrmTypS[39], &_PrmTypLstS[310]},
+  {&_PrmTypS[38], &_PrmTypLstS[311]},
+  {&_PrmTypS[37], &_PrmTypLstS[312]},
+  {&_PrmTypS[36], &_PrmTypLstS[313]},
+  {&_PrmTypS[27], &_PrmTypLstS[314]},
+  {&_PrmTypS[26], &_PrmTypLstS[315]},
+  {&_PrmTypS[24], &_PrmTypLstS[316]},
+  {&_PrmTypS[23], &_PrmTypLstS[317]},
+  {&_PrmTypS[14], &_PrmTypLstS[318]},
+  {&_PrmTypS[11], &_PrmTypLstS[319]},
+  {&_PrmTypS[10], &_PrmTypLstS[320]},
+  {&_PrmTypS[9], &_PrmTypLstS[321]},
+  {&_PrmTypS[8], &_PrmTypLstS[322]},
+  {&_PrmTypS[7], &_PrmTypLstS[323]},
+  {&_PrmTypS[44], &_PrmTypLstS[241]},
+  {&_PrmTypS[43], &_PrmTypLstS[325]},
+  {&_PrmTypS[42], &_PrmTypLstS[326]},
+  {&_PrmTypS[41], &_PrmTypLstS[327]},
+  {&_PrmTypS[40], &_PrmTypLstS[328]},
+  {&_PrmTypS[39], &_PrmTypLstS[329]},
+  {&_PrmTypS[38], &_PrmTypLstS[330]},
+  {&_PrmTypS[37], &_PrmTypLstS[331]},
+  {&_PrmTypS[36], &_PrmTypLstS[332]},
+  {&_PrmTypS[27], &_PrmTypLstS[333]},
+  {&_PrmTypS[26], &_PrmTypLstS[334]},
+  {&_PrmTypS[24], &_PrmTypLstS[335]},
+  {&_PrmTypS[23], &_PrmTypLstS[336]},
+  {&_PrmTypS[14], &_PrmTypLstS[337]},
+  {&_PrmTypS[11], &_PrmTypLstS[338]},
+  {&_PrmTypS[10], &_PrmTypLstS[339]},
+  {&_PrmTypS[9], &_PrmTypLstS[340]},
+  {&_PrmTypS[8], &_PrmTypLstS[341]},
+  {&_PrmTypS[7], &_PrmTypLstS[342]},
+  {&_PrmTypS[50], &_PrmTypLstS[240]},
+  {&_PrmTypS[49], &_PrmTypLstS[344]},
+  {&_PrmTypS[48], &_PrmTypLstS[345]},
+  {&_PrmTypS[47], &_PrmTypLstS[346]},
+  {&_PrmTypS[44], &_PrmTypLstS[347]},
+  {&_PrmTypS[43], &_PrmTypLstS[348]},
+  {&_PrmTypS[42], &_PrmTypLstS[349]},
+  {&_PrmTypS[41], &_PrmTypLstS[350]},
+  {&_PrmTypS[40], &_PrmTypLstS[351]},
+  {&_PrmTypS[39], &_PrmTypLstS[352]},
+  {&_PrmTypS[38], &_PrmTypLstS[353]},
+  {&_PrmTypS[37], &_PrmTypLstS[354]},
+  {&_PrmTypS[36], &_PrmTypLstS[355]},
+  {&_PrmTypS[27], &_PrmTypLstS[356]},
+  {&_PrmTypS[26], &_PrmTypLstS[357]},
+  {&_PrmTypS[24], &_PrmTypLstS[358]},
+  {&_PrmTypS[23], &_PrmTypLstS[359]},
+  {&_PrmTypS[14], &_PrmTypLstS[360]},
+  {&_PrmTypS[11], &_PrmTypLstS[361]},
+  {&_PrmTypS[10], &_PrmTypLstS[362]},
+  {&_PrmTypS[9], &_PrmTypLstS[363]},
+  {&_PrmTypS[8], &_PrmTypLstS[364]},
+  {&_PrmTypS[7], &_PrmTypLstS[365]},
+  {&_PrmTypS[34], &_PrmTypLstS[225]},
+  {&_PrmTypS[33], &_PrmTypLstS[367]},
+  {&_PrmTypS[32], &_PrmTypLstS[368]},
+  {&_PrmTypS[26], &_PrmTypLstS[369]},
+  {&_PrmTypS[24], &_PrmTypLstS[370]},
+  {&_PrmTypS[23], &_PrmTypLstS[371]},
+  {&_PrmTypS[17], &_PrmTypLstS[372]},
+  {&_PrmTypS[15], &_PrmTypLstS[373]},
+  {&_PrmTypS[14], &_PrmTypLstS[374]},
+  {&_PrmTypS[11], &_PrmTypLstS[375]},
+  {&_PrmTypS[10], &_PrmTypLstS[376]},
+  {&_PrmTypS[9], &_PrmTypLstS[377]},
+  {&_PrmTypS[8], &_PrmTypLstS[378]},
+  {&_PrmTypS[7], &_PrmTypLstS[379]},
+  {&_PrmTypS[29], &_PrmTypLstS[225]},
+  {&_PrmTypS[28], &_PrmTypLstS[381]},
+  {&_PrmTypS[27], &_PrmTypLstS[382]},
+  {&_PrmTypS[26], &_PrmTypLstS[383]},
+  {&_PrmTypS[24], &_PrmTypLstS[384]},
+  {&_PrmTypS[23], &_PrmTypLstS[385]},
+  {&_PrmTypS[17], &_PrmTypLstS[386]},
+  {&_PrmTypS[16], &_PrmTypLstS[387]},
+  {&_PrmTypS[15], &_PrmTypLstS[388]},
+  {&_PrmTypS[14], &_PrmTypLstS[389]},
+  {&_PrmTypS[11], &_PrmTypLstS[390]},
+  {&_PrmTypS[10], &_PrmTypLstS[391]},
+  {&_PrmTypS[9], &_PrmTypLstS[392]},
+  {&_PrmTypS[8], &_PrmTypLstS[393]},
+  {&_PrmTypS[7], &_PrmTypLstS[394]},
+  {&_PrmTypS[29], &_PrmTypLstS[255]},
+  {&_PrmTypS[28], &_PrmTypLstS[396]},
+  {&_PrmTypS[27], &_PrmTypLstS[397]},
+  {&_PrmTypS[26], &_PrmTypLstS[398]},
+  {&_PrmTypS[24], &_PrmTypLstS[399]},
+  {&_PrmTypS[23], &_PrmTypLstS[400]},
+  {&_PrmTypS[17], &_PrmTypLstS[401]},
+  {&_PrmTypS[16], &_PrmTypLstS[402]},
+  {&_PrmTypS[15], &_PrmTypLstS[403]},
+  {&_PrmTypS[14], &_PrmTypLstS[404]},
+  {&_PrmTypS[11], &_PrmTypLstS[405]},
+  {&_PrmTypS[10], &_PrmTypLstS[406]},
+  {&_PrmTypS[9], &_PrmTypLstS[407]},
+  {&_PrmTypS[8], &_PrmTypLstS[408]},
+  {&_PrmTypS[7], &_PrmTypLstS[409]},
+  {&_PrmTypS[34], &_PrmTypLstS[255]},
+  {&_PrmTypS[33], &_PrmTypLstS[411]},
+  {&_PrmTypS[32], &_PrmTypLstS[412]},
+  {&_PrmTypS[29], &_PrmTypLstS[413]},
+  {&_PrmTypS[28], &_PrmTypLstS[414]},
+  {&_PrmTypS[27], &_PrmTypLstS[415]},
+  {&_PrmTypS[26], &_PrmTypLstS[416]},
+  {&_PrmTypS[24], &_PrmTypLstS[417]},
+  {&_PrmTypS[23], &_PrmTypLstS[418]},
+  {&_PrmTypS[17], &_PrmTypLstS[419]},
+  {&_PrmTypS[16], &_PrmTypLstS[420]},
+  {&_PrmTypS[15], &_PrmTypLstS[421]},
+  {&_PrmTypS[14], &_PrmTypLstS[422]},
+  {&_PrmTypS[11], &_PrmTypLstS[423]},
+  {&_PrmTypS[10], &_PrmTypLstS[424]},
+  {&_PrmTypS[9], &_PrmTypLstS[425]},
+  {&_PrmTypS[8], &_PrmTypLstS[426]},
+  {&_PrmTypS[7], &_PrmTypLstS[427]},
+  {&_PrmTypS[27], &_PrmTypLstS[225]},
+  {&_PrmTypS[26], &_PrmTypLstS[429]},
+  {&_PrmTypS[24], &_PrmTypLstS[430]},
+  {&_PrmTypS[23], &_PrmTypLstS[431]},
+  {&_PrmTypS[21], &_PrmTypLstS[432]},
+  {&_PrmTypS[20], &_PrmTypLstS[433]},
+  {&_PrmTypS[19], &_PrmTypLstS[434]},
+  {&_PrmTypS[17], &_PrmTypLstS[435]},
+  {&_PrmTypS[16], &_PrmTypLstS[436]},
+  {&_PrmTypS[15], &_PrmTypLstS[437]},
+  {&_PrmTypS[14], &_PrmTypLstS[438]},
+  {&_PrmTypS[11], &_PrmTypLstS[439]},
+  {&_PrmTypS[10], &_PrmTypLstS[440]},
+  {&_PrmTypS[9], &_PrmTypLstS[441]},
+  {&_PrmTypS[8], &_PrmTypLstS[442]},
+  {&_PrmTypS[7], &_PrmTypLstS[443]},
+  {&_PrmTypS[21], &_PrmTypLstS[318]},
+  {&_PrmTypS[20], &_PrmTypLstS[445]},
+  {&_PrmTypS[19], &_PrmTypLstS[446]},
+  {&_PrmTypS[17], &_PrmTypLstS[447]},
+  {&_PrmTypS[16], &_PrmTypLstS[448]},
+  {&_PrmTypS[15], &_PrmTypLstS[449]},
+  {&_PrmTypS[14], &_PrmTypLstS[450]},
+  {&_PrmTypS[11], &_PrmTypLstS[451]},
+  {&_PrmTypS[10], &_PrmTypLstS[452]},
+  {&_PrmTypS[9], &_PrmTypLstS[453]},
+  {&_PrmTypS[8], &_PrmTypLstS[454]},
+  {&_PrmTypS[7], &_PrmTypLstS[455]},
+  {&_PrmTypS[34], &_PrmTypLstS[314]},
+  {&_PrmTypS[33], &_PrmTypLstS[457]},
+  {&_PrmTypS[32], &_PrmTypLstS[458]},
+  {&_PrmTypS[29], &_PrmTypLstS[459]},
+  {&_PrmTypS[28], &_PrmTypLstS[460]},
+  {&_PrmTypS[27], &_PrmTypLstS[461]},
+  {&_PrmTypS[26], &_PrmTypLstS[462]},
+  {&_PrmTypS[24], &_PrmTypLstS[463]},
+  {&_PrmTypS[23], &_PrmTypLstS[464]},
+  {&_PrmTypS[21], &_PrmTypLstS[465]},
+  {&_PrmTypS[20], &_PrmTypLstS[466]},
+  {&_PrmTypS[19], &_PrmTypLstS[467]},
+  {&_PrmTypS[17], &_PrmTypLstS[468]},
+  {&_PrmTypS[16], &_PrmTypLstS[469]},
+  {&_PrmTypS[15], &_PrmTypLstS[470]},
+  {&_PrmTypS[14], &_PrmTypLstS[471]},
+  {&_PrmTypS[11], &_PrmTypLstS[472]},
+  {&_PrmTypS[10], &_PrmTypLstS[473]},
+  {&_PrmTypS[9], &_PrmTypLstS[474]},
+  {&_PrmTypS[8], &_PrmTypLstS[475]},
+  {&_PrmTypS[7], &_PrmTypLstS[476]},
+  {&_PrmTypS[31], &_PrmTypLstS[225]},
+  {&_PrmTypS[26], &_PrmTypLstS[478]},
+  {&_PrmTypS[24], &_PrmTypLstS[479]},
+  {&_PrmTypS[23], &_PrmTypLstS[480]},
+  {&_PrmTypS[14], &_PrmTypLstS[481]},
+  {&_PrmTypS[11], &_PrmTypLstS[482]},
+  {&_PrmTypS[10], &_PrmTypLstS[483]},
+  {&_PrmTypS[9], &_PrmTypLstS[484]},
+  {&_PrmTypS[8], &_PrmTypLstS[485]},
+  {&_PrmTypS[7], &_PrmTypLstS[486]},
+  {&_PrmTypS[31], &_PrmTypLstS[459]},
+  {&_PrmTypS[29], &_PrmTypLstS[488]},
+  {&_PrmTypS[28], &_PrmTypLstS[489]},
+  {&_PrmTypS[27], &_PrmTypLstS[490]},
+  {&_PrmTypS[26], &_PrmTypLstS[491]},
+  {&_PrmTypS[24], &_PrmTypLstS[492]},
+  {&_PrmTypS[23], &_PrmTypLstS[493]},
+  {&_PrmTypS[21], &_PrmTypLstS[494]},
+  {&_PrmTypS[20], &_PrmTypLstS[495]},
+  {&_PrmTypS[19], &_PrmTypLstS[496]},
+  {&_PrmTypS[17], &_PrmTypLstS[497]},
+  {&_PrmTypS[16], &_PrmTypLstS[498]},
+  {&_PrmTypS[15], &_PrmTypLstS[499]},
+  {&_PrmTypS[14], &_PrmTypLstS[500]},
+  {&_PrmTypS[11], &_PrmTypLstS[501]},
+  {&_PrmTypS[10], &_PrmTypLstS[502]},
+  {&_PrmTypS[9], &_PrmTypLstS[503]},
+  {&_PrmTypS[8], &_PrmTypLstS[504]},
+  {&_PrmTypS[7], &_PrmTypLstS[505]},
+  {&_PrmTypS[13], &_PrmTypLstS[501]},
+  {&_PrmTypS[12], &_PrmTypLstS[507]},
+  {&_PrmTypS[11], &_PrmTypLstS[508]},
+  {&_PrmTypS[10], &_PrmTypLstS[509]},
+  {&_PrmTypS[9], &_PrmTypLstS[510]},
+  {&_PrmTypS[8], &_PrmTypLstS[511]},
+  {&_PrmTypS[7], &_PrmTypLstS[512]},
+  {&_PrmTypS[30], &_PrmTypLstS[478]},
+  {&_PrmTypS[26], &_PrmTypLstS[514]},
+  {&_PrmTypS[24], &_PrmTypLstS[515]},
+  {&_PrmTypS[23], &_PrmTypLstS[516]},
+  {&_PrmTypS[14], &_PrmTypLstS[517]},
+  {&_PrmTypS[11], &_PrmTypLstS[518]},
+  {&_PrmTypS[10], &_PrmTypLstS[519]},
+  {&_PrmTypS[9], &_PrmTypLstS[520]},
+  {&_PrmTypS[8], &_PrmTypLstS[521]},
+  {&_PrmTypS[7], &_PrmTypLstS[522]},
+  {&_PrmTypS[30], &_PrmTypLstS[488]},
+  {&_PrmTypS[29], &_PrmTypLstS[524]},
+  {&_PrmTypS[28], &_PrmTypLstS[525]},
+  {&_PrmTypS[27], &_PrmTypLstS[526]},
+  {&_PrmTypS[26], &_PrmTypLstS[527]},
+  {&_PrmTypS[24], &_PrmTypLstS[528]},
+  {&_PrmTypS[23], &_PrmTypLstS[529]},
+  {&_PrmTypS[21], &_PrmTypLstS[530]},
+  {&_PrmTypS[20], &_PrmTypLstS[531]},
+  {&_PrmTypS[19], &_PrmTypLstS[532]},
+  {&_PrmTypS[17], &_PrmTypLstS[533]},
+  {&_PrmTypS[16], &_PrmTypLstS[534]},
+  {&_PrmTypS[15], &_PrmTypLstS[535]},
+  {&_PrmTypS[14], &_PrmTypLstS[536]},
+  {&_PrmTypS[13], &_PrmTypLstS[537]},
+  {&_PrmTypS[12], &_PrmTypLstS[538]},
+  {&_PrmTypS[11], &_PrmTypLstS[539]},
+  {&_PrmTypS[10], &_PrmTypLstS[540]},
+  {&_PrmTypS[9], &_PrmTypLstS[541]},
+  {&_PrmTypS[8], &_PrmTypLstS[542]},
+  {&_PrmTypS[7], &_PrmTypLstS[543]},
+  {&_PrmTypS[63], &_PrmTypLstS[223]},
+  {&_PrmTypS[43], &_PrmTypLstS[545]},
+  {&_PrmTypS[42], &_PrmTypLstS[546]},
+  {&_PrmTypS[26], &_PrmTypLstS[547]},
+  {&_PrmTypS[24], &_PrmTypLstS[548]},
+  {&_PrmTypS[23], &_PrmTypLstS[549]},
+  {&_PrmTypS[14], &_PrmTypLstS[550]},
+  {&_PrmTypS[11], &_PrmTypLstS[551]},
+  {&_PrmTypS[10], &_PrmTypLstS[552]},
+  {&_PrmTypS[9], &_PrmTypLstS[553]},
+  {&_PrmTypS[8], &_PrmTypLstS[554]},
+  {&_PrmTypS[7], &_PrmTypLstS[555]},
+  {&_PrmTypS[25], &_PrmTypLstS[463]},
+  {&_PrmTypS[24], &_PrmTypLstS[557]},
+  {&_PrmTypS[23], &_PrmTypLstS[558]},
+  {&_PrmTypS[22], &_PrmTypLstS[559]},
+  {&_PrmTypS[21], &_PrmTypLstS[560]},
+  {&_PrmTypS[20], &_PrmTypLstS[561]},
+  {&_PrmTypS[19], &_PrmTypLstS[562]},
+  {&_PrmTypS[18], &_PrmTypLstS[563]},
+  {&_PrmTypS[17], &_PrmTypLstS[564]},
+  {&_PrmTypS[16], &_PrmTypLstS[565]},
+  {&_PrmTypS[15], &_PrmTypLstS[566]},
+  {&_PrmTypS[14], &_PrmTypLstS[567]},
+  {&_PrmTypS[11], &_PrmTypLstS[568]},
+  {&_PrmTypS[10], &_PrmTypLstS[569]},
+  {&_PrmTypS[9], &_PrmTypLstS[570]},
+  {&_PrmTypS[8], &_PrmTypLstS[571]},
+  {&_PrmTypS[7], &_PrmTypLstS[572]},
+  {&_PrmTypS[13], &_PrmTypLstS[568]},
+  {&_PrmTypS[12], &_PrmTypLstS[574]},
+  {&_PrmTypS[11], &_PrmTypLstS[575]},
+  {&_PrmTypS[10], &_PrmTypLstS[576]},
+  {&_PrmTypS[9], &_PrmTypLstS[577]},
+  {&_PrmTypS[8], &_PrmTypLstS[578]},
+  {&_PrmTypS[7], &_PrmTypLstS[579]},
+  {&_PrmTypS[59], &_PrmTypLstS[223]},
+  {&_PrmTypS[43], &_PrmTypLstS[581]},
+  {&_PrmTypS[42], &_PrmTypLstS[582]},
+  {&_PrmTypS[26], &_PrmTypLstS[583]},
+  {&_PrmTypS[24], &_PrmTypLstS[584]},
+  {&_PrmTypS[23], &_PrmTypLstS[585]},
+  {&_PrmTypS[14], &_PrmTypLstS[586]},
+  {&_PrmTypS[11], &_PrmTypLstS[587]},
+  {&_PrmTypS[10], &_PrmTypLstS[588]},
+  {&_PrmTypS[9], &_PrmTypLstS[589]},
+  {&_PrmTypS[8], &_PrmTypLstS[590]},
+  {&_PrmTypS[7], &_PrmTypLstS[591]},
+  {&_PrmTypS[44], &_PrmTypLstS[581]},
+  {&_PrmTypS[43], &_PrmTypLstS[593]},
+  {&_PrmTypS[42], &_PrmTypLstS[594]},
+  {&_PrmTypS[41], &_PrmTypLstS[595]},
+  {&_PrmTypS[40], &_PrmTypLstS[596]},
+  {&_PrmTypS[39], &_PrmTypLstS[597]},
+  {&_PrmTypS[38], &_PrmTypLstS[598]},
+  {&_PrmTypS[37], &_PrmTypLstS[599]},
+  {&_PrmTypS[36], &_PrmTypLstS[600]},
+  {&_PrmTypS[34], &_PrmTypLstS[601]},
+  {&_PrmTypS[33], &_PrmTypLstS[602]},
+  {&_PrmTypS[32], &_PrmTypLstS[603]},
+  {&_PrmTypS[29], &_PrmTypLstS[604]},
+  {&_PrmTypS[28], &_PrmTypLstS[605]},
+  {&_PrmTypS[27], &_PrmTypLstS[606]},
+  {&_PrmTypS[26], &_PrmTypLstS[607]},
+  {&_PrmTypS[25], &_PrmTypLstS[608]},
+  {&_PrmTypS[24], &_PrmTypLstS[609]},
+  {&_PrmTypS[23], &_PrmTypLstS[610]},
+  {&_PrmTypS[22], &_PrmTypLstS[611]},
+  {&_PrmTypS[21], &_PrmTypLstS[612]},
+  {&_PrmTypS[20], &_PrmTypLstS[613]},
+  {&_PrmTypS[19], &_PrmTypLstS[614]},
+  {&_PrmTypS[18], &_PrmTypLstS[615]},
+  {&_PrmTypS[17], &_PrmTypLstS[616]},
+  {&_PrmTypS[16], &_PrmTypLstS[617]},
+  {&_PrmTypS[15], &_PrmTypLstS[618]},
+  {&_PrmTypS[14], &_PrmTypLstS[619]},
+  {&_PrmTypS[13], &_PrmTypLstS[620]},
+  {&_PrmTypS[12], &_PrmTypLstS[621]},
+  {&_PrmTypS[11], &_PrmTypLstS[622]},
+  {&_PrmTypS[10], &_PrmTypLstS[623]},
+  {&_PrmTypS[9], &_PrmTypLstS[624]},
+  {&_PrmTypS[8], &_PrmTypLstS[625]},
+  {&_PrmTypS[7], &_PrmTypLstS[626]},
+  {&_PrmTypS[59], &_PrmTypLstS[545]},
+  {&_PrmTypS[44], &_PrmTypLstS[628]},
+  {&_PrmTypS[43], &_PrmTypLstS[629]},
+  {&_PrmTypS[42], &_PrmTypLstS[630]},
+  {&_PrmTypS[41], &_PrmTypLstS[631]},
+  {&_PrmTypS[40], &_PrmTypLstS[632]},
+  {&_PrmTypS[39], &_PrmTypLstS[633]},
+  {&_PrmTypS[38], &_PrmTypLstS[634]},
+  {&_PrmTypS[37], &_PrmTypLstS[635]},
+  {&_PrmTypS[36], &_PrmTypLstS[636]},
+  {&_PrmTypS[34], &_PrmTypLstS[637]},
+  {&_PrmTypS[33], &_PrmTypLstS[638]},
+  {&_PrmTypS[32], &_PrmTypLstS[639]},
+  {&_PrmTypS[29], &_PrmTypLstS[640]},
+  {&_PrmTypS[28], &_PrmTypLstS[641]},
+  {&_PrmTypS[27], &_PrmTypLstS[642]},
+  {&_PrmTypS[26], &_PrmTypLstS[643]},
+  {&_PrmTypS[25], &_PrmTypLstS[644]},
+  {&_PrmTypS[24], &_PrmTypLstS[645]},
+  {&_PrmTypS[23], &_PrmTypLstS[646]},
+  {&_PrmTypS[22], &_PrmTypLstS[647]},
+  {&_PrmTypS[21], &_PrmTypLstS[648]},
+  {&_PrmTypS[20], &_PrmTypLstS[649]},
+  {&_PrmTypS[19], &_PrmTypLstS[650]},
+  {&_PrmTypS[18], &_PrmTypLstS[651]},
+  {&_PrmTypS[17], &_PrmTypLstS[652]},
+  {&_PrmTypS[16], &_PrmTypLstS[653]},
+  {&_PrmTypS[15], &_PrmTypLstS[654]},
+  {&_PrmTypS[14], &_PrmTypLstS[655]},
+  {&_PrmTypS[13], &_PrmTypLstS[656]},
+  {&_PrmTypS[12], &_PrmTypLstS[657]},
+  {&_PrmTypS[11], &_PrmTypLstS[658]},
+  {&_PrmTypS[10], &_PrmTypLstS[659]},
+  {&_PrmTypS[9], &_PrmTypLstS[660]},
+  {&_PrmTypS[8], &_PrmTypLstS[661]},
+  {&_PrmTypS[7], &_PrmTypLstS[662]},
+  {&_PrmTypS[60], &_PrmTypLstS[223]},
+  {&_PrmTypS[43], &_PrmTypLstS[664]},
+  {&_PrmTypS[42], &_PrmTypLstS[665]},
+  {&_PrmTypS[26], &_PrmTypLstS[666]},
+  {&_PrmTypS[24], &_PrmTypLstS[667]},
+  {&_PrmTypS[23], &_PrmTypLstS[668]},
+  {&_PrmTypS[14], &_PrmTypLstS[669]},
+  {&_PrmTypS[11], &_PrmTypLstS[670]},
+  {&_PrmTypS[10], &_PrmTypLstS[671]},
+  {&_PrmTypS[9], &_PrmTypLstS[672]},
+  {&_PrmTypS[8], &_PrmTypLstS[673]},
+  {&_PrmTypS[7], &_PrmTypLstS[674]},
+  {&_PrmTypS[60], &_PrmTypLstS[545]},
+  {&_PrmTypS[59], &_PrmTypLstS[676]},
+  {&_PrmTypS[44], &_PrmTypLstS[677]},
+  {&_PrmTypS[43], &_PrmTypLstS[678]},
+  {&_PrmTypS[42], &_PrmTypLstS[679]},
+  {&_PrmTypS[41], &_PrmTypLstS[680]},
+  {&_PrmTypS[40], &_PrmTypLstS[681]},
+  {&_PrmTypS[39], &_PrmTypLstS[682]},
+  {&_PrmTypS[38], &_PrmTypLstS[683]},
+  {&_PrmTypS[37], &_PrmTypLstS[684]},
+  {&_PrmTypS[36], &_PrmTypLstS[685]},
+  {&_PrmTypS[34], &_PrmTypLstS[686]},
+  {&_PrmTypS[33], &_PrmTypLstS[687]},
+  {&_PrmTypS[32], &_PrmTypLstS[688]},
+  {&_PrmTypS[29], &_PrmTypLstS[689]},
+  {&_PrmTypS[28], &_PrmTypLstS[690]},
+  {&_PrmTypS[27], &_PrmTypLstS[691]},
+  {&_PrmTypS[26], &_PrmTypLstS[692]},
+  {&_PrmTypS[25], &_PrmTypLstS[693]},
+  {&_PrmTypS[24], &_PrmTypLstS[694]},
+  {&_PrmTypS[23], &_PrmTypLstS[695]},
+  {&_PrmTypS[22], &_PrmTypLstS[696]},
+  {&_PrmTypS[21], &_PrmTypLstS[697]},
+  {&_PrmTypS[20], &_PrmTypLstS[698]},
+  {&_PrmTypS[19], &_PrmTypLstS[699]},
+  {&_PrmTypS[18], &_PrmTypLstS[700]},
+  {&_PrmTypS[17], &_PrmTypLstS[701]},
+  {&_PrmTypS[16], &_PrmTypLstS[702]},
+  {&_PrmTypS[15], &_PrmTypLstS[703]},
+  {&_PrmTypS[14], &_PrmTypLstS[704]},
+  {&_PrmTypS[13], &_PrmTypLstS[705]},
+  {&_PrmTypS[12], &_PrmTypLstS[706]},
+  {&_PrmTypS[11], &_PrmTypLstS[707]},
+  {&_PrmTypS[10], &_PrmTypLstS[708]},
+  {&_PrmTypS[9], &_PrmTypLstS[709]},
+  {&_PrmTypS[8], &_PrmTypLstS[710]},
+  {&_PrmTypS[7], &_PrmTypLstS[711]},
+  {&_PrmTypS[62], &_PrmTypLstS[545]},
+  {&_PrmTypS[60], &_PrmTypLstS[713]},
+  {&_PrmTypS[59], &_PrmTypLstS[714]},
+  {&_PrmTypS[44], &_PrmTypLstS[715]},
+  {&_PrmTypS[43], &_PrmTypLstS[716]},
+  {&_PrmTypS[42], &_PrmTypLstS[717]},
+  {&_PrmTypS[41], &_PrmTypLstS[718]},
+  {&_PrmTypS[40], &_PrmTypLstS[719]},
+  {&_PrmTypS[39], &_PrmTypLstS[720]},
+  {&_PrmTypS[38], &_PrmTypLstS[721]},
+  {&_PrmTypS[37], &_PrmTypLstS[722]},
+  {&_PrmTypS[36], &_PrmTypLstS[723]},
+  {&_PrmTypS[34], &_PrmTypLstS[724]},
+  {&_PrmTypS[33], &_PrmTypLstS[725]},
+  {&_PrmTypS[32], &_PrmTypLstS[726]},
+  {&_PrmTypS[29], &_PrmTypLstS[727]},
+  {&_PrmTypS[28], &_PrmTypLstS[728]},
+  {&_PrmTypS[27], &_PrmTypLstS[729]},
+  {&_PrmTypS[26], &_PrmTypLstS[730]},
+  {&_PrmTypS[25], &_PrmTypLstS[731]},
+  {&_PrmTypS[24], &_PrmTypLstS[732]},
+  {&_PrmTypS[23], &_PrmTypLstS[733]},
+  {&_PrmTypS[22], &_PrmTypLstS[734]},
+  {&_PrmTypS[21], &_PrmTypLstS[735]},
+  {&_PrmTypS[20], &_PrmTypLstS[736]},
+  {&_PrmTypS[19], &_PrmTypLstS[737]},
+  {&_PrmTypS[18], &_PrmTypLstS[738]},
+  {&_PrmTypS[17], &_PrmTypLstS[739]},
+  {&_PrmTypS[16], &_PrmTypLstS[740]},
+  {&_PrmTypS[15], &_PrmTypLstS[741]},
+  {&_PrmTypS[14], &_PrmTypLstS[742]},
+  {&_PrmTypS[13], &_PrmTypLstS[743]},
+  {&_PrmTypS[12], &_PrmTypLstS[744]},
+  {&_PrmTypS[11], &_PrmTypLstS[745]},
+  {&_PrmTypS[10], &_PrmTypLstS[746]},
+  {&_PrmTypS[9], &_PrmTypLstS[747]},
+  {&_PrmTypS[8], &_PrmTypLstS[748]},
+  {&_PrmTypS[7], &_PrmTypLstS[749]},
+  {&_PrmTypS[63], &_PrmTypLstS[195]},
+  {&_PrmTypS[58], &_PrmTypLstS[751]},
+  {&_PrmTypS[57], &_PrmTypLstS[752]},
+  {&_PrmTypS[59], &_PrmTypLstS[751]},
+  {&_PrmTypS[58], &_PrmTypLstS[754]},
+  {&_PrmTypS[57], &_PrmTypLstS[755]},
+  {&_PrmTypS[60], &_PrmTypLstS[751]},
+  {&_PrmTypS[59], &_PrmTypLstS[757]},
+  {&_PrmTypS[58], &_PrmTypLstS[758]},
+  {&_PrmTypS[57], &_PrmTypLstS[759]},
+  {&_PrmTypS[64], &_PrmTypLstS[223]},
+  {&_PrmTypS[63], &_PrmTypLstS[761]},
+  {&_PrmTypS[62], &_PrmTypLstS[762]},
+  {&_PrmTypS[60], &_PrmTypLstS[763]},
+  {&_PrmTypS[59], &_PrmTypLstS[764]},
+  {&_PrmTypS[58], &_PrmTypLstS[765]},
+  {&_PrmTypS[57], &_PrmTypLstS[766]},
+  {&_PrmTypS[44], &_PrmTypLstS[767]},
+  {&_PrmTypS[43], &_PrmTypLstS[768]},
+  {&_PrmTypS[42], &_PrmTypLstS[769]},
+  {&_PrmTypS[41], &_PrmTypLstS[770]},
+  {&_PrmTypS[40], &_PrmTypLstS[771]},
+  {&_PrmTypS[39], &_PrmTypLstS[772]},
+  {&_PrmTypS[38], &_PrmTypLstS[773]},
+  {&_PrmTypS[37], &_PrmTypLstS[774]},
+  {&_PrmTypS[36], &_PrmTypLstS[775]},
+  {&_PrmTypS[34], &_PrmTypLstS[776]},
+  {&_PrmTypS[33], &_PrmTypLstS[777]},
+  {&_PrmTypS[32], &_PrmTypLstS[778]},
+  {&_PrmTypS[29], &_PrmTypLstS[779]},
+  {&_PrmTypS[28], &_PrmTypLstS[780]},
+  {&_PrmTypS[27], &_PrmTypLstS[781]},
+  {&_PrmTypS[26], &_PrmTypLstS[782]},
+  {&_PrmTypS[25], &_PrmTypLstS[783]},
+  {&_PrmTypS[24], &_PrmTypLstS[784]},
+  {&_PrmTypS[23], &_PrmTypLstS[785]},
+  {&_PrmTypS[22], &_PrmTypLstS[786]},
+  {&_PrmTypS[21], &_PrmTypLstS[787]},
+  {&_PrmTypS[20], &_PrmTypLstS[788]},
+  {&_PrmTypS[19], &_PrmTypLstS[789]},
+  {&_PrmTypS[18], &_PrmTypLstS[790]},
+  {&_PrmTypS[17], &_PrmTypLstS[791]},
+  {&_PrmTypS[16], &_PrmTypLstS[792]},
+  {&_PrmTypS[15], &_PrmTypLstS[793]},
+  {&_PrmTypS[14], &_PrmTypLstS[794]},
+  {&_PrmTypS[13], &_PrmTypLstS[795]},
+  {&_PrmTypS[12], &_PrmTypLstS[796]},
+  {&_PrmTypS[11], &_PrmTypLstS[797]},
+  {&_PrmTypS[10], &_PrmTypLstS[798]},
+  {&_PrmTypS[9], &_PrmTypLstS[799]},
+  {&_PrmTypS[8], &_PrmTypLstS[800]},
+  {&_PrmTypS[7], &_PrmTypLstS[801]},
+  {&_PrmTypS[56], &_PrmTypLstS[223]},
+  {&_PrmTypS[43], &_PrmTypLstS[803]},
+  {&_PrmTypS[42], &_PrmTypLstS[804]},
+  {&_PrmTypS[26], &_PrmTypLstS[805]},
+  {&_PrmTypS[24], &_PrmTypLstS[806]},
+  {&_PrmTypS[23], &_PrmTypLstS[807]},
+  {&_PrmTypS[14], &_PrmTypLstS[808]},
+  {&_PrmTypS[11], &_PrmTypLstS[809]},
+  {&_PrmTypS[10], &_PrmTypLstS[810]},
+  {&_PrmTypS[9], &_PrmTypLstS[811]},
+  {&_PrmTypS[8], &_PrmTypLstS[812]},
+  {&_PrmTypS[7], &_PrmTypLstS[813]},
+  {&_PrmTypS[25], &_PrmTypLstS[528]},
+  {&_PrmTypS[24], &_PrmTypLstS[815]},
+  {&_PrmTypS[23], &_PrmTypLstS[816]},
+  {&_PrmTypS[22], &_PrmTypLstS[817]},
+  {&_PrmTypS[21], &_PrmTypLstS[818]},
+  {&_PrmTypS[20], &_PrmTypLstS[819]},
+  {&_PrmTypS[19], &_PrmTypLstS[820]},
+  {&_PrmTypS[18], &_PrmTypLstS[821]},
+  {&_PrmTypS[17], &_PrmTypLstS[822]},
+  {&_PrmTypS[16], &_PrmTypLstS[823]},
+  {&_PrmTypS[15], &_PrmTypLstS[824]},
+  {&_PrmTypS[14], &_PrmTypLstS[825]},
+  {&_PrmTypS[13], &_PrmTypLstS[826]},
+  {&_PrmTypS[12], &_PrmTypLstS[827]},
+  {&_PrmTypS[11], &_PrmTypLstS[828]},
+  {&_PrmTypS[10], &_PrmTypLstS[829]},
+  {&_PrmTypS[9], &_PrmTypLstS[830]},
+  {&_PrmTypS[8], &_PrmTypLstS[831]},
+  {&_PrmTypS[7], &_PrmTypLstS[832]},
+  {&_PrmTypS[61], &_PrmTypLstS[223]},
+  {&_PrmTypS[43], &_PrmTypLstS[834]},
+  {&_PrmTypS[42], &_PrmTypLstS[835]},
+  {&_PrmTypS[26], &_PrmTypLstS[836]},
+  {&_PrmTypS[24], &_PrmTypLstS[837]},
+  {&_PrmTypS[23], &_PrmTypLstS[838]},
+  {&_PrmTypS[14], &_PrmTypLstS[839]},
+  {&_PrmTypS[11], &_PrmTypLstS[840]},
+  {&_PrmTypS[10], &_PrmTypLstS[841]},
+  {&_PrmTypS[9], &_PrmTypLstS[842]},
+  {&_PrmTypS[8], &_PrmTypLstS[843]},
+  {&_PrmTypS[7], &_PrmTypLstS[844]},
+  {&_PrmTypS[61], &_PrmTypLstS[763]},
+  {&_PrmTypS[60], &_PrmTypLstS[846]},
+  {&_PrmTypS[59], &_PrmTypLstS[847]},
+  {&_PrmTypS[58], &_PrmTypLstS[848]},
+  {&_PrmTypS[57], &_PrmTypLstS[849]},
+  {&_PrmTypS[44], &_PrmTypLstS[850]},
+  {&_PrmTypS[43], &_PrmTypLstS[851]},
+  {&_PrmTypS[42], &_PrmTypLstS[852]},
+  {&_PrmTypS[41], &_PrmTypLstS[853]},
+  {&_PrmTypS[40], &_PrmTypLstS[854]},
+  {&_PrmTypS[39], &_PrmTypLstS[855]},
+  {&_PrmTypS[38], &_PrmTypLstS[856]},
+  {&_PrmTypS[37], &_PrmTypLstS[857]},
+  {&_PrmTypS[36], &_PrmTypLstS[858]},
+  {&_PrmTypS[34], &_PrmTypLstS[859]},
+  {&_PrmTypS[33], &_PrmTypLstS[860]},
+  {&_PrmTypS[32], &_PrmTypLstS[861]},
+  {&_PrmTypS[29], &_PrmTypLstS[862]},
+  {&_PrmTypS[28], &_PrmTypLstS[863]},
+  {&_PrmTypS[27], &_PrmTypLstS[864]},
+  {&_PrmTypS[26], &_PrmTypLstS[865]},
+  {&_PrmTypS[25], &_PrmTypLstS[866]},
+  {&_PrmTypS[24], &_PrmTypLstS[867]},
+  {&_PrmTypS[23], &_PrmTypLstS[868]},
+  {&_PrmTypS[22], &_PrmTypLstS[869]},
+  {&_PrmTypS[21], &_PrmTypLstS[870]},
+  {&_PrmTypS[20], &_PrmTypLstS[871]},
+  {&_PrmTypS[19], &_PrmTypLstS[872]},
+  {&_PrmTypS[18], &_PrmTypLstS[873]},
+  {&_PrmTypS[17], &_PrmTypLstS[874]},
+  {&_PrmTypS[16], &_PrmTypLstS[875]},
+  {&_PrmTypS[15], &_PrmTypLstS[876]},
+  {&_PrmTypS[14], &_PrmTypLstS[877]},
+  {&_PrmTypS[13], &_PrmTypLstS[878]},
+  {&_PrmTypS[12], &_PrmTypLstS[879]},
+  {&_PrmTypS[11], &_PrmTypLstS[880]},
+  {&_PrmTypS[10], &_PrmTypLstS[881]},
+  {&_PrmTypS[9], &_PrmTypLstS[882]},
+  {&_PrmTypS[8], &_PrmTypLstS[883]},
+  {&_PrmTypS[7], &_PrmTypLstS[884]},
+  {&_PrmTypS[68], &_PrmTypLstS[223]},
+  {&_PrmTypS[67], &_PrmTypLstS[886]},
+  {&_PrmTypS[66], &_PrmTypLstS[887]},
+  {&_PrmTypS[43], &_PrmTypLstS[888]},
+  {&_PrmTypS[42], &_PrmTypLstS[889]},
+  {&_PrmTypS[26], &_PrmTypLstS[890]},
+  {&_PrmTypS[24], &_PrmTypLstS[891]},
+  {&_PrmTypS[23], &_PrmTypLstS[892]},
+  {&_PrmTypS[14], &_PrmTypLstS[893]},
+  {&_PrmTypS[11], &_PrmTypLstS[894]},
+  {&_PrmTypS[10], &_PrmTypLstS[895]},
+  {&_PrmTypS[9], &_PrmTypLstS[896]},
+  {&_PrmTypS[8], &_PrmTypLstS[897]},
+  {&_PrmTypS[7], &_PrmTypLstS[898]},
+  {&_PrmTypS[66], &_PrmTypLstS[886]},
+  {&_PrmTypS[43], &_PrmTypLstS[900]},
+  {&_PrmTypS[42], &_PrmTypLstS[901]},
+  {&_PrmTypS[26], &_PrmTypLstS[902]},
+  {&_PrmTypS[24], &_PrmTypLstS[903]},
+  {&_PrmTypS[23], &_PrmTypLstS[904]},
+  {&_PrmTypS[14], &_PrmTypLstS[905]},
+  {&_PrmTypS[11], &_PrmTypLstS[906]},
+  {&_PrmTypS[10], &_PrmTypLstS[907]},
+  {&_PrmTypS[9], &_PrmTypLstS[908]},
+  {&_PrmTypS[8], &_PrmTypLstS[909]},
+  {&_PrmTypS[7], &_PrmTypLstS[910]},
+  {&_PrmTypS[44], &_PrmTypLstS[888]},
+  {&_PrmTypS[43], &_PrmTypLstS[912]},
+  {&_PrmTypS[42], &_PrmTypLstS[913]},
+  {&_PrmTypS[41], &_PrmTypLstS[914]},
+  {&_PrmTypS[40], &_PrmTypLstS[915]},
+  {&_PrmTypS[39], &_PrmTypLstS[916]},
+  {&_PrmTypS[38], &_PrmTypLstS[917]},
+  {&_PrmTypS[37], &_PrmTypLstS[918]},
+  {&_PrmTypS[36], &_PrmTypLstS[919]},
+  {&_PrmTypS[27], &_PrmTypLstS[920]},
+  {&_PrmTypS[26], &_PrmTypLstS[921]},
+  {&_PrmTypS[24], &_PrmTypLstS[922]},
+  {&_PrmTypS[23], &_PrmTypLstS[923]},
+  {&_PrmTypS[14], &_PrmTypLstS[924]},
+  {&_PrmTypS[11], &_PrmTypLstS[925]},
+  {&_PrmTypS[10], &_PrmTypLstS[926]},
+  {&_PrmTypS[9], &_PrmTypLstS[927]},
+  {&_PrmTypS[8], &_PrmTypLstS[928]},
+  {&_PrmTypS[7], &_PrmTypLstS[929]},
+  {&_PrmTypS[2], &_PrmTypLstS[239]},
+  {&_PrmTypS[3], &_PrmTypLstS[239]},
+  {&_PrmTypS[4], &_PrmTypLstS[239]},
+  {&_PrmTypS[6], &_PrmTypLstS[239]},
+  {&_PrmTypS[36], &_PrmTypLstS[265]},
+  {&_PrmTypS[26], &_PrmTypLstS[935]},
+  {&_PrmTypS[24], &_PrmTypLstS[936]},
+  {&_PrmTypS[23], &_PrmTypLstS[937]},
+  {&_PrmTypS[14], &_PrmTypLstS[938]},
+  {&_PrmTypS[11], &_PrmTypLstS[939]},
+  {&_PrmTypS[10], &_PrmTypLstS[940]},
+  {&_PrmTypS[9], &_PrmTypLstS[941]},
+  {&_PrmTypS[8], &_PrmTypLstS[942]},
+  {&_PrmTypS[7], &_PrmTypLstS[943]},
+  {&_PrmTypS[40], &_PrmTypLstS[265]},
+  {&_PrmTypS[39], &_PrmTypLstS[945]},
+  {&_PrmTypS[38], &_PrmTypLstS[946]},
+  {&_PrmTypS[37], &_PrmTypLstS[947]},
+  {&_PrmTypS[36], &_PrmTypLstS[948]},
+  {&_PrmTypS[27], &_PrmTypLstS[949]},
+  {&_PrmTypS[26], &_PrmTypLstS[950]},
+  {&_PrmTypS[24], &_PrmTypLstS[951]},
+  {&_PrmTypS[23], &_PrmTypLstS[952]},
+  {&_PrmTypS[14], &_PrmTypLstS[953]},
+  {&_PrmTypS[11], &_PrmTypLstS[954]},
+  {&_PrmTypS[10], &_PrmTypLstS[955]},
+  {&_PrmTypS[9], &_PrmTypLstS[956]},
+  {&_PrmTypS[8], &_PrmTypLstS[957]},
+  {&_PrmTypS[7], &_PrmTypLstS[958]},
+  {&_PrmTypS[13], &_PrmTypLstS[230]},
+  {&_PrmTypS[12], &_PrmTypLstS[960]},
+  {&_PrmTypS[11], &_PrmTypLstS[961]},
+  {&_PrmTypS[10], &_PrmTypLstS[962]},
+  {&_PrmTypS[9], &_PrmTypLstS[963]},
+  {&_PrmTypS[8], &_PrmTypLstS[964]},
+  {&_PrmTypS[7], &_PrmTypLstS[965]},
+  {&_PrmTypS[46], &_PrmTypLstS[223]},
+  {&_PrmTypS[45], &_PrmTypLstS[967]},
+  {&_PrmTypS[43], &_PrmTypLstS[968]},
+  {&_PrmTypS[42], &_PrmTypLstS[969]},
+  {&_PrmTypS[26], &_PrmTypLstS[970]},
+  {&_PrmTypS[24], &_PrmTypLstS[971]},
+  {&_PrmTypS[23], &_PrmTypLstS[972]},
+  {&_PrmTypS[14], &_PrmTypLstS[973]},
+  {&_PrmTypS[11], &_PrmTypLstS[974]},
+  {&_PrmTypS[10], &_PrmTypLstS[975]},
+  {&_PrmTypS[9], &_PrmTypLstS[976]},
+  {&_PrmTypS[8], &_PrmTypLstS[977]},
+  {&_PrmTypS[7], &_PrmTypLstS[978]},
+  {&_PrmTypS[44], &_PrmTypLstS[968]},
+  {&_PrmTypS[43], &_PrmTypLstS[980]},
+  {&_PrmTypS[42], &_PrmTypLstS[981]},
+  {&_PrmTypS[41], &_PrmTypLstS[982]},
+  {&_PrmTypS[40], &_PrmTypLstS[983]},
+  {&_PrmTypS[39], &_PrmTypLstS[984]},
+  {&_PrmTypS[38], &_PrmTypLstS[985]},
+  {&_PrmTypS[37], &_PrmTypLstS[986]},
+  {&_PrmTypS[36], &_PrmTypLstS[987]},
+  {&_PrmTypS[34], &_PrmTypLstS[988]},
+  {&_PrmTypS[33], &_PrmTypLstS[989]},
+  {&_PrmTypS[32], &_PrmTypLstS[990]},
+  {&_PrmTypS[31], &_PrmTypLstS[991]},
+  {&_PrmTypS[30], &_PrmTypLstS[992]},
+  {&_PrmTypS[29], &_PrmTypLstS[993]},
+  {&_PrmTypS[28], &_PrmTypLstS[994]},
+  {&_PrmTypS[27], &_PrmTypLstS[995]},
+  {&_PrmTypS[26], &_PrmTypLstS[996]},
+  {&_PrmTypS[25], &_PrmTypLstS[997]},
+  {&_PrmTypS[24], &_PrmTypLstS[998]},
+  {&_PrmTypS[23], &_PrmTypLstS[999]},
+  {&_PrmTypS[22], &_PrmTypLstS[1000]},
+  {&_PrmTypS[21], &_PrmTypLstS[1001]},
+  {&_PrmTypS[20], &_PrmTypLstS[1002]},
+  {&_PrmTypS[19], &_PrmTypLstS[1003]},
+  {&_PrmTypS[18], &_PrmTypLstS[1004]},
+  {&_PrmTypS[17], &_PrmTypLstS[1005]},
+  {&_PrmTypS[16], &_PrmTypLstS[1006]},
+  {&_PrmTypS[15], &_PrmTypLstS[1007]},
+  {&_PrmTypS[14], &_PrmTypLstS[1008]},
+  {&_PrmTypS[13], &_PrmTypLstS[1009]},
+  {&_PrmTypS[12], &_PrmTypLstS[1010]},
+  {&_PrmTypS[11], &_PrmTypLstS[1011]},
+  {&_PrmTypS[10], &_PrmTypLstS[1012]},
+  {&_PrmTypS[9], &_PrmTypLstS[1013]},
+  {&_PrmTypS[8], &_PrmTypLstS[1014]},
+  {&_PrmTypS[7], &_PrmTypLstS[1015]},
+  {&_PrmTypS[34], &_PrmTypLstS[356]},
+  {&_PrmTypS[33], &_PrmTypLstS[1017]},
+  {&_PrmTypS[32], &_PrmTypLstS[1018]},
+  {&_PrmTypS[31], &_PrmTypLstS[1019]},
+  {&_PrmTypS[30], &_PrmTypLstS[1020]},
+  {&_PrmTypS[29], &_PrmTypLstS[1021]},
+  {&_PrmTypS[28], &_PrmTypLstS[1022]},
+  {&_PrmTypS[27], &_PrmTypLstS[1023]},
+  {&_PrmTypS[26], &_PrmTypLstS[1024]},
+  {&_PrmTypS[24], &_PrmTypLstS[1025]},
+  {&_PrmTypS[23], &_PrmTypLstS[1026]},
+  {&_PrmTypS[21], &_PrmTypLstS[1027]},
+  {&_PrmTypS[20], &_PrmTypLstS[1028]},
+  {&_PrmTypS[19], &_PrmTypLstS[1029]},
+  {&_PrmTypS[17], &_PrmTypLstS[1030]},
+  {&_PrmTypS[16], &_PrmTypLstS[1031]},
+  {&_PrmTypS[15], &_PrmTypLstS[1032]},
+  {&_PrmTypS[14], &_PrmTypLstS[1033]},
+  {&_PrmTypS[13], &_PrmTypLstS[1034]},
+  {&_PrmTypS[12], &_PrmTypLstS[1035]},
+  {&_PrmTypS[11], &_PrmTypLstS[1036]},
+  {&_PrmTypS[10], &_PrmTypLstS[1037]},
+  {&_PrmTypS[9], &_PrmTypLstS[1038]},
+  {&_PrmTypS[8], &_PrmTypLstS[1039]},
+  {&_PrmTypS[7], &_PrmTypLstS[1040]},
+  {&_PrmTypS[52], &_PrmTypLstS[223]},
+  {&_PrmTypS[43], &_PrmTypLstS[1042]},
+  {&_PrmTypS[42], &_PrmTypLstS[1043]},
+  {&_PrmTypS[26], &_PrmTypLstS[1044]},
+  {&_PrmTypS[24], &_PrmTypLstS[1045]},
+  {&_PrmTypS[23], &_PrmTypLstS[1046]},
+  {&_PrmTypS[14], &_PrmTypLstS[1047]},
+  {&_PrmTypS[11], &_PrmTypLstS[1048]},
+  {&_PrmTypS[10], &_PrmTypLstS[1049]},
+  {&_PrmTypS[9], &_PrmTypLstS[1050]},
+  {&_PrmTypS[8], &_PrmTypLstS[1051]},
+  {&_PrmTypS[7], &_PrmTypLstS[1052]},
+  {&_PrmTypS[53], &_PrmTypLstS[223]},
+  {&_PrmTypS[43], &_PrmTypLstS[1054]},
+  {&_PrmTypS[42], &_PrmTypLstS[1055]},
+  {&_PrmTypS[26], &_PrmTypLstS[1056]},
+  {&_PrmTypS[24], &_PrmTypLstS[1057]},
+  {&_PrmTypS[23], &_PrmTypLstS[1058]},
+  {&_PrmTypS[14], &_PrmTypLstS[1059]},
+  {&_PrmTypS[11], &_PrmTypLstS[1060]},
+  {&_PrmTypS[10], &_PrmTypLstS[1061]},
+  {&_PrmTypS[9], &_PrmTypLstS[1062]},
+  {&_PrmTypS[8], &_PrmTypLstS[1063]},
+  {&_PrmTypS[7], &_PrmTypLstS[1064]},
+  {&_PrmTypS[55], &_PrmTypLstS[223]},
+  {&_PrmTypS[54], &_PrmTypLstS[1066]},
+  {&_PrmTypS[43], &_PrmTypLstS[1067]},
+  {&_PrmTypS[42], &_PrmTypLstS[1068]},
+  {&_PrmTypS[26], &_PrmTypLstS[1069]},
+  {&_PrmTypS[24], &_PrmTypLstS[1070]},
+  {&_PrmTypS[23], &_PrmTypLstS[1071]},
+  {&_PrmTypS[14], &_PrmTypLstS[1072]},
+  {&_PrmTypS[11], &_PrmTypLstS[1073]},
+  {&_PrmTypS[10], &_PrmTypLstS[1074]},
+  {&_PrmTypS[9], &_PrmTypLstS[1075]},
+  {&_PrmTypS[8], &_PrmTypLstS[1076]},
+  {&_PrmTypS[7], &_PrmTypLstS[1077]},
+  {&_PrmTypS[60], &_PrmTypLstS[762]},
+  {&_PrmTypS[59], &_PrmTypLstS[1079]},
+  {&_PrmTypS[58], &_PrmTypLstS[1080]},
+  {&_PrmTypS[57], &_PrmTypLstS[1081]},
+  {&_PrmTypS[43], &_PrmTypLstS[1082]},
+  {&_PrmTypS[42], &_PrmTypLstS[1083]},
+  {&_PrmTypS[26], &_PrmTypLstS[1084]},
+  {&_PrmTypS[24], &_PrmTypLstS[1085]},
+  {&_PrmTypS[23], &_PrmTypLstS[1086]},
+  {&_PrmTypS[14], &_PrmTypLstS[1087]},
+  {&_PrmTypS[11], &_PrmTypLstS[1088]},
+  {&_PrmTypS[10], &_PrmTypLstS[1089]},
+  {&_PrmTypS[9], &_PrmTypLstS[1090]},
+  {&_PrmTypS[8], &_PrmTypLstS[1091]},
+  {&_PrmTypS[7], &_PrmTypLstS[1092]},
+  {&_PrmTypS[62], &_PrmTypLstS[223]},
+  {&_PrmTypS[43], &_PrmTypLstS[1094]},
+  {&_PrmTypS[42], &_PrmTypLstS[1095]},
+  {&_PrmTypS[26], &_PrmTypLstS[1096]},
+  {&_PrmTypS[24], &_PrmTypLstS[1097]},
+  {&_PrmTypS[23], &_PrmTypLstS[1098]},
+  {&_PrmTypS[14], &_PrmTypLstS[1099]},
+  {&_PrmTypS[11], &_PrmTypLstS[1100]},
+  {&_PrmTypS[10], &_PrmTypLstS[1101]},
+  {&_PrmTypS[9], &_PrmTypLstS[1102]},
+  {&_PrmTypS[8], &_PrmTypLstS[1103]},
+  {&_PrmTypS[7], &_PrmTypLstS[1104]},
+  {&_PrmTypS[65], &_PrmTypLstS[223]},
+  {&_PrmTypS[43], &_PrmTypLstS[1106]},
+  {&_PrmTypS[42], &_PrmTypLstS[1107]},
+  {&_PrmTypS[27], &_PrmTypLstS[1108]},
+  {&_PrmTypS[26], &_PrmTypLstS[1109]},
+  {&_PrmTypS[24], &_PrmTypLstS[1110]},
+  {&_PrmTypS[23], &_PrmTypLstS[1111]},
+  {&_PrmTypS[14], &_PrmTypLstS[1112]},
+  {&_PrmTypS[11], &_PrmTypLstS[1113]},
+  {&_PrmTypS[10], &_PrmTypLstS[1114]},
+  {&_PrmTypS[9], &_PrmTypLstS[1115]},
+  {&_PrmTypS[8], &_PrmTypLstS[1116]},
+  {&_PrmTypS[7], &_PrmTypLstS[1117]},
+  {&_PrmTypS[44], &_PrmTypLstS[1106]},
+  {&_PrmTypS[43], &_PrmTypLstS[1119]},
+  {&_PrmTypS[42], &_PrmTypLstS[1120]},
+  {&_PrmTypS[41], &_PrmTypLstS[1121]},
+  {&_PrmTypS[40], &_PrmTypLstS[1122]},
+  {&_PrmTypS[39], &_PrmTypLstS[1123]},
+  {&_PrmTypS[38], &_PrmTypLstS[1124]},
+  {&_PrmTypS[37], &_PrmTypLstS[1125]},
+  {&_PrmTypS[36], &_PrmTypLstS[1126]},
+  {&_PrmTypS[34], &_PrmTypLstS[1127]},
+  {&_PrmTypS[33], &_PrmTypLstS[1128]},
+  {&_PrmTypS[32], &_PrmTypLstS[1129]},
+  {&_PrmTypS[31], &_PrmTypLstS[1130]},
+  {&_PrmTypS[30], &_PrmTypLstS[1131]},
+  {&_PrmTypS[29], &_PrmTypLstS[1132]},
+  {&_PrmTypS[28], &_PrmTypLstS[1133]},
+  {&_PrmTypS[27], &_PrmTypLstS[1134]},
+  {&_PrmTypS[26], &_PrmTypLstS[1135]},
+  {&_PrmTypS[25], &_PrmTypLstS[1136]},
+  {&_PrmTypS[24], &_PrmTypLstS[1137]},
+  {&_PrmTypS[23], &_PrmTypLstS[1138]},
+  {&_PrmTypS[22], &_PrmTypLstS[1139]},
+  {&_PrmTypS[21], &_PrmTypLstS[1140]},
+  {&_PrmTypS[20], &_PrmTypLstS[1141]},
+  {&_PrmTypS[19], &_PrmTypLstS[1142]},
+  {&_PrmTypS[18], &_PrmTypLstS[1143]},
+  {&_PrmTypS[17], &_PrmTypLstS[1144]},
+  {&_PrmTypS[16], &_PrmTypLstS[1145]},
+  {&_PrmTypS[15], &_PrmTypLstS[1146]},
+  {&_PrmTypS[14], &_PrmTypLstS[1147]},
+  {&_PrmTypS[13], &_PrmTypLstS[1148]},
+  {&_PrmTypS[12], &_PrmTypLstS[1149]},
+  {&_PrmTypS[11], &_PrmTypLstS[1150]},
+  {&_PrmTypS[10], &_PrmTypLstS[1151]},
+  {&_PrmTypS[9], &_PrmTypLstS[1152]},
+  {&_PrmTypS[8], &_PrmTypLstS[1153]},
+  {&_PrmTypS[7], &_PrmTypLstS[1154]} };
+int num_EnvVarS = 38;
+tps_EnvVar _EnvVarS [38] = {
+  {"ODIN_VERSION_STR", "odin-build release number", 2, "1.18.0", 0},
+  {"ODIN_CC", "name of the C compiler", 2, "gcc", 0},
+  {"ODIN_CC_FLAGS", "C compiler flags", 2, "-g -O2", 0},
+  {"ODIN_CPP", "name of the C preprocessor", 2, "gcc -E", 0},
+  {"ODIN_CPP_FLAGS", "C preprocessor flags", 2, "", 0},
+  {"ODIN_CXX", "name of the C++ compiler", 2, "g++", 0},
+  {"ODIN_CXX_FLAGS", "CC flags", 2, "-g -O2", 0},
+  {"ODIN_YACC", "name of the yacc compiler", 2, "bison -y", 0},
+  {"ODIN_RANLIB", "archive symbol table program", 2, "ranlib", 0},
+  {"ODIN_RBSCMD", "the name of the Odin remote-build-server", 1, "odin/rbs.sh", 0},
+  {"ODIN_SHORTNAMES", "use short cache filenames", 1, "", 0},
+  {"ODIN_LOCALIPC", "use Unix domain interprocess communication", 1, "", 0},
+  {"ODIN_PASTE", "name of the multi-file line merge command", 1, "paste", 0},
+  {"ODINCACHE", "the Odin cache directory", 1, "", 0},
+  {"DUMPCORE", "whether to dump core when anomaly detected", 1, "yes", 0},
+  {"ODIN_VC_RCS", "look for RCS files in viewpath", 2, "yes", 0},
+  {"ODIN_VC_SCCS", "look for SCCS files in viewpath", 2, "yes", 0},
+  {"ODIN_IGNORE", "egrep expression for includes to ignore", 2, "/usr/include", 0},
+  {"ODIN_LIB_SP", "default library search path", 2, "/lib /usr/lib", 0},
+  {"ODIN_CC_HOME", "directory containing the C compiler", 2, "", 0},
+  {"ODIN_CC_DEBUGF", "debug flag for C compiler", 2, "-g", 0},
+  {"ODIN_CC_I", "directory containing default C include files", 2, "/usr/include", 0},
+  {"ODIN_CXX_HOME", "directory containing the C++ compiler", 2, "", 0},
+  {"ODIN_CXX_DEBUGF", "debug flag for C++ compiler", 2, "-g", 0},
+  {"ODIN_CXX_I", "directory containing default C++ include files", 2, "/usr/lib/CC/include", 0},
+  {"ODIN_CXX_PTR", "template repository directory", 2, "1", 0},
+  {"ODIN_CXX_LD_DEBUGF", "debug flag for C++ linker", 2, "-g", 0},
+  {"ODIN_CXX_LD_LIBRARY_PATH", "load library path for C++", 2, "/usr/lib/CC", 0},
+  {"ODIN_CXX_IGNORE_ERR", "egrep expression for errors to ignore", 2, "", 0},
+  {"OS_ROOTDIR", "ObjectStore root directory", 2, "/net/xlendi/usr2/ostore-r3.0", 0},
+  {"ODIN_SYS5", "use Unix System V conventions", 1, "", 0},
+  {"ODIN_YACC_FLAGS", "yacc flags", 2, "-dv", 0},
+  {"ODIN_IDL_HOME", "directory containing the idl compiler", 2, "", 0},
+  {"ODIN_IDL", "name of the idl compiler", 2, "idl++", 0},
+  {"ODIN_IDL_FLAGS", "idl flags", 2, "-keep source", 0},
+  {"ODIN_IDL_I", "directory containing default idl include files", 2, "", 0},
+  {"ODIN_LINT_PASS1_FLAG", "pass-1 only lint flag", 2, "-c", 0},
+  {"ODIN_LINT_FLAGS", "lint flags", 2, "", 0} };
+int num_EnvVarLstS = 77;
+tps_EnvVarLst _EnvVarLstS [77] = {
+  {0, 0},
+  {&_EnvVarS[15], 0},
+  {&_EnvVarS[16], 0},
+  {&_EnvVarS[15], &_EnvVarLstS[2]},
+  {&_EnvVarS[8], 0},
+  {&_EnvVarS[18], 0},
+  {&_EnvVarS[21], 0},
+  {&_EnvVarS[17], 0},
+  {&_EnvVarS[17], &_EnvVarLstS[6]},
+  {&_EnvVarS[1], 0},
+  {&_EnvVarS[20], 0},
+  {&_EnvVarS[1], &_EnvVarLstS[10]},
+  {&_EnvVarS[2], 0},
+  {&_EnvVarS[2], &_EnvVarLstS[10]},
+  {&_EnvVarS[1], &_EnvVarLstS[13]},
+  {&_EnvVarS[19], 0},
+  {&_EnvVarS[19], &_EnvVarLstS[10]},
+  {&_EnvVarS[2], &_EnvVarLstS[16]},
+  {&_EnvVarS[1], &_EnvVarLstS[17]},
+  {&_EnvVarS[3], 0},
+  {&_EnvVarS[4], 0},
+  {&_EnvVarS[3], &_EnvVarLstS[20]},
+  {&_EnvVarS[24], 0},
+  {&_EnvVarS[17], &_EnvVarLstS[22]},
+  {&_EnvVarS[5], 0},
+  {&_EnvVarS[23], 0},
+  {&_EnvVarS[5], &_EnvVarLstS[25]},
+  {&_EnvVarS[6], 0},
+  {&_EnvVarS[6], &_EnvVarLstS[25]},
+  {&_EnvVarS[5], &_EnvVarLstS[28]},
+  {&_EnvVarS[22], 0},
+  {&_EnvVarS[22], &_EnvVarLstS[25]},
+  {&_EnvVarS[6], &_EnvVarLstS[31]},
+  {&_EnvVarS[5], &_EnvVarLstS[32]},
+  {&_EnvVarS[27], 0},
+  {&_EnvVarS[23], &_EnvVarLstS[34]},
+  {&_EnvVarS[22], &_EnvVarLstS[35]},
+  {&_EnvVarS[6], &_EnvVarLstS[36]},
+  {&_EnvVarS[5], &_EnvVarLstS[37]},
+  {&_EnvVarS[25], 0},
+  {&_EnvVarS[25], &_EnvVarLstS[34]},
+  {&_EnvVarS[23], &_EnvVarLstS[40]},
+  {&_EnvVarS[22], &_EnvVarLstS[41]},
+  {&_EnvVarS[6], &_EnvVarLstS[42]},
+  {&_EnvVarS[5], &_EnvVarLstS[43]},
+  {&_EnvVarS[28], 0},
+  {&_EnvVarS[23], &_EnvVarLstS[45]},
+  {&_EnvVarS[22], &_EnvVarLstS[46]},
+  {&_EnvVarS[6], &_EnvVarLstS[47]},
+  {&_EnvVarS[5], &_EnvVarLstS[48]},
+  {&_EnvVarS[27], &_EnvVarLstS[45]},
+  {&_EnvVarS[23], &_EnvVarLstS[50]},
+  {&_EnvVarS[22], &_EnvVarLstS[51]},
+  {&_EnvVarS[6], &_EnvVarLstS[52]},
+  {&_EnvVarS[5], &_EnvVarLstS[53]},
+  {&_EnvVarS[25], &_EnvVarLstS[50]},
+  {&_EnvVarS[23], &_EnvVarLstS[55]},
+  {&_EnvVarS[22], &_EnvVarLstS[56]},
+  {&_EnvVarS[6], &_EnvVarLstS[57]},
+  {&_EnvVarS[5], &_EnvVarLstS[58]},
+  {&_EnvVarS[29], 0},
+  {&_EnvVarS[30], 0},
+  {&_EnvVarS[7], 0},
+  {&_EnvVarS[7], &_EnvVarLstS[61]},
+  {&_EnvVarS[31], 0},
+  {&_EnvVarS[30], &_EnvVarLstS[64]},
+  {&_EnvVarS[7], &_EnvVarLstS[65]},
+  {&_EnvVarS[35], 0},
+  {&_EnvVarS[17], &_EnvVarLstS[67]},
+  {&_EnvVarS[33], 0},
+  {&_EnvVarS[34], 0},
+  {&_EnvVarS[33], &_EnvVarLstS[70]},
+  {&_EnvVarS[32], 0},
+  {&_EnvVarS[32], &_EnvVarLstS[71]},
+  {&_EnvVarS[37], 0},
+  {&_EnvVarS[36], 0},
+  {&_EnvVarS[36], &_EnvVarLstS[74]} };
+int num_ToolS = 190;
+tps_Tool _ToolS [190] = {
+  {1, 0, 0, 0, "."},
+  {12, 0, 0, 0, "."},
+  {2, 0, 0, 0, "."},
+  {47, 0, 0, 0, "."},
+  {8, 0, 0, 0, "."},
+  {37, 0, 0, 0, "."},
+  {10, 0, 0, 0, "."},
+  {18, 0, 0, 0, "."},
+  {13, &_InpEdgS[0], 0, 0, "odin"},
+  {14, &_InpEdgS[1], 0, 0, "odin"},
+  {21, &_InpEdgS[3], 0, 0, "odin"},
+  {4, &_InpEdgS[2], 0, 0, "odin"},
+  {15, &_InpEdgS[5], 0, 0, "odin"},
+  {16, &_InpEdgS[7], 0, 0, "odin"},
+  {17, &_InpEdgS[8], 0, 0, "odin"},
+  {29, &_InpEdgS[9], 0, 0, "odin"},
+  {11, &_InpEdgS[10], &_PrmTypLstS[1], 0, "odin"},
+  {28, &_InpEdgS[13], &_PrmTypLstS[2], 0, "odin"},
+  {3, &_InpEdgS[15], 0, 0, "."},
+  {3, &_InpEdgS[16], 0, 0, "."},
+  {41, &_InpEdgS[17], 0, 0, "odin"},
+  {40, &_InpEdgS[18], 0, 0, "odin"},
+  {30, &_InpEdgS[20], 0, 0, "odin"},
+  {31, &_InpEdgS[21], 0, 0, "odin"},
+  {43, &_InpEdgS[22], 0, 0, "odin"},
+  {44, &_InpEdgS[23], 0, 0, "odin"},
+  {27, &_InpEdgS[24], 0, 0, "odin"},
+  {45, &_InpEdgS[25], 0, 0, "odin"},
+  {46, &_InpEdgS[26], 0, 0, "odin"},
+  {33, &_InpEdgS[27], 0, 0, "odin"},
+  {34, &_InpEdgS[28], 0, 0, "odin"},
+  {35, &_InpEdgS[29], 0, 0, "odin"},
+  {36, &_InpEdgS[30], 0, 0, "odin"},
+  {19, &_InpEdgS[31], 0, 0, "odin"},
+  {20, &_InpEdgS[32], 0, 0, "odin"},
+  {38, &_InpEdgS[33], 0, 0, "odin"},
+  {32, &_InpEdgS[34], 0, 0, "odin"},
+  {23, &_InpEdgS[35], 0, 0, "odin"},
+  {24, &_InpEdgS[36], 0, 0, "odin"},
+  {25, &_InpEdgS[37], 0, 0, "odin"},
+  {26, &_InpEdgS[38], 0, 0, "odin"},
+  {39, &_InpEdgS[39], &_PrmTypLstS[3], 0, "odin"},
+  {11, &_InpEdgS[41], 0, 0, "odin"},
+  {49, &_InpEdgS[43], 0, 0, "odin"},
+  {50, &_InpEdgS[44], 0, 0, "odin"},
+  {51, &_InpEdgS[45], 0, 0, "odin"},
+  {52, &_InpEdgS[46], &_PrmTypLstS[4], 0, "odin"},
+  {11, &_InpEdgS[48], &_PrmTypLstS[14], 0, "vc"},
+  {11, &_InpEdgS[54], &_PrmTypLstS[14], 0, "vc"},
+  {11, &_InpEdgS[60], &_PrmTypLstS[7], 0, "vc"},
+  {11, &_InpEdgS[64], &_PrmTypLstS[7], 0, "vc"},
+  {11, &_InpEdgS[68], &_PrmTypLstS[15], &_EnvVarLstS[3], "vc"},
+  {11, &_InpEdgS[73], 0, 0, "vc"},
+  {11, &_InpEdgS[76], 0, 0, "vc"},
+  {4, &_InpEdgS[78], 0, 0, "odin"},
+  {21, &_InpEdgS[80], 0, 0, "vc"},
+  {22, &_InpEdgS[81], 0, 0, "code"},
+  {21, &_InpEdgS[83], 0, 0, "code"},
+  {5, &_InpEdgS[82], 0, 0, "odin"},
+  {11, &_InpEdgS[84], 0, 0, "code"},
+  {4, &_InpEdgS[85], 0, 0, "odin"},
+  {4, &_InpEdgS[87], 0, 0, "odin"},
+  {11, &_InpEdgS[89], 0, &_EnvVarLstS[4], "code"},
+  {3, &_InpEdgS[93], 0, 0, "."},
+  {3, &_InpEdgS[94], 0, 0, "."},
+  {11, &_InpEdgS[95], &_PrmTypLstS[18], &_EnvVarLstS[5], "code"},
+  {21, &_InpEdgS[101], 0, 0, "code"},
+  {21, &_InpEdgS[102], 0, 0, "cc"},
+  {22, &_InpEdgS[103], 0, 0, "cc"},
+  {11, &_InpEdgS[104], &_PrmTypLstS[24], &_EnvVarLstS[8], "cc"},
+  {21, &_InpEdgS[112], 0, 0, "cc"},
+  {21, &_InpEdgS[114], 0, 0, "cc"},
+  {4, &_InpEdgS[113], 0, 0, "odin"},
+  {11, &_InpEdgS[116], &_PrmTypLstS[54], &_EnvVarLstS[18], "cc"},
+  {48, &_InpEdgS[128], 0, 0, "odin"},
+  {11, &_InpEdgS[134], &_PrmTypLstS[77], &_EnvVarLstS[18], "cc"},
+  {11, &_InpEdgS[152], 0, 0, "cc"},
+  {11, &_InpEdgS[154], &_PrmTypLstS[78], 0, "cc"},
+  {11, &_InpEdgS[159], &_PrmTypLstS[78], &_EnvVarLstS[21], "cpp"},
+  {11, &_InpEdgS[168], &_PrmTypLstS[78], &_EnvVarLstS[21], "cpp"},
+  {21, &_InpEdgS[177], 0, 0, "cxx"},
+  {22, &_InpEdgS[178], 0, 0, "cxx"},
+  {11, &_InpEdgS[179], &_PrmTypLstS[24], &_EnvVarLstS[23], "cxx"},
+  {21, &_InpEdgS[187], 0, 0, "cxx"},
+  {21, &_InpEdgS[189], 0, 0, "cxx"},
+  {4, &_InpEdgS[188], 0, 0, "odin"},
+  {11, &_InpEdgS[191], &_PrmTypLstS[99], &_EnvVarLstS[44], "cxx"},
+  {48, &_InpEdgS[203], 0, 0, "odin"},
+  {11, &_InpEdgS[211], &_PrmTypLstS[122], &_EnvVarLstS[59], "cxx"},
+  {22, &_InpEdgS[234], 0, 0, "odi"},
+  {11, &_InpEdgS[235], &_PrmTypLstS[126], &_EnvVarLstS[60], "odi"},
+  {4, &_InpEdgS[237], 0, 0, "odin"},
+  {11, &_InpEdgS[246], &_PrmTypLstS[124], &_EnvVarLstS[60], "odi"},
+  {21, &_InpEdgS[254], 0, 0, "odi"},
+  {11, &_InpEdgS[256], &_PrmTypLstS[139], 0, "f77"},
+  {11, &_InpEdgS[263], &_PrmTypLstS[140], 0, "lex"},
+  {3, &_InpEdgS[266], 0, 0, "."},
+  {3, &_InpEdgS[267], 0, 0, "."},
+  {3, &_InpEdgS[268], 0, 0, "."},
+  {11, &_InpEdgS[269], &_PrmTypLstS[157], &_EnvVarLstS[66], "yacc"},
+  {3, &_InpEdgS[280], 0, 0, "."},
+  {3, &_InpEdgS[281], 0, 0, "."},
+  {3, &_InpEdgS[282], 0, 0, "."},
+  {3, &_InpEdgS[283], 0, 0, "."},
+  {11, &_InpEdgS[284], &_PrmTypLstS[140], 0, "tregrm"},
+  {3, &_InpEdgS[288], 0, 0, "."},
+  {3, &_InpEdgS[289], 0, 0, "."},
+  {3, &_InpEdgS[290], 0, 0, "."},
+  {3, &_InpEdgS[291], 0, 0, "."},
+  {11, &_InpEdgS[292], &_PrmTypLstS[158], 0, "dg"},
+  {11, &_InpEdgS[297], &_PrmTypLstS[24], &_EnvVarLstS[68], "idl"},
+  {21, &_InpEdgS[305], 0, 0, "idl"},
+  {21, &_InpEdgS[307], 0, 0, "idl"},
+  {4, &_InpEdgS[306], 0, 0, "odin"},
+  {3, &_InpEdgS[309], 0, 0, "."},
+  {3, &_InpEdgS[310], 0, 0, "."},
+  {3, &_InpEdgS[311], 0, 0, "."},
+  {3, &_InpEdgS[312], 0, 0, "."},
+  {3, &_InpEdgS[313], 0, 0, "."},
+  {11, &_InpEdgS[314], &_PrmTypLstS[160], &_EnvVarLstS[73], "idl"},
+  {48, &_InpEdgS[319], 0, 0, "odin"},
+  {21, &_InpEdgS[324], 0, 0, "idl"},
+  {21, &_InpEdgS[328], 0, 0, "idl"},
+  {11, &_InpEdgS[329], 0, 0, "idl"},
+  {11, &_InpEdgS[333], &_PrmTypLstS[163], 0, "prof"},
+  {3, &_InpEdgS[338], 0, 0, "."},
+  {3, &_InpEdgS[339], 0, 0, "."},
+  {11, &_InpEdgS[340], &_PrmTypLstS[170], &_EnvVarLstS[76], "lint"},
+  {11, &_InpEdgS[350], &_PrmTypLstS[182], &_EnvVarLstS[74], "lint"},
+  {4, &_InpEdgS[351], 0, 0, "odin"},
+  {4, &_InpEdgS[353], 0, 0, "odin"},
+  {22, &_InpEdgS[365], 0, 0, "misc"},
+  {11, &_InpEdgS[366], 0, 0, "misc"},
+  {11, &_InpEdgS[368], 0, 0, "misc"},
+  {11, &_InpEdgS[370], &_PrmTypLstS[183], 0, "misc"},
+  {22, &_InpEdgS[373], 0, 0, "misc"},
+  {11, &_InpEdgS[374], &_PrmTypLstS[184], 0, "misc"},
+  {11, &_InpEdgS[377], &_PrmTypLstS[187], 0, "misc"},
+  {11, &_InpEdgS[381], &_PrmTypLstS[19], 0, "roff"},
+  {22, &_InpEdgS[384], 0, 0, "roff"},
+  {21, &_InpEdgS[386], 0, 0, "roff"},
+  {4, &_InpEdgS[385], 0, 0, "odin"},
+  {11, &_InpEdgS[388], 0, 0, "roff"},
+  {11, &_InpEdgS[391], 0, 0, "roff"},
+  {11, &_InpEdgS[394], 0, 0, "roff"},
+  {11, &_InpEdgS[396], &_PrmTypLstS[188], 0, "roff"},
+  {48, &_InpEdgS[400], 0, 0, "odin"},
+  {11, &_InpEdgS[402], 0, 0, "tex"},
+  {3, &_InpEdgS[405], 0, 0, "."},
+  {3, &_InpEdgS[406], 0, 0, "."},
+  {11, &_InpEdgS[407], &_PrmTypLstS[189], 0, "tex"},
+  {11, &_InpEdgS[411], &_PrmTypLstS[190], 0, "tex"},
+  {21, &_InpEdgS[415], 0, 0, "tex"},
+  {6, &_InpEdgS[416], 0, 0, "odin"},
+  {4, &_InpEdgS[417], 0, 0, "odin"},
+  {21, &_InpEdgS[419], 0, 0, "tex"},
+  {11, &_InpEdgS[420], &_PrmTypLstS[191], 0, "tex"},
+  {11, &_InpEdgS[423], 0, 0, "tex"},
+  {21, &_InpEdgS[426], 0, 0, "tex"},
+  {11, &_InpEdgS[427], &_PrmTypLstS[197], 0, "tex"},
+  {3, &_InpEdgS[432], 0, 0, "."},
+  {3, &_InpEdgS[433], 0, 0, "."},
+  {3, &_InpEdgS[434], 0, 0, "."},
+  {3, &_InpEdgS[435], 0, 0, "."},
+  {3, &_InpEdgS[436], 0, 0, "."},
+  {3, &_InpEdgS[437], 0, 0, "."},
+  {11, &_InpEdgS[438], 0, 0, "tex"},
+  {6, &_InpEdgS[444], 0, 0, "odin"},
+  {6, &_InpEdgS[446], 0, 0, "odin"},
+  {11, &_InpEdgS[449], 0, 0, "tex"},
+  {6, &_InpEdgS[452], 0, 0, "odin"},
+  {6, &_InpEdgS[454], 0, 0, "odin"},
+  {3, &_InpEdgS[456], 0, 0, "."},
+  {3, &_InpEdgS[457], 0, 0, "."},
+  {11, &_InpEdgS[458], &_PrmTypLstS[198], 0, "tex"},
+  {11, &_InpEdgS[461], 0, 0, "tex"},
+  {11, &_InpEdgS[466], &_PrmTypLstS[199], 0, "tex"},
+  {6, &_InpEdgS[470], 0, 0, "odin"},
+  {21, &_InpEdgS[472], 0, 0, "tex"},
+  {11, &_InpEdgS[473], &_PrmTypLstS[201], 0, "dbx"},
+  {11, &_InpEdgS[477], &_PrmTypLstS[204], 0, "run"},
+  {3, &_InpEdgS[482], 0, 0, "."},
+  {3, &_InpEdgS[483], 0, 0, "."},
+  {11, &_InpEdgS[484], &_PrmTypLstS[204], 0, "run"},
+  {11, &_InpEdgS[489], &_PrmTypLstS[204], 0, "run"},
+  {3, &_InpEdgS[494], 0, 0, "."},
+  {3, &_InpEdgS[495], 0, 0, "."},
+  {11, &_InpEdgS[496], &_PrmTypLstS[208], 0, "run"},
+  {11, &_InpEdgS[503], &_PrmTypLstS[225], 0, "regsub"},
+  {11, &_InpEdgS[512], &_PrmTypLstS[225], 0, "regsub"} };
+tp_Tool SourceTool = &_ToolS[0];
+tp_Tool StrTool = &_ToolS[1];
+tp_Tool DrvDirElmTool = &_ToolS[2];
+tp_Tool VirDirElmTool = &_ToolS[3];
+tp_Tool PntrHoTool = &_ToolS[4];
+tp_Tool PntrElmTool = &_ToolS[5];
+tp_Tool InternalPntrTool = &_ToolS[6];
+tp_Tool TextDefTool = &_ToolS[7];
+int num_InpEdgS = 521;
+tps_InpEdg _InpEdgS [521] = {
+  {&_InpSpcS[1], 1, 1,0},
+  {&_InpSpcS[2], 1, 1,0},
+  {&_InpSpcS[5], 4, 1,0},
+  {&_InpSpcS[3], 3, 1,&_InpEdgS[4]},
+  {&_InpSpcS[6], 3, 1,0},
+  {&_InpSpcS[7], 1, 1,&_InpEdgS[6]},
+  {&_InpSpcS[8], 6, 0,0},
+  {&_InpSpcS[9], 1, 1,0},
+  {&_InpSpcS[10], 1, 1,0},
+  {&_InpSpcS[11], 4, 1,0},
+  {&_InpSpcS[12], 2, 1,&_InpEdgS[11]},
+  {&_InpSpcS[13], 2, 1,&_InpEdgS[12]},
+  {&_InpSpcS[14], 6, 1,0},
+  {&_InpSpcS[15], 2, 1,&_InpEdgS[14]},
+  {&_InpSpcS[16], 6, 1,0},
+  {&_InpSpcS[17], 1, 0,0},
+  {&_InpSpcS[18], 1, 0,0},
+  {&_InpSpcS[19], 1, 1,0},
+  {&_InpSpcS[20], 2, 1,&_InpEdgS[19]},
+  {&_InpSpcS[21], 2, 1,0},
+  {&_InpSpcS[22], 3, 1,0},
+  {&_InpSpcS[23], 1, 1,0},
+  {&_InpSpcS[24], 2, 1,0},
+  {&_InpSpcS[25], 2, 1,0},
+  {&_InpSpcS[26], 4, 1,0},
+  {&_InpSpcS[27], 3, 1,0},
+  {&_InpSpcS[28], 4, 1,0},
+  {&_InpSpcS[29], 4, 1,0},
+  {&_InpSpcS[30], 4, 1,0},
+  {&_InpSpcS[31], 2, 1,0},
+  {&_InpSpcS[32], 4, 1,0},
+  {&_InpSpcS[33], 3, 1,0},
+  {&_InpSpcS[34], 4, 1,0},
+  {&_InpSpcS[35], 3, 1,0},
+  {&_InpSpcS[36], 2, 1,0},
+  {&_InpSpcS[37], 1, 1,0},
+  {&_InpSpcS[38], 1, 1,0},
+  {&_InpSpcS[39], 1, 1,0},
+  {&_InpSpcS[40], 2, 1,0},
+  {&_InpSpcS[41], 3, 1,&_InpEdgS[40]},
+  {&_InpSpcS[42], 2, 1,0},
+  {&_InpSpcS[43], 2, 1,&_InpEdgS[42]},
+  {&_InpSpcS[0], 1, 0,0},
+  {&_InpSpcS[44], 3, 1,0},
+  {&_InpSpcS[45], 3, 1,0},
+  {&_InpSpcS[46], 4, 1,0},
+  {&_InpSpcS[47], 4, 1,&_InpEdgS[47]},
+  {&_InpSpcS[48], 2, 1,0},
+  {&_InpSpcS[49], 2, 1,&_InpEdgS[49]},
+  {&_InpSpcS[50], 2, 1,&_InpEdgS[50]},
+  {&_InpSpcS[51], 2, 1,&_InpEdgS[51]},
+  {&_InpSpcS[52], 2, 1,&_InpEdgS[52]},
+  {&_InpSpcS[53], 2, 1,&_InpEdgS[53]},
+  {&_InpSpcS[54], 2, 1,0},
+  {&_InpSpcS[55], 2, 1,&_InpEdgS[55]},
+  {&_InpSpcS[56], 2, 1,&_InpEdgS[56]},
+  {&_InpSpcS[57], 2, 1,&_InpEdgS[57]},
+  {&_InpSpcS[58], 2, 1,&_InpEdgS[58]},
+  {&_InpSpcS[59], 2, 1,&_InpEdgS[59]},
+  {&_InpSpcS[60], 2, 1,0},
+  {&_InpSpcS[61], 2, 1,&_InpEdgS[61]},
+  {&_InpSpcS[62], 2, 1,&_InpEdgS[62]},
+  {&_InpSpcS[63], 2, 1,&_InpEdgS[63]},
+  {&_InpSpcS[64], 2, 1,0},
+  {&_InpSpcS[65], 2, 1,&_InpEdgS[65]},
+  {&_InpSpcS[66], 2, 1,&_InpEdgS[66]},
+  {&_InpSpcS[67], 2, 1,&_InpEdgS[67]},
+  {&_InpSpcS[68], 2, 1,0},
+  {&_InpSpcS[69], 2, 1,&_InpEdgS[69]},
+  {&_InpSpcS[70], 2, 1,&_InpEdgS[70]},
+  {&_InpSpcS[72], 2, 1,&_InpEdgS[71]},
+  {&_InpSpcS[73], 2, 0,&_InpEdgS[72]},
+  {&_InpSpcS[74], 2, 0,0},
+  {&_InpSpcS[75], 2, 1,&_InpEdgS[74]},
+  {&_InpSpcS[76], 2, 1,&_InpEdgS[75]},
+  {&_InpSpcS[79], 2, 1,0},
+  {&_InpSpcS[81], 2, 1,&_InpEdgS[77]},
+  {&_InpSpcS[82], 2, 1,&_InpEdgS[79]},
+  {&_InpSpcS[87], 4, 1,0},
+  {&_InpSpcS[84], 2, 1,0},
+  {&_InpSpcS[89], 3, 1,0},
+  {&_InpSpcS[91], 1, 1,0},
+  {&_InpSpcS[94], 4, 1,0},
+  {&_InpSpcS[92], 3, 1,0},
+  {&_InpSpcS[95], 2, 1,&_InpEdgS[86]},
+  {&_InpSpcS[98], 4, 1,0},
+  {&_InpSpcS[96], 2, 1,&_InpEdgS[88]},
+  {&_InpSpcS[102], 4, 1,0},
+  {&_InpSpcS[100], 2, 1,0},
+  {&_InpSpcS[104], 2, 1,&_InpEdgS[90]},
+  {&_InpSpcS[105], 2, 1,&_InpEdgS[91]},
+  {&_InpSpcS[107], 2, 0,&_InpEdgS[92]},
+  {&_InpSpcS[109], 2, 0,0},
+  {&_InpSpcS[110], 1, 0,0},
+  {&_InpSpcS[111], 1, 0,0},
+  {&_InpSpcS[112], 2, 1,&_InpEdgS[96]},
+  {&_InpSpcS[113], 2, 1,&_InpEdgS[97]},
+  {&_InpSpcS[114], 2, 1,&_InpEdgS[98]},
+  {&_InpSpcS[115], 6, 0,&_InpEdgS[99]},
+  {&_InpSpcS[117], 2, 0,&_InpEdgS[100]},
+  {&_InpSpcS[0], 1, 0,0},
+  {&_InpSpcS[118], 3, 1,0},
+  {&_InpSpcS[120], 3, 1,0},
+  {&_InpSpcS[121], 1, 1,0},
+  {&_InpSpcS[122], 2, 1,&_InpEdgS[105]},
+  {&_InpSpcS[123], 2, 1,&_InpEdgS[106]},
+  {&_InpSpcS[124], 4, 1,&_InpEdgS[107]},
+  {&_InpSpcS[126], 4, 1,&_InpEdgS[108]},
+  {&_InpSpcS[127], 2, 1,&_InpEdgS[109]},
+  {&_InpSpcS[128], 2, 1,&_InpEdgS[110]},
+  {&_InpSpcS[129], 2, 0,&_InpEdgS[111]},
+  {&_InpSpcS[130], 2, 0,0},
+  {&_InpSpcS[131], 3, 1,0},
+  {&_InpSpcS[135], 4, 1,0},
+  {&_InpSpcS[133], 3, 1,&_InpEdgS[115]},
+  {&_InpSpcS[136], 3, 1,0},
+  {&_InpSpcS[137], 2, 1,&_InpEdgS[117]},
+  {&_InpSpcS[138], 2, 1,&_InpEdgS[118]},
+  {&_InpSpcS[139], 4, 1,&_InpEdgS[119]},
+  {&_InpSpcS[141], 2, 1,&_InpEdgS[120]},
+  {&_InpSpcS[142], 4, 1,&_InpEdgS[121]},
+  {&_InpSpcS[143], 2, 1,&_InpEdgS[122]},
+  {&_InpSpcS[144], 2, 1,&_InpEdgS[123]},
+  {&_InpSpcS[145], 2, 1,&_InpEdgS[124]},
+  {&_InpSpcS[146], 2, 1,&_InpEdgS[125]},
+  {&_InpSpcS[147], 2, 1,&_InpEdgS[126]},
+  {&_InpSpcS[148], 2, 1,&_InpEdgS[127]},
+  {&_InpSpcS[149], 2, 1,&_InpEdgS[129]},
+  {&_InpSpcS[155], 4, 1,0},
+  {&_InpSpcS[150], 2, 0,&_InpEdgS[130]},
+  {&_InpSpcS[156], 2, 0,&_InpEdgS[131]},
+  {&_InpSpcS[157], 2, 0,&_InpEdgS[132]},
+  {&_InpSpcS[158], 2, 0,&_InpEdgS[133]},
+  {&_InpSpcS[159], 2, 0,0},
+  {&_InpSpcS[160], 2, 1,&_InpEdgS[135]},
+  {&_InpSpcS[161], 2, 1,&_InpEdgS[136]},
+  {&_InpSpcS[163], 2, 1,&_InpEdgS[137]},
+  {&_InpSpcS[164], 4, 1,&_InpEdgS[138]},
+  {&_InpSpcS[165], 2, 1,&_InpEdgS[139]},
+  {&_InpSpcS[166], 2, 1,&_InpEdgS[140]},
+  {&_InpSpcS[167], 2, 1,&_InpEdgS[141]},
+  {&_InpSpcS[168], 2, 1,&_InpEdgS[142]},
+  {&_InpSpcS[169], 2, 1,&_InpEdgS[143]},
+  {&_InpSpcS[170], 2, 1,&_InpEdgS[144]},
+  {&_InpSpcS[171], 2, 1,&_InpEdgS[145]},
+  {&_InpSpcS[172], 2, 0,&_InpEdgS[146]},
+  {&_InpSpcS[174], 2, 0,&_InpEdgS[147]},
+  {&_InpSpcS[175], 4, 0,&_InpEdgS[148]},
+  {&_InpSpcS[176], 2, 0,&_InpEdgS[149]},
+  {&_InpSpcS[177], 2, 0,&_InpEdgS[150]},
+  {&_InpSpcS[178], 2, 0,&_InpEdgS[151]},
+  {&_InpSpcS[179], 2, 0,0},
+  {&_InpSpcS[180], 2, 1,&_InpEdgS[153]},
+  {&_InpSpcS[181], 2, 1,0},
+  {&_InpSpcS[182], 2, 1,&_InpEdgS[155]},
+  {&_InpSpcS[183], 2, 1,&_InpEdgS[156]},
+  {&_InpSpcS[184], 4, 1,&_InpEdgS[157]},
+  {&_InpSpcS[186], 2, 1,&_InpEdgS[158]},
+  {&_InpSpcS[187], 2, 1,0},
+  {&_InpSpcS[188], 2, 1,&_InpEdgS[160]},
+  {&_InpSpcS[189], 2, 1,&_InpEdgS[161]},
+  {&_InpSpcS[190], 2, 1,&_InpEdgS[162]},
+  {&_InpSpcS[191], 4, 1,&_InpEdgS[163]},
+  {&_InpSpcS[193], 2, 1,&_InpEdgS[164]},
+  {&_InpSpcS[194], 2, 1,&_InpEdgS[165]},
+  {&_InpSpcS[195], 2, 0,&_InpEdgS[166]},
+  {&_InpSpcS[200], 2, 0,&_InpEdgS[167]},
+  {&_InpSpcS[201], 2, 0,0},
+  {&_InpSpcS[202], 2, 1,&_InpEdgS[169]},
+  {&_InpSpcS[203], 2, 1,&_InpEdgS[170]},
+  {&_InpSpcS[204], 2, 1,&_InpEdgS[171]},
+  {&_InpSpcS[205], 4, 1,&_InpEdgS[172]},
+  {&_InpSpcS[207], 2, 1,&_InpEdgS[173]},
+  {&_InpSpcS[208], 2, 1,&_InpEdgS[174]},
+  {&_InpSpcS[209], 2, 0,&_InpEdgS[175]},
+  {&_InpSpcS[214], 2, 0,&_InpEdgS[176]},
+  {&_InpSpcS[215], 2, 0,0},
+  {&_InpSpcS[216], 3, 1,0},
+  {&_InpSpcS[217], 1, 1,0},
+  {&_InpSpcS[218], 2, 1,&_InpEdgS[180]},
+  {&_InpSpcS[219], 2, 1,&_InpEdgS[181]},
+  {&_InpSpcS[220], 4, 1,&_InpEdgS[182]},
+  {&_InpSpcS[222], 4, 1,&_InpEdgS[183]},
+  {&_InpSpcS[223], 2, 1,&_InpEdgS[184]},
+  {&_InpSpcS[224], 2, 1,&_InpEdgS[185]},
+  {&_InpSpcS[225], 2, 0,&_InpEdgS[186]},
+  {&_InpSpcS[226], 2, 0,0},
+  {&_InpSpcS[227], 3, 1,0},
+  {&_InpSpcS[231], 4, 1,0},
+  {&_InpSpcS[229], 3, 1,&_InpEdgS[190]},
+  {&_InpSpcS[232], 3, 1,0},
+  {&_InpSpcS[233], 2, 1,&_InpEdgS[192]},
+  {&_InpSpcS[234], 2, 1,&_InpEdgS[193]},
+  {&_InpSpcS[235], 2, 1,&_InpEdgS[194]},
+  {&_InpSpcS[237], 4, 1,&_InpEdgS[195]},
+  {&_InpSpcS[239], 2, 1,&_InpEdgS[196]},
+  {&_InpSpcS[240], 2, 1,&_InpEdgS[197]},
+  {&_InpSpcS[241], 2, 1,&_InpEdgS[198]},
+  {&_InpSpcS[242], 2, 1,&_InpEdgS[199]},
+  {&_InpSpcS[243], 2, 1,&_InpEdgS[200]},
+  {&_InpSpcS[244], 2, 1,&_InpEdgS[201]},
+  {&_InpSpcS[245], 2, 1,&_InpEdgS[202]},
+  {&_InpSpcS[246], 2, 1,&_InpEdgS[204]},
+  {&_InpSpcS[252], 4, 1,0},
+  {&_InpSpcS[247], 2, 0,&_InpEdgS[205]},
+  {&_InpSpcS[253], 2, 0,&_InpEdgS[206]},
+  {&_InpSpcS[254], 2, 0,&_InpEdgS[207]},
+  {&_InpSpcS[255], 2, 0,&_InpEdgS[208]},
+  {&_InpSpcS[256], 2, 0,&_InpEdgS[209]},
+  {&_InpSpcS[257], 2, 0,&_InpEdgS[210]},
+  {&_InpSpcS[258], 2, 0,0},
+  {&_InpSpcS[259], 2, 1,&_InpEdgS[212]},
+  {&_InpSpcS[260], 2, 1,&_InpEdgS[213]},
+  {&_InpSpcS[262], 2, 1,&_InpEdgS[214]},
+  {&_InpSpcS[263], 2, 1,&_InpEdgS[215]},
+  {&_InpSpcS[265], 2, 1,&_InpEdgS[216]},
+  {&_InpSpcS[266], 2, 1,&_InpEdgS[217]},
+  {&_InpSpcS[267], 2, 1,&_InpEdgS[218]},
+  {&_InpSpcS[268], 2, 1,&_InpEdgS[219]},
+  {&_InpSpcS[269], 2, 1,&_InpEdgS[220]},
+  {&_InpSpcS[270], 2, 1,&_InpEdgS[221]},
+  {&_InpSpcS[271], 2, 1,&_InpEdgS[222]},
+  {&_InpSpcS[272], 2, 1,&_InpEdgS[223]},
+  {&_InpSpcS[273], 2, 1,&_InpEdgS[224]},
+  {&_InpSpcS[274], 2, 0,&_InpEdgS[225]},
+  {&_InpSpcS[276], 2, 0,&_InpEdgS[226]},
+  {&_InpSpcS[277], 4, 0,&_InpEdgS[227]},
+  {&_InpSpcS[278], 2, 0,&_InpEdgS[228]},
+  {&_InpSpcS[279], 2, 0,&_InpEdgS[229]},
+  {&_InpSpcS[280], 2, 0,&_InpEdgS[230]},
+  {&_InpSpcS[281], 2, 0,&_InpEdgS[231]},
+  {&_InpSpcS[282], 2, 0,&_InpEdgS[232]},
+  {&_InpSpcS[283], 2, 0,&_InpEdgS[233]},
+  {&_InpSpcS[284], 2, 0,0},
+  {&_InpSpcS[285], 1, 1,0},
+  {&_InpSpcS[286], 2, 1,&_InpEdgS[236]},
+  {&_InpSpcS[287], 2, 1,&_InpEdgS[238]},
+  {&_InpSpcS[291], 4, 1,0},
+  {&_InpSpcS[289], 2, 1,&_InpEdgS[239]},
+  {&_InpSpcS[293], 4, 1,&_InpEdgS[240]},
+  {&_InpSpcS[294], 2, 1,&_InpEdgS[241]},
+  {&_InpSpcS[295], 4, 1,&_InpEdgS[242]},
+  {&_InpSpcS[296], 2, 0,&_InpEdgS[243]},
+  {&_InpSpcS[297], 2, 0,&_InpEdgS[244]},
+  {&_InpSpcS[299], 2, 0,&_InpEdgS[245]},
+  {&_InpSpcS[0], 1, 0,0},
+  {&_InpSpcS[300], 2, 1,&_InpEdgS[247]},
+  {&_InpSpcS[301], 4, 1,&_InpEdgS[248]},
+  {&_InpSpcS[302], 2, 1,&_InpEdgS[249]},
+  {&_InpSpcS[306], 2, 1,&_InpEdgS[250]},
+  {&_InpSpcS[307], 2, 0,&_InpEdgS[251]},
+  {&_InpSpcS[310], 2, 0,&_InpEdgS[252]},
+  {&_InpSpcS[311], 2, 0,&_InpEdgS[253]},
+  {&_InpSpcS[312], 2, 0,0},
+  {&_InpSpcS[313], 3, 1,&_InpEdgS[255]},
+  {&_InpSpcS[314], 3, 1,0},
+  {&_InpSpcS[315], 2, 1,&_InpEdgS[257]},
+  {&_InpSpcS[316], 2, 1,&_InpEdgS[258]},
+  {&_InpSpcS[317], 2, 1,&_InpEdgS[259]},
+  {&_InpSpcS[318], 2, 1,&_InpEdgS[260]},
+  {&_InpSpcS[319], 2, 1,&_InpEdgS[261]},
+  {&_InpSpcS[320], 2, 1,&_InpEdgS[262]},
+  {&_InpSpcS[321], 2, 1,0},
+  {&_InpSpcS[322], 2, 1,&_InpEdgS[264]},
+  {&_InpSpcS[323], 2, 1,&_InpEdgS[265]},
+  {&_InpSpcS[324], 2, 1,0},
+  {&_InpSpcS[325], 1, 0,0},
+  {&_InpSpcS[326], 1, 0,0},
+  {&_InpSpcS[327], 1, 0,0},
+  {&_InpSpcS[328], 2, 1,&_InpEdgS[270]},
+  {&_InpSpcS[329], 2, 1,&_InpEdgS[271]},
+  {&_InpSpcS[330], 2, 1,&_InpEdgS[272]},
+  {&_InpSpcS[331], 2, 1,&_InpEdgS[273]},
+  {&_InpSpcS[332], 2, 1,&_InpEdgS[274]},
+  {&_InpSpcS[333], 2, 1,&_InpEdgS[275]},
+  {&_InpSpcS[334], 2, 1,&_InpEdgS[276]},
+  {&_InpSpcS[335], 2, 1,&_InpEdgS[277]},
+  {&_InpSpcS[336], 2, 0,&_InpEdgS[278]},
+  {&_InpSpcS[337], 2, 0,&_InpEdgS[279]},
+  {&_InpSpcS[338], 2, 0,0},
+  {&_InpSpcS[339], 1, 0,0},
+  {&_InpSpcS[340], 1, 0,0},
+  {&_InpSpcS[341], 1, 0,0},
+  {&_InpSpcS[342], 1, 0,0},
+  {&_InpSpcS[343], 2, 1,&_InpEdgS[285]},
+  {&_InpSpcS[344], 2, 1,&_InpEdgS[286]},
+  {&_InpSpcS[345], 2, 1,&_InpEdgS[287]},
+  {&_InpSpcS[346], 2, 1,0},
+  {&_InpSpcS[347], 1, 0,0},
+  {&_InpSpcS[348], 1, 0,0},
+  {&_InpSpcS[349], 1, 0,0},
+  {&_InpSpcS[350], 1, 0,0},
+  {&_InpSpcS[351], 2, 1,&_InpEdgS[293]},
+  {&_InpSpcS[352], 2, 1,&_InpEdgS[294]},
+  {&_InpSpcS[353], 4, 1,&_InpEdgS[295]},
+  {&_InpSpcS[356], 2, 1,&_InpEdgS[296]},
+  {&_InpSpcS[357], 2, 0,0},
+  {&_InpSpcS[365], 2, 1,&_InpEdgS[298]},
+  {&_InpSpcS[366], 2, 1,&_InpEdgS[299]},
+  {&_InpSpcS[367], 4, 1,&_InpEdgS[300]},
+  {&_InpSpcS[369], 4, 1,&_InpEdgS[301]},
+  {&_InpSpcS[370], 2, 1,&_InpEdgS[302]},
+  {&_InpSpcS[371], 2, 1,&_InpEdgS[303]},
+  {&_InpSpcS[372], 2, 0,&_InpEdgS[304]},
+  {&_InpSpcS[373], 2, 0,0},
+  {&_InpSpcS[374], 3, 1,0},
+  {&_InpSpcS[378], 4, 1,0},
+  {&_InpSpcS[376], 3, 1,&_InpEdgS[308]},
+  {&_InpSpcS[379], 3, 1,0},
+  {&_InpSpcS[380], 1, 0,0},
+  {&_InpSpcS[381], 1, 0,0},
+  {&_InpSpcS[382], 1, 0,0},
+  {&_InpSpcS[383], 1, 0,0},
+  {&_InpSpcS[384], 1, 0,0},
+  {&_InpSpcS[385], 2, 1,&_InpEdgS[315]},
+  {&_InpSpcS[386], 2, 1,&_InpEdgS[316]},
+  {&_InpSpcS[387], 4, 1,&_InpEdgS[317]},
+  {&_InpSpcS[389], 2, 1,&_InpEdgS[318]},
+  {&_InpSpcS[390], 2, 1,&_InpEdgS[320]},
+  {&_InpSpcS[396], 4, 1,0},
+  {&_InpSpcS[391], 2, 0,&_InpEdgS[321]},
+  {&_InpSpcS[397], 2, 0,&_InpEdgS[322]},
+  {&_InpSpcS[398], 2, 0,&_InpEdgS[323]},
+  {&_InpSpcS[399], 2, 0,0},
+  {&_InpSpcS[400], 3, 1,&_InpEdgS[325]},
+  {&_InpSpcS[401], 3, 1,&_InpEdgS[326]},
+  {&_InpSpcS[402], 3, 1,&_InpEdgS[327]},
+  {&_InpSpcS[403], 3, 1,0},
+  {&_InpSpcS[404], 3, 1,0},
+  {&_InpSpcS[408], 2, 1,&_InpEdgS[330]},
+  {&_InpSpcS[409], 4, 1,&_InpEdgS[331]},
+  {&_InpSpcS[410], 2, 1,&_InpEdgS[332]},
+  {&_InpSpcS[412], 2, 1,0},
+  {&_InpSpcS[414], 2, 1,&_InpEdgS[334]},
+  {&_InpSpcS[415], 2, 1,&_InpEdgS[335]},
+  {&_InpSpcS[416], 2, 1,&_InpEdgS[336]},
+  {&_InpSpcS[418], 2, 1,&_InpEdgS[337]},
+  {&_InpSpcS[419], 2, 0,0},
+  {&_InpSpcS[420], 1, 0,0},
+  {&_InpSpcS[421], 1, 0,0},
+  {&_InpSpcS[422], 2, 1,&_InpEdgS[341]},
+  {&_InpSpcS[423], 2, 1,&_InpEdgS[342]},
+  {&_InpSpcS[424], 4, 1,&_InpEdgS[343]},
+  {&_InpSpcS[426], 2, 1,&_InpEdgS[344]},
+  {&_InpSpcS[427], 2, 1,&_InpEdgS[345]},
+  {&_InpSpcS[428], 2, 1,&_InpEdgS[346]},
+  {&_InpSpcS[429], 2, 1,&_InpEdgS[347]},
+  {&_InpSpcS[430], 2, 0,&_InpEdgS[348]},
+  {&_InpSpcS[435], 2, 0,&_InpEdgS[349]},
+  {&_InpSpcS[436], 2, 0,0},
+  {&_InpSpcS[437], 2, 1,&_InpEdgS[352]},
+  {&_InpSpcS[440], 4, 1,0},
+  {&_InpSpcS[438], 2, 1,&_InpEdgS[354]},
+  {&_InpSpcS[444], 4, 1,0},
+  {&_InpSpcS[442], 2, 1,&_InpEdgS[355]},
+  {&_InpSpcS[446], 2, 1,&_InpEdgS[356]},
+  {&_InpSpcS[449], 2, 1,&_InpEdgS[357]},
+  {&_InpSpcS[451], 2, 1,&_InpEdgS[358]},
+  {&_InpSpcS[452], 2, 1,&_InpEdgS[359]},
+  {&_InpSpcS[453], 2, 1,&_InpEdgS[360]},
+  {&_InpSpcS[454], 2, 0,&_InpEdgS[361]},
+  {&_InpSpcS[456], 2, 0,&_InpEdgS[362]},
+  {&_InpSpcS[458], 2, 0,&_InpEdgS[363]},
+  {&_InpSpcS[460], 2, 0,&_InpEdgS[364]},
+  {&_InpSpcS[461], 2, 0,0},
+  {&_InpSpcS[462], 1, 1,0},
+  {&_InpSpcS[463], 2, 1,&_InpEdgS[367]},
+  {&_InpSpcS[464], 2, 1,0},
+  {&_InpSpcS[466], 2, 1,&_InpEdgS[369]},
+  {&_InpSpcS[467], 2, 1,0},
+  {&_InpSpcS[468], 2, 1,&_InpEdgS[371]},
+  {&_InpSpcS[469], 6, 1,&_InpEdgS[372]},
+  {&_InpSpcS[470], 2, 1,0},
+  {&_InpSpcS[471], 1, 1,0},
+  {&_InpSpcS[472], 2, 1,&_InpEdgS[375]},
+  {&_InpSpcS[473], 2, 1,&_InpEdgS[376]},
+  {&_InpSpcS[474], 2, 1,0},
+  {&_InpSpcS[475], 2, 1,&_InpEdgS[378]},
+  {&_InpSpcS[476], 2, 1,&_InpEdgS[379]},
+  {&_InpSpcS[477], 2, 1,&_InpEdgS[380]},
+  {&_InpSpcS[478], 2, 1,0},
+  {&_InpSpcS[479], 2, 1,&_InpEdgS[382]},
+  {&_InpSpcS[480], 2, 1,&_InpEdgS[383]},
+  {&_InpSpcS[481], 4, 1,0},
+  {&_InpSpcS[482], 1, 1,0},
+  {&_InpSpcS[485], 4, 1,0},
+  {&_InpSpcS[483], 3, 1,&_InpEdgS[387]},
+  {&_InpSpcS[486], 3, 1,0},
+  {&_InpSpcS[487], 2, 1,&_InpEdgS[389]},
+  {&_InpSpcS[488], 2, 1,&_InpEdgS[390]},
+  {&_InpSpcS[489], 2, 1,0},
+  {&_InpSpcS[490], 2, 1,&_InpEdgS[392]},
+  {&_InpSpcS[491], 2, 1,&_InpEdgS[393]},
+  {&_InpSpcS[492], 2, 1,0},
+  {&_InpSpcS[493], 2, 1,&_InpEdgS[395]},
+  {&_InpSpcS[494], 2, 1,0},
+  {&_InpSpcS[495], 2, 1,&_InpEdgS[397]},
+  {&_InpSpcS[496], 2, 1,&_InpEdgS[398]},
+  {&_InpSpcS[497], 4, 1,&_InpEdgS[399]},
+  {&_InpSpcS[499], 2, 1,&_InpEdgS[401]},
+  {&_InpSpcS[505], 4, 1,0},
+  {&_InpSpcS[500], 2, 0,0},
+  {&_InpSpcS[506], 2, 1,&_InpEdgS[403]},
+  {&_InpSpcS[507], 2, 1,&_InpEdgS[404]},
+  {&_InpSpcS[508], 2, 1,0},
+  {&_InpSpcS[509], 1, 0,0},
+  {&_InpSpcS[510], 1, 0,0},
+  {&_InpSpcS[511], 2, 1,&_InpEdgS[408]},
+  {&_InpSpcS[512], 2, 1,&_InpEdgS[409]},
+  {&_InpSpcS[513], 2, 1,&_InpEdgS[410]},
+  {&_InpSpcS[514], 2, 0,0},
+  {&_InpSpcS[516], 2, 1,&_InpEdgS[412]},
+  {&_InpSpcS[517], 4, 1,&_InpEdgS[413]},
+  {&_InpSpcS[519], 4, 1,&_InpEdgS[414]},
+  {&_InpSpcS[520], 2, 1,0},
+  {&_InpSpcS[521], 3, 1,&_InpEdgS[418]},
+  {&_InpSpcS[524], 4, 1,0},
+  {&_InpSpcS[526], 4, 1,0},
+  {&_InpSpcS[522], 3, 1,0},
+  {&_InpSpcS[527], 3, 1,0},
+  {&_InpSpcS[531], 2, 1,&_InpEdgS[421]},
+  {&_InpSpcS[532], 2, 1,&_InpEdgS[422]},
+  {&_InpSpcS[533], 2, 1,0},
+  {&_InpSpcS[534], 2, 1,&_InpEdgS[424]},
+  {&_InpSpcS[535], 2, 1,&_InpEdgS[425]},
+  {&_InpSpcS[537], 2, 1,0},
+  {&_InpSpcS[538], 3, 1,0},
+  {&_InpSpcS[540], 2, 1,&_InpEdgS[428]},
+  {&_InpSpcS[541], 2, 1,&_InpEdgS[429]},
+  {&_InpSpcS[546], 2, 1,&_InpEdgS[430]},
+  {&_InpSpcS[547], 2, 1,&_InpEdgS[431]},
+  {&_InpSpcS[548], 2, 1,0},
+  {&_InpSpcS[549], 1, 0,0},
+  {&_InpSpcS[550], 1, 0,0},
+  {&_InpSpcS[551], 1, 0,0},
+  {&_InpSpcS[552], 1, 0,0},
+  {&_InpSpcS[553], 1, 0,0},
+  {&_InpSpcS[554], 1, 0,0},
+  {&_InpSpcS[555], 2, 1,&_InpEdgS[439]},
+  {&_InpSpcS[556], 2, 1,&_InpEdgS[440]},
+  {&_InpSpcS[557], 2, 1,&_InpEdgS[441]},
+  {&_InpSpcS[558], 2, 1,&_InpEdgS[442]},
+  {&_InpSpcS[559], 6, 1,&_InpEdgS[443]},
+  {&_InpSpcS[562], 2, 0,&_InpEdgS[445]},
+  {&_InpSpcS[566], 4, 1,0},
+  {&_InpSpcS[564], 2, 0,&_InpEdgS[447]},
+  {&_InpSpcS[569], 4, 1,0},
+  {&_InpSpcS[567], 2, 0,&_InpEdgS[448]},
+  {&_InpSpcS[570], 6, 0,0},
+  {&_InpSpcS[573], 2, 1,&_InpEdgS[450]},
+  {&_InpSpcS[574], 6, 1,&_InpEdgS[451]},
+  {&_InpSpcS[575], 2, 1,&_InpEdgS[453]},
+  {&_InpSpcS[578], 4, 1,0},
+  {&_InpSpcS[576], 2, 0,&_InpEdgS[455]},
+  {&_InpSpcS[581], 4, 1,0},
+  {&_InpSpcS[579], 2, 0,0},
+  {&_InpSpcS[582], 1, 0,0},
+  {&_InpSpcS[583], 1, 0,0},
+  {&_InpSpcS[584], 2, 1,&_InpEdgS[459]},
+  {&_InpSpcS[585], 6, 1,&_InpEdgS[460]},
+  {&_InpSpcS[586], 2, 1,0},
+  {&_InpSpcS[587], 2, 1,&_InpEdgS[462]},
+  {&_InpSpcS[588], 2, 1,&_InpEdgS[463]},
+  {&_InpSpcS[589], 6, 1,&_InpEdgS[464]},
+  {&_InpSpcS[590], 2, 1,&_InpEdgS[465]},
+  {&_InpSpcS[591], 2, 1,0},
+  {&_InpSpcS[592], 2, 1,&_InpEdgS[467]},
+  {&_InpSpcS[593], 2, 1,&_InpEdgS[468]},
+  {&_InpSpcS[594], 2, 1,&_InpEdgS[469]},
+  {&_InpSpcS[595], 2, 1,&_InpEdgS[471]},
+  {&_InpSpcS[598], 4, 1,0},
+  {&_InpSpcS[596], 2, 0,0},
+  {&_InpSpcS[599], 3, 1,0},
+  {&_InpSpcS[602], 2, 1,&_InpEdgS[474]},
+  {&_InpSpcS[603], 2, 1,&_InpEdgS[475]},
+  {&_InpSpcS[604], 2, 1,&_InpEdgS[476]},
+  {&_InpSpcS[605], 2, 1,0},
+  {&_InpSpcS[606], 2, 1,&_InpEdgS[478]},
+  {&_InpSpcS[607], 2, 1,&_InpEdgS[479]},
+  {&_InpSpcS[608], 2, 1,&_InpEdgS[480]},
+  {&_InpSpcS[610], 6, 0,&_InpEdgS[481]},
+  {&_InpSpcS[611], 2, 0,0},
+  {&_InpSpcS[612], 1, 0,0},
+  {&_InpSpcS[613], 1, 0,0},
+  {&_InpSpcS[614], 2, 1,&_InpEdgS[485]},
+  {&_InpSpcS[615], 2, 1,&_InpEdgS[486]},
+  {&_InpSpcS[616], 2, 1,&_InpEdgS[487]},
+  {&_InpSpcS[618], 2, 0,&_InpEdgS[488]},
+  {&_InpSpcS[619], 2, 0,0},
+  {&_InpSpcS[620], 2, 1,&_InpEdgS[490]},
+  {&_InpSpcS[621], 2, 1,&_InpEdgS[491]},
+  {&_InpSpcS[622], 2, 1,&_InpEdgS[492]},
+  {&_InpSpcS[624], 6, 0,&_InpEdgS[493]},
+  {&_InpSpcS[625], 2, 0,0},
+  {&_InpSpcS[626], 1, 0,0},
+  {&_InpSpcS[627], 1, 0,0},
+  {&_InpSpcS[628], 2, 1,&_InpEdgS[497]},
+  {&_InpSpcS[629], 2, 1,&_InpEdgS[498]},
+  {&_InpSpcS[630], 2, 1,&_InpEdgS[499]},
+  {&_InpSpcS[632], 2, 1,&_InpEdgS[500]},
+  {&_InpSpcS[634], 2, 0,&_InpEdgS[501]},
+  {&_InpSpcS[635], 2, 0,&_InpEdgS[502]},
+  {&_InpSpcS[636], 2, 0,0},
+  {&_InpSpcS[637], 2, 1,&_InpEdgS[504]},
+  {&_InpSpcS[638], 2, 1,&_InpEdgS[505]},
+  {&_InpSpcS[639], 2, 1,&_InpEdgS[506]},
+  {&_InpSpcS[640], 2, 1,&_InpEdgS[507]},
+  {&_InpSpcS[641], 2, 1,&_InpEdgS[508]},
+  {&_InpSpcS[642], 2, 1,&_InpEdgS[509]},
+  {&_InpSpcS[643], 2, 1,&_InpEdgS[510]},
+  {&_InpSpcS[644], 2, 1,&_InpEdgS[511]},
+  {&_InpSpcS[645], 2, 1,0},
+  {&_InpSpcS[646], 2, 1,&_InpEdgS[513]},
+  {&_InpSpcS[647], 2, 1,&_InpEdgS[514]},
+  {&_InpSpcS[648], 2, 1,&_InpEdgS[515]},
+  {&_InpSpcS[649], 2, 1,&_InpEdgS[516]},
+  {&_InpSpcS[650], 2, 1,&_InpEdgS[517]},
+  {&_InpSpcS[651], 2, 1,&_InpEdgS[518]},
+  {&_InpSpcS[652], 2, 1,&_InpEdgS[519]},
+  {&_InpSpcS[653], 2, 1,&_InpEdgS[520]},
+  {&_InpSpcS[654], 2, 1,0} };
+int num_MemEdgS = 36;
+tps_MemEdg _MemEdgS [36] = {
+  {&_FilTypS[66], &_MemEdgS[1]},
+  {&_FilTypS[67], 0},
+  {&_FilTypS[130], &_MemEdgS[3]},
+  {&_FilTypS[131], 0},
+  {&_FilTypS[194], &_MemEdgS[5]},
+  {&_FilTypS[195], &_MemEdgS[6]},
+  {&_FilTypS[196], 0},
+  {&_FilTypS[202], &_MemEdgS[8]},
+  {&_FilTypS[203], &_MemEdgS[9]},
+  {&_FilTypS[204], &_MemEdgS[10]},
+  {&_FilTypS[205], 0},
+  {&_FilTypS[211], &_MemEdgS[12]},
+  {&_FilTypS[212], &_MemEdgS[13]},
+  {&_FilTypS[213], &_MemEdgS[14]},
+  {&_FilTypS[214], 0},
+  {&_FilTypS[233], &_MemEdgS[16]},
+  {&_FilTypS[234], &_MemEdgS[17]},
+  {&_FilTypS[235], &_MemEdgS[18]},
+  {&_FilTypS[236], &_MemEdgS[19]},
+  {&_FilTypS[237], 0},
+  {&_FilTypS[248], &_MemEdgS[21]},
+  {&_FilTypS[249], 0},
+  {&_FilTypS[308], &_MemEdgS[23]},
+  {&_FilTypS[309], 0},
+  {&_FilTypS[325], &_MemEdgS[25]},
+  {&_FilTypS[326], &_MemEdgS[26]},
+  {&_FilTypS[327], &_MemEdgS[27]},
+  {&_FilTypS[328], &_MemEdgS[28]},
+  {&_FilTypS[329], &_MemEdgS[29]},
+  {&_FilTypS[330], 0},
+  {&_FilTypS[339], &_MemEdgS[31]},
+  {&_FilTypS[341], 0},
+  {&_FilTypS[357], &_MemEdgS[33]},
+  {&_FilTypS[358], 0},
+  {&_FilTypS[361], &_MemEdgS[35]},
+  {&_FilTypS[362], 0} };
+int num_EqvEdgS = 192;
+tps_EqvEdg _EqvEdgS [192] = {
+  {&_FilTypS[22], 0},
+  {&_FilTypS[23], 0},
+  {&_FilTypS[24], 0},
+  {&_FilTypS[25], 0},
+  {&_FilTypS[27], 0},
+  {&_FilTypS[28], 0},
+  {&_FilTypS[29], 0},
+  {&_FilTypS[32], 0},
+  {&_FilTypS[33], 0},
+  {&_FilTypS[36], 0},
+  {&_FilTypS[37], 0},
+  {&_FilTypS[35], 0},
+  {&_FilTypS[34], 0},
+  {&_FilTypS[19], 0},
+  {&_FilTypS[38], 0},
+  {&_FilTypS[39], 0},
+  {&_FilTypS[40], 0},
+  {&_FilTypS[41], 0},
+  {&_FilTypS[42], 0},
+  {&_FilTypS[43], 0},
+  {&_FilTypS[44], 0},
+  {&_FilTypS[45], 0},
+  {&_FilTypS[46], 0},
+  {&_FilTypS[47], 0},
+  {&_FilTypS[48], 0},
+  {&_FilTypS[49], 0},
+  {&_FilTypS[50], 0},
+  {&_FilTypS[51], 0},
+  {&_FilTypS[52], 0},
+  {&_FilTypS[53], 0},
+  {&_FilTypS[54], 0},
+  {&_FilTypS[55], 0},
+  {&_FilTypS[56], 0},
+  {&_FilTypS[57], 0},
+  {&_FilTypS[58], 0},
+  {&_FilTypS[59], 0},
+  {&_FilTypS[60], 0},
+  {&_FilTypS[7], 0},
+  {&_FilTypS[97], 0},
+  {&_FilTypS[7], &_EqvEdgS[40]},
+  {&_FilTypS[98], 0},
+  {&_FilTypS[101], 0},
+  {&_FilTypS[101], 0},
+  {&_FilTypS[97], 0},
+  {&_FilTypS[96], 0},
+  {&_FilTypS[100], 0},
+  {&_FilTypS[93], 0},
+  {&_FilTypS[94], 0},
+  {&_FilTypS[95], 0},
+  {&_FilTypS[99], 0},
+  {&_FilTypS[116], 0},
+  {&_FilTypS[117], 0},
+  {&_FilTypS[119], 0},
+  {&_FilTypS[113], 0},
+  {&_FilTypS[118], 0},
+  {&_FilTypS[120], 0},
+  {&_FilTypS[121], 0},
+  {&_FilTypS[115], 0},
+  {&_FilTypS[117], &_EqvEdgS[59]},
+  {&_FilTypS[137], 0},
+  {&_FilTypS[116], &_EqvEdgS[61]},
+  {&_FilTypS[137], 0},
+  {&_FilTypS[8], 0},
+  {&_FilTypS[136], 0},
+  {&_FilTypS[138], 0},
+  {&_FilTypS[139], 0},
+  {&_FilTypS[140], 0},
+  {&_FilTypS[141], 0},
+  {&_FilTypS[112], 0},
+  {&_FilTypS[134], 0},
+  {&_FilTypS[142], 0},
+  {&_FilTypS[143], 0},
+  {&_FilTypS[8], 0},
+  {&_FilTypS[7], 0},
+  {&_FilTypS[156], 0},
+  {&_FilTypS[157], 0},
+  {&_FilTypS[115], 0},
+  {&_FilTypS[117], &_EqvEdgS[78]},
+  {&_FilTypS[166], 0},
+  {&_FilTypS[116], &_EqvEdgS[80]},
+  {&_FilTypS[166], 0},
+  {&_FilTypS[165], 0},
+  {&_FilTypS[167], 0},
+  {&_FilTypS[162], 0},
+  {&_FilTypS[163], 0},
+  {&_FilTypS[164], 0},
+  {&_FilTypS[112], 0},
+  {&_FilTypS[134], 0},
+  {&_FilTypS[116], 0},
+  {&_FilTypS[178], 0},
+  {&_FilTypS[180], 0},
+  {&_FilTypS[179], 0},
+  {&_FilTypS[167], 0},
+  {&_FilTypS[115], 0},
+  {&_FilTypS[112], 0},
+  {&_FilTypS[133], 0},
+  {&_FilTypS[101], 0},
+  {&_FilTypS[133], 0},
+  {&_FilTypS[191], 0},
+  {&_FilTypS[192], 0},
+  {&_FilTypS[191], 0},
+  {&_FilTypS[191], 0},
+  {&_FilTypS[101], 0},
+  {&_FilTypS[190], 0},
+  {&_FilTypS[198], 0},
+  {&_FilTypS[199], 0},
+  {&_FilTypS[200], 0},
+  {&_FilTypS[101], 0},
+  {&_FilTypS[207], 0},
+  {&_FilTypS[133], 0},
+  {&_FilTypS[208], 0},
+  {&_FilTypS[209], 0},
+  {&_FilTypS[160], 0},
+  {&_FilTypS[133], 0},
+  {&_FilTypS[133], 0},
+  {&_FilTypS[160], 0},
+  {&_FilTypS[113], 0},
+  {&_FilTypS[117], 0},
+  {&_FilTypS[217], 0},
+  {&_FilTypS[218], 0},
+  {&_FilTypS[219], 0},
+  {&_FilTypS[220], 0},
+  {&_FilTypS[221], 0},
+  {&_FilTypS[224], 0},
+  {&_FilTypS[222], 0},
+  {&_FilTypS[223], 0},
+  {&_FilTypS[226], 0},
+  {&_FilTypS[225], 0},
+  {&_FilTypS[227], 0},
+  {&_FilTypS[242], 0},
+  {&_FilTypS[244], 0},
+  {&_FilTypS[245], 0},
+  {&_FilTypS[246], 0},
+  {&_FilTypS[109], 0},
+  {&_FilTypS[253], 0},
+  {&_FilTypS[254], 0},
+  {&_FilTypS[255], 0},
+  {&_FilTypS[256], 0},
+  {&_FilTypS[257], 0},
+  {&_FilTypS[258], 0},
+  {&_FilTypS[267], 0},
+  {&_FilTypS[7], 0},
+  {&_FilTypS[268], 0},
+  {&_FilTypS[269], 0},
+  {&_FilTypS[270], 0},
+  {&_FilTypS[271], 0},
+  {&_FilTypS[272], 0},
+  {&_FilTypS[273], 0},
+  {&_FilTypS[274], 0},
+  {&_FilTypS[275], 0},
+  {&_FilTypS[26], 0},
+  {&_FilTypS[295], 0},
+  {&_FilTypS[26], 0},
+  {&_FilTypS[290], 0},
+  {&_FilTypS[305], 0},
+  {&_FilTypS[292], 0},
+  {&_FilTypS[293], 0},
+  {&_FilTypS[294], 0},
+  {&_FilTypS[296], 0},
+  {&_FilTypS[311], 0},
+  {&_FilTypS[316], 0},
+  {&_FilTypS[318], 0},
+  {&_FilTypS[295], 0},
+  {&_FilTypS[313], 0},
+  {&_FilTypS[322], 0},
+  {&_FilTypS[297], 0},
+  {&_FilTypS[298], 0},
+  {&_FilTypS[299], 0},
+  {&_FilTypS[300], 0},
+  {&_FilTypS[301], 0},
+  {&_FilTypS[302], 0},
+  {&_FilTypS[333], 0},
+  {&_FilTypS[338], 0},
+  {&_FilTypS[340], 0},
+  {&_FilTypS[303], 0},
+  {&_FilTypS[304], 0},
+  {&_FilTypS[345], 0},
+  {&_FilTypS[291], 0},
+  {&_FilTypS[347], 0},
+  {&_FilTypS[8], 0},
+  {&_FilTypS[8], 0},
+  {&_FilTypS[349], 0},
+  {&_FilTypS[350], 0},
+  {&_FilTypS[351], 0},
+  {&_FilTypS[352], 0},
+  {&_FilTypS[353], 0},
+  {&_FilTypS[354], 0},
+  {&_FilTypS[8], 0},
+  {&_FilTypS[7], 0},
+  {&_FilTypS[215], 0},
+  {&_FilTypS[364], 0},
+  {&_FilTypS[0], 0} };
+int num_CastEdgS = 172;
+tps_CastEdg _CastEdgS [172] = {
+  {&_FilTypS[1], &_CastEdgS[56]},
+  {&_FilTypS[1], 0},
+  {&_FilTypS[1], 0},
+  {&_FilTypS[1], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], &_CastEdgS[9]},
+  {&_FilTypS[5], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[9], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[4], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[5], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[5], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[5], 0},
+  {&_FilTypS[6], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[98], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[5], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[115], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[5], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[5], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[160], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[9], 0},
+  {&_FilTypS[5], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[5], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[6], 0},
+  {&_FilTypS[6], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[5], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[4], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[5], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[9], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[2], 0},
+  {&_FilTypS[3], 0},
+  {&_FilTypS[5], 0},
+  {&_FilTypS[6], 0},
+  {&_FilTypS[6], 0},
+  {&_FilTypS[9], 0},
+  {&_FilTypS[6], 0},
+  {&_FilTypS[9], 0},
+  {&_FilTypS[2], 0} };
+int num_DrvEdgS = 184;
+tps_DrvEdg _DrvEdgS [184] = {
+  {&_FilTypS[348], &_PrmTypLstS[201], 0},
+  {&_FilTypS[243], &_PrmTypLstS[163], &_DrvEdgS[0]},
+  {&_FilTypS[128], 0, 0},
+  {&_FilTypS[250], &_PrmTypLstS[366], 0},
+  {&_FilTypS[125], &_PrmTypLstS[477], &_DrvEdgS[3]},
+  {&_FilTypS[123], &_PrmTypLstS[544], 0},
+  {&_FilTypS[132], 0, 0},
+  {&_FilTypS[131], 0, 0},
+  {&_FilTypS[130], 0, &_DrvEdgS[7]},
+  {&_FilTypS[182], &_PrmTypLstS[523], 0},
+  {&_FilTypS[129], &_PrmTypLstS[18], &_DrvEdgS[9]},
+  {&_FilTypS[85], 0, &_DrvEdgS[10]},
+  {&_FilTypS[341], 0, 0},
+  {&_FilTypS[339], 0, &_DrvEdgS[12]},
+  {&_FilTypS[337], &_PrmTypLstS[198], 0},
+  {&_FilTypS[330], 0, 0},
+  {&_FilTypS[329], 0, &_DrvEdgS[15]},
+  {&_FilTypS[328], 0, &_DrvEdgS[16]},
+  {&_FilTypS[327], 0, &_DrvEdgS[17]},
+  {&_FilTypS[326], 0, &_DrvEdgS[18]},
+  {&_FilTypS[325], 0, &_DrvEdgS[19]},
+  {&_FilTypS[312], &_PrmTypLstS[663], 0},
+  {&_FilTypS[321], 0, 0},
+  {&_FilTypS[319], &_PrmTypLstS[191], 0},
+  {&_FilTypS[309], 0, 0},
+  {&_FilTypS[308], 0, &_DrvEdgS[24]},
+  {&_FilTypS[346], &_PrmTypLstS[802], 0},
+  {&_FilTypS[307], &_PrmTypLstS[189], &_DrvEdgS[26]},
+  {&_FilTypS[261], 0, 0},
+  {&_FilTypS[15], 0, 0},
+  {&_FilTypS[14], 0, 0},
+  {&_FilTypS[13], 0, &_DrvEdgS[30]},
+  {&_FilTypS[344], 0, 0},
+  {&_FilTypS[336], 0, &_DrvEdgS[32]},
+  {&_FilTypS[335], 0, &_DrvEdgS[33]},
+  {&_FilTypS[332], 0, &_DrvEdgS[34]},
+  {&_FilTypS[331], 0, &_DrvEdgS[35]},
+  {&_FilTypS[315], 0, &_DrvEdgS[36]},
+  {&_FilTypS[314], 0, &_DrvEdgS[37]},
+  {&_FilTypS[284], 0, &_DrvEdgS[38]},
+  {&_FilTypS[279], 0, &_DrvEdgS[39]},
+  {&_FilTypS[260], 0, &_DrvEdgS[40]},
+  {&_FilTypS[252], 0, &_DrvEdgS[41]},
+  {&_FilTypS[251], 0, &_DrvEdgS[42]},
+  {&_FilTypS[238], 0, &_DrvEdgS[43]},
+  {&_FilTypS[231], 0, &_DrvEdgS[44]},
+  {&_FilTypS[183], 0, &_DrvEdgS[45]},
+  {&_FilTypS[175], 0, &_DrvEdgS[46]},
+  {&_FilTypS[173], 0, &_DrvEdgS[47]},
+  {&_FilTypS[151], 0, &_DrvEdgS[48]},
+  {&_FilTypS[149], 0, &_DrvEdgS[49]},
+  {&_FilTypS[127], 0, &_DrvEdgS[50]},
+  {&_FilTypS[126], 0, &_DrvEdgS[51]},
+  {&_FilTypS[124], 0, &_DrvEdgS[52]},
+  {&_FilTypS[110], 0, &_DrvEdgS[53]},
+  {&_FilTypS[89], &_PrmTypLstS[4], &_DrvEdgS[54]},
+  {&_FilTypS[88], 0, &_DrvEdgS[55]},
+  {&_FilTypS[87], 0, &_DrvEdgS[56]},
+  {&_FilTypS[86], 0, &_DrvEdgS[57]},
+  {&_FilTypS[81], 0, &_DrvEdgS[58]},
+  {&_FilTypS[80], 0, &_DrvEdgS[59]},
+  {&_FilTypS[78], 0, &_DrvEdgS[60]},
+  {&_FilTypS[72], 0, &_DrvEdgS[61]},
+  {&_FilTypS[71], 0, &_DrvEdgS[62]},
+  {&_FilTypS[70], 0, &_DrvEdgS[63]},
+  {&_FilTypS[69], 0, &_DrvEdgS[64]},
+  {&_FilTypS[64], &_PrmTypLstS[2], &_DrvEdgS[65]},
+  {&_FilTypS[63], 0, &_DrvEdgS[66]},
+  {&_FilTypS[20], &_PrmTypLstS[3], &_DrvEdgS[67]},
+  {&_FilTypS[16], &_PrmTypLstS[1], &_DrvEdgS[68]},
+  {&_FilTypS[11], 0, &_DrvEdgS[69]},
+  {&_FilTypS[362], 0, 0},
+  {&_FilTypS[361], 0, &_DrvEdgS[71]},
+  {&_FilTypS[358], 0, 0},
+  {&_FilTypS[357], 0, &_DrvEdgS[73]},
+  {&_FilTypS[283], &_PrmTypLstS[814], 0},
+  {&_FilTypS[282], 0, 0},
+  {&_FilTypS[278], &_PrmTypLstS[239], 0},
+  {&_FilTypS[277], 0, 0},
+  {&_FilTypS[263], 0, 0},
+  {&_FilTypS[230], &_PrmTypLstS[239], 0},
+  {&_FilTypS[229], 0, 0},
+  {&_FilTypS[172], &_PrmTypLstS[239], 0},
+  {&_FilTypS[171], 0, 0},
+  {&_FilTypS[148], &_PrmTypLstS[239], 0},
+  {&_FilTypS[147], 0, 0},
+  {&_FilTypS[84], 0, 0},
+  {&_FilTypS[67], 0, 0},
+  {&_FilTypS[66], 0, &_DrvEdgS[87]},
+  {&_FilTypS[62], &_PrmTypLstS[239], 0},
+  {&_FilTypS[365], &_PrmTypLstS[225], 0},
+  {&_FilTypS[360], &_PrmTypLstS[208], &_DrvEdgS[90]},
+  {&_FilTypS[359], &_PrmTypLstS[204], &_DrvEdgS[91]},
+  {&_FilTypS[356], &_PrmTypLstS[204], &_DrvEdgS[92]},
+  {&_FilTypS[355], &_PrmTypLstS[204], &_DrvEdgS[93]},
+  {&_FilTypS[280], 0, &_DrvEdgS[94]},
+  {&_FilTypS[276], &_PrmTypLstS[19], &_DrvEdgS[95]},
+  {&_FilTypS[265], &_PrmTypLstS[187], &_DrvEdgS[96]},
+  {&_FilTypS[264], &_PrmTypLstS[184], &_DrvEdgS[97]},
+  {&_FilTypS[262], &_PrmTypLstS[183], &_DrvEdgS[98]},
+  {&_FilTypS[259], 0, &_DrvEdgS[99]},
+  {&_FilTypS[228], &_PrmTypLstS[24], &_DrvEdgS[100]},
+  {&_FilTypS[170], &_PrmTypLstS[24], &_DrvEdgS[101]},
+  {&_FilTypS[158], &_PrmTypLstS[239], &_DrvEdgS[102]},
+  {&_FilTypS[146], &_PrmTypLstS[24], &_DrvEdgS[103]},
+  {&_FilTypS[83], 0, &_DrvEdgS[104]},
+  {&_FilTypS[82], 0, &_DrvEdgS[105]},
+  {&_FilTypS[74], 0, &_DrvEdgS[106]},
+  {&_FilTypS[65], 0, &_DrvEdgS[107]},
+  {&_FilTypS[61], 0, &_DrvEdgS[108]},
+  {&_FilTypS[18], 0, &_DrvEdgS[109]},
+  {&_FilTypS[17], 0, &_DrvEdgS[110]},
+  {&_FilTypS[10], 0, &_DrvEdgS[111]},
+  {&_FilTypS[12], &_PrmTypLstS[239], &_DrvEdgS[112]},
+  {&_FilTypS[79], 0, 0},
+  {&_FilTypS[77], 0, &_DrvEdgS[114]},
+  {&_FilTypS[76], 0, &_DrvEdgS[115]},
+  {&_FilTypS[75], 0, &_DrvEdgS[116]},
+  {&_FilTypS[73], 0, &_DrvEdgS[117]},
+  {&_FilTypS[68], 0, &_DrvEdgS[118]},
+  {&_FilTypS[103], &_PrmTypLstS[14], 0},
+  {&_FilTypS[102], &_PrmTypLstS[14], &_DrvEdgS[120]},
+  {&_FilTypS[105], &_PrmTypLstS[7], 0},
+  {&_FilTypS[104], &_PrmTypLstS[7], &_DrvEdgS[122]},
+  {&_FilTypS[111], 0, 0},
+  {&_FilTypS[106], &_PrmTypLstS[15], 0},
+  {&_FilTypS[107], &_PrmTypLstS[15], &_DrvEdgS[125]},
+  {&_FilTypS[108], &_PrmTypLstS[239], &_DrvEdgS[126]},
+  {&_FilTypS[122], 0, 0},
+  {&_FilTypS[249], 0, 0},
+  {&_FilTypS[248], 0, &_DrvEdgS[129]},
+  {&_FilTypS[247], &_PrmTypLstS[252], 0},
+  {&_FilTypS[154], &_PrmTypLstS[78], &_DrvEdgS[131]},
+  {&_FilTypS[153], 0, &_DrvEdgS[132]},
+  {&_FilTypS[150], &_PrmTypLstS[444], &_DrvEdgS[133]},
+  {&_FilTypS[144], 0, &_DrvEdgS[134]},
+  {&_FilTypS[145], 0, 0},
+  {&_FilTypS[159], &_PrmTypLstS[239], 0},
+  {&_FilTypS[174], &_PrmTypLstS[395], 0},
+  {&_FilTypS[168], 0, &_DrvEdgS[138]},
+  {&_FilTypS[169], 0, 0},
+  {&_FilTypS[181], 0, 0},
+  {&_FilTypS[187], &_PrmTypLstS[139], 0},
+  {&_FilTypS[189], &_PrmTypLstS[140], 0},
+  {&_FilTypS[196], 0, 0},
+  {&_FilTypS[195], 0, &_DrvEdgS[144]},
+  {&_FilTypS[194], 0, &_DrvEdgS[145]},
+  {&_FilTypS[193], &_PrmTypLstS[157], 0},
+  {&_FilTypS[205], 0, 0},
+  {&_FilTypS[204], 0, &_DrvEdgS[148]},
+  {&_FilTypS[203], 0, &_DrvEdgS[149]},
+  {&_FilTypS[202], 0, &_DrvEdgS[150]},
+  {&_FilTypS[201], &_PrmTypLstS[140], 0},
+  {&_FilTypS[214], 0, 0},
+  {&_FilTypS[213], 0, &_DrvEdgS[153]},
+  {&_FilTypS[212], 0, &_DrvEdgS[154]},
+  {&_FilTypS[211], 0, &_DrvEdgS[155]},
+  {&_FilTypS[210], &_PrmTypLstS[265], 0},
+  {&_FilTypS[237], 0, 0},
+  {&_FilTypS[236], 0, &_DrvEdgS[158]},
+  {&_FilTypS[235], 0, &_DrvEdgS[159]},
+  {&_FilTypS[234], 0, &_DrvEdgS[160]},
+  {&_FilTypS[233], 0, &_DrvEdgS[161]},
+  {&_FilTypS[239], 0, &_DrvEdgS[162]},
+  {&_FilTypS[240], &_PrmTypLstS[477], &_DrvEdgS[163]},
+  {&_FilTypS[232], &_PrmTypLstS[264], 0},
+  {&_FilTypS[241], &_PrmTypLstS[477], &_DrvEdgS[165]},
+  {&_FilTypS[281], 0, 0},
+  {&_FilTypS[320], &_PrmTypLstS[580], 0},
+  {&_FilTypS[366], &_PrmTypLstS[225], 0},
+  {&_FilTypS[176], &_PrmTypLstS[833], 0},
+  {&_FilTypS[310], &_PrmTypLstS[190], &_DrvEdgS[27]},
+  {&_FilTypS[323], &_PrmTypLstS[760], &_DrvEdgS[171]},
+  {&_FilTypS[317], &_PrmTypLstS[712], &_DrvEdgS[172]},
+  {&_FilTypS[324], &_PrmTypLstS[802], &_DrvEdgS[173]},
+  {&_FilTypS[343], &_PrmTypLstS[885], &_DrvEdgS[174]},
+  {&_FilTypS[334], &_PrmTypLstS[802], &_DrvEdgS[175]},
+  {&_FilTypS[342], &_PrmTypLstS[802], &_DrvEdgS[176]},
+  {&_FilTypS[152], &_PrmTypLstS[580], 0},
+  {&_FilTypS[152], &_PrmTypLstS[833], 0},
+  {&_FilTypS[176], &_PrmTypLstS[580], 0},
+  {&_FilTypS[184], &_PrmTypLstS[544], 0},
+  {&_FilTypS[185], &_PrmTypLstS[544], &_DrvEdgS[181]},
+  {&_FilTypS[306], 0, &_DrvEdgS[168]} };
+int num_InpSpcS = 655;
+tps_InpSpc _InpSpcS [655] = {
+  {3, &_FilTypS[0], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[23], 0, 0, 0, 0, &_InpSpcS[4]},
+  {3, &_FilTypS[63], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[23], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[24], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[22], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[22], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[28], 0, 0, 0, 0, 0},
+  {2, 0, 0, "copy.lua", 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[2], 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[4], 0, 0, 0, 0},
+  {3, &_FilTypS[65], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[65], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[36], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[3], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[3], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[3], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[3], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[3], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[3], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[53], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[3], 0, 0, 0, 0},
+  {2, 0, 0, "help.lua", 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[6], 0, 0, 0, 0},
+  {2, 0, 0, "rcs.log.lua", 0, 0, 0},
+  {3, &_FilTypS[90], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[7], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[8], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[9], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[10], 0, 0, 0, 0},
+  {2, 0, 0, "rcs_co.lua", 0, 0, 0},
+  {3, &_FilTypS[90], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[7], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[8], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[9], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[10], 0, 0, 0, 0},
+  {2, 0, 0, "sccs_co.lua", 0, 0, 0},
+  {3, &_FilTypS[91], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[7], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[8], 0, 0, 0, 0},
+  {2, 0, 0, "sccs.log.lua", 0, 0, 0},
+  {3, &_FilTypS[91], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[7], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[8], 0, 0, 0, 0},
+  {2, 0, 0, "vw.lua", 0, 0, 0},
+  {3, &_FilTypS[92], 0, 0, 0, 0, &_InpSpcS[71]},
+  {3, &_FilTypS[51], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[11], 0, 0, 0, 0},
+  {1, 0, 0, "ODIN_VC_RCS", 1, 0, 0},
+  {1, 0, 0, "ODIN_VC_SCCS", 1, 0, 0},
+  {2, 0, 0, "merge.lua", 0, 0, 0},
+  {3, &_FilTypS[93], 0, 0, 0, 0, &_InpSpcS[77]},
+  {3, &_FilTypS[54], 0, 0, 0, 0, &_InpSpcS[78]},
+  {3, &_FilTypS[42], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[92], 0, 0, 0, 0, &_InpSpcS[80]},
+  {3, &_FilTypS[52], 0, 0, 0, 0, 0},
+  {2, 0, 0, "vw.of.lua", 0, 0, 0},
+  {3, &_FilTypS[92], 0, 0, 0, 0, &_InpSpcS[83]},
+  {3, &_FilTypS[51], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[94], 0, 0, 0, 0, &_InpSpcS[85]},
+  {3, &_FilTypS[109], 0, 0, 0, 0, &_InpSpcS[86]},
+  {3, &_FilTypS[110], 0, 0, 0, 0, &_InpSpcS[88]},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[44], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[95], 0, 0, 0, 0, &_InpSpcS[90]},
+  {3, &_FilTypS[29], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[114], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[116], 0, 0, 0, 0, &_InpSpcS[93]},
+  {3, &_FilTypS[124], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {2, 0, 0, "o_of.lua", 0, 0, 0},
+  {3, &_FilTypS[117], 0, 0, 0, 0, &_InpSpcS[97]},
+  {3, &_FilTypS[126], 0, 0, 0, 0, &_InpSpcS[99]},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[44], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[117], 0, 0, 0, 0, &_InpSpcS[101]},
+  {3, &_FilTypS[127], 0, 0, 0, 0, &_InpSpcS[103]},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[44], 0, 0, 0, 0, 0},
+  {2, 0, 0, "ar.lua", 0, 0, 0},
+  {3, &_FilTypS[119], 0, 0, 0, 0, &_InpSpcS[106]},
+  {3, &_FilTypS[29], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[119], 0, 0, 0, 0, &_InpSpcS[108]},
+  {3, &_FilTypS[28], 0, 0, 0, 0, 0},
+  {1, 0, 0, "ODIN_RANLIB", 1, 0, 0},
+  {3, &_FilTypS[129], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[129], 0, 0, 0, 0, 0},
+  {2, 0, 0, "libraries.lua", 0, 0, 0},
+  {4, 0, &_PrmTypS[12], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[13], 0, 0, 0, 0},
+  {3, &_FilTypS[118], 0, 0, 0, 0, &_InpSpcS[116]},
+  {3, &_FilTypS[121], 0, 0, 0, 0, 0},
+  {1, 0, 0, "ODIN_LIB_SP", 1, 0, 0},
+  {3, &_FilTypS[118], 0, 0, 0, 0, &_InpSpcS[119]},
+  {3, &_FilTypS[54], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[133], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[135], 0, 0, 0, 0, 0},
+  {2, 0, 0, "c_inc.lua", 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, &_InpSpcS[125]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[26], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[23], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[24], 0, 0, 0, 0},
+  {1, 0, 0, "ODIN_CC_I", 1, 0, 0},
+  {1, 0, 0, "ODIN_IGNORE", 1, 0, 0},
+  {3, &_FilTypS[139], 0, 0, 0, 0, &_InpSpcS[132]},
+  {3, &_FilTypS[54], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[140], 0, 0, 0, 0, &_InpSpcS[134]},
+  {3, &_FilTypS[149], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[140], 0, 0, 0, 0, 0},
+  {2, 0, 0, "cc.lua", 0, 0, 0},
+  {3, &_FilTypS[133], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[133], 0, 0, 0, 0, &_InpSpcS[140]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[23], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[19], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[27], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[15], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[17], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[16], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[14], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[20], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[21], 0, 0, 0, 0},
+  {3, &_FilTypS[133], 0, 0, 0, 0, &_InpSpcS[151]},
+  {4, 0, &_PrmTypS[26], 0, 0, &_InpSpcS[152], &_InpSpcS[154]},
+  {3, &_FilTypS[133], 0, 0, 0, 0, &_InpSpcS[153]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[151], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {1, 0, 0, "ODIN_CC", 1, 0, 0},
+  {1, 0, 0, "ODIN_CC_DEBUGF", 1, 0, 0},
+  {1, 0, 0, "ODIN_CC_FLAGS", 1, 0, 0},
+  {1, 0, 0, "ODIN_CC_HOME", 1, 0, 0},
+  {2, 0, 0, "ld.lua", 0, 0, 0},
+  {3, &_FilTypS[119], 0, 0, 0, 0, &_InpSpcS[162]},
+  {3, &_FilTypS[29], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[120], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[19], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[27], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[25], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[15], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[17], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[18], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[20], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[22], 0, 0, 0, 0},
+  {3, &_FilTypS[119], 0, 0, 0, 0, &_InpSpcS[173]},
+  {3, &_FilTypS[28], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[121], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[137], 0, 0, 0, 0, 0},
+  {1, 0, 0, "ODIN_CC", 1, 0, 0},
+  {1, 0, 0, "ODIN_CC_DEBUGF", 1, 0, 0},
+  {1, 0, 0, "ODIN_CC_FLAGS", 1, 0, 0},
+  {1, 0, 0, "ODIN_CC_HOME", 1, 0, 0},
+  {2, 0, 0, "fmt.c.lua", 0, 0, 0},
+  {3, &_FilTypS[133], 0, 0, 0, 0, 0},
+  {2, 0, 0, "c.h.lua", 0, 0, 0},
+  {3, &_FilTypS[133], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[133], 0, 0, 0, 0, &_InpSpcS[185]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[23], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[14], 0, 0, 0, 0},
+  {2, 0, 0, "cpp.lua", 0, 0, 0},
+  {1, 0, 0, "cpp", 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, &_InpSpcS[192]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[23], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[14], 0, 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, &_InpSpcS[196]},
+  {4, 0, &_PrmTypS[26], 0, 0, &_InpSpcS[197], &_InpSpcS[199]},
+  {3, &_FilTypS[2], 0, 0, 0, 0, &_InpSpcS[198]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[151], 0, 0, 0, 0, 0},
+  {1, 0, 0, "ODIN_CPP", 1, 0, 0},
+  {1, 0, 0, "ODIN_CPP_FLAGS", 1, 0, 0},
+  {2, 0, 0, "cpp.lua", 0, 0, 0},
+  {1, 0, 0, "gnc.cpp", 0, 0, 0},
+  {3, &_FilTypS[155], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[155], 0, 0, 0, 0, &_InpSpcS[206]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[23], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[14], 0, 0, 0, 0},
+  {3, &_FilTypS[155], 0, 0, 0, 0, &_InpSpcS[210]},
+  {4, 0, &_PrmTypS[26], 0, 0, &_InpSpcS[211], &_InpSpcS[213]},
+  {3, &_FilTypS[155], 0, 0, 0, 0, &_InpSpcS[212]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[151], 0, 0, 0, 0, 0},
+  {1, 0, 0, "ODIN_CPP", 1, 0, 0},
+  {1, 0, 0, "ODIN_CPP_FLAGS", 1, 0, 0},
+  {3, &_FilTypS[160], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[161], 0, 0, 0, 0, 0},
+  {2, 0, 0, "cxx_inc.lua", 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, &_InpSpcS[221]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[26], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[23], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[24], 0, 0, 0, 0},
+  {1, 0, 0, "ODIN_CXX_I", 1, 0, 0},
+  {1, 0, 0, "ODIN_IGNORE", 1, 0, 0},
+  {3, &_FilTypS[162], 0, 0, 0, 0, &_InpSpcS[228]},
+  {3, &_FilTypS[54], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[163], 0, 0, 0, 0, &_InpSpcS[230]},
+  {3, &_FilTypS[173], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[163], 0, 0, 0, 0, 0},
+  {2, 0, 0, "CC.lua", 0, 0, 0},
+  {3, &_FilTypS[160], 0, 0, 0, 0, 0},
+  {2, 0, 0, "ptr_of", 0, 0, &_InpSpcS[236]},
+  {3, &_FilTypS[29], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[160], 0, 0, 0, 0, &_InpSpcS[238]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[23], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[27], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[15], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[17], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[16], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[14], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[28], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[29], 0, 0, 0, 0},
+  {3, &_FilTypS[160], 0, 0, 0, 0, &_InpSpcS[248]},
+  {4, 0, &_PrmTypS[26], 0, 0, &_InpSpcS[249], &_InpSpcS[251]},
+  {3, &_FilTypS[160], 0, 0, 0, 0, &_InpSpcS[250]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[175], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {1, 0, 0, "ODIN_CXX", 1, 0, 0},
+  {1, 0, 0, "ODIN_CXX_DEBUGF", 1, 0, 0},
+  {1, 0, 0, "ODIN_CXX_FLAGS", 1, 0, 0},
+  {1, 0, 0, "ODIN_CXX_HOME", 1, 0, 0},
+  {1, 0, 0, "ODIN_CXX_LD_LIBRARY_PATH", 1, 0, 0},
+  {1, 0, 0, "ODIN_CXX_PTR", 1, 0, 0},
+  {2, 0, 0, "ld.lua", 0, 0, 0},
+  {3, &_FilTypS[119], 0, 0, 0, 0, &_InpSpcS[261]},
+  {3, &_FilTypS[29], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[120], 0, 0, 0, 0, 0},
+  {2, 0, 0, "ptr_of", 0, 0, &_InpSpcS[264]},
+  {3, &_FilTypS[29], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[14], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[23], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[27], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[25], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[15], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[17], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[18], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[28], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[22], 0, 0, 0, 0},
+  {3, &_FilTypS[119], 0, 0, 0, 0, &_InpSpcS[275]},
+  {3, &_FilTypS[28], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[121], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[166], 0, 0, 0, 0, 0},
+  {1, 0, 0, "ODIN_CXX", 1, 0, 0},
+  {1, 0, 0, "ODIN_CXX_DEBUGF", 1, 0, 0},
+  {1, 0, 0, "ODIN_CXX_FLAGS", 1, 0, 0},
+  {1, 0, 0, "ODIN_CXX_HOME", 1, 0, 0},
+  {1, 0, 0, "ODIN_CXX_IGNORE_ERR", 1, 0, 0},
+  {1, 0, 0, "ODIN_CXX_LD_LIBRARY_PATH", 1, 0, 0},
+  {1, 0, 0, "ODIN_CXX_PTR", 1, 0, 0},
+  {3, &_FilTypS[177], 0, 0, 0, 0, 0},
+  {2, 0, 0, "com_schema.lua", 0, 0, 0},
+  {4, 0, &_PrmTypS[30], 0, 0, 0, &_InpSpcS[288]},
+  {3, &_FilTypS[44], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[30], 0, 0, 0, &_InpSpcS[290]},
+  {3, &_FilTypS[183], 0, 0, 0, 0, &_InpSpcS[292]},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[44], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[31], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[23], 0, 0, 0, 0},
+  {3, &_FilTypS[180], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[30], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[30], 0, 0, 0, &_InpSpcS[298]},
+  {3, &_FilTypS[173], 0, 0, 0, 0, 0},
+  {1, 0, 0, "OS_ROOTDIR", 1, 0, 0},
+  {2, 0, 0, "app_schema.lua", 0, 0, 0},
+  {4, 0, &_PrmTypS[31], 0, 0, 0, 0},
+  {3, &_FilTypS[178], 0, 0, 0, 0, &_InpSpcS[303]},
+  {3, &_FilTypS[124], 0, 0, 0, 0, &_InpSpcS[304]},
+  {3, &_FilTypS[127], 0, 0, 0, 0, &_InpSpcS[305]},
+  {3, &_FilTypS[44], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[120], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[178], 0, 0, 0, 0, &_InpSpcS[308]},
+  {3, &_FilTypS[124], 0, 0, 0, 0, &_InpSpcS[309]},
+  {3, &_FilTypS[127], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[121], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[180], 0, 0, 0, 0, 0},
+  {1, 0, 0, "OS_ROOTDIR", 1, 0, 0},
+  {3, &_FilTypS[178], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[179], 0, 0, 0, 0, 0},
+  {2, 0, 0, "f_obj.lua", 0, 0, 0},
+  {3, &_FilTypS[186], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[15], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[17], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[32], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[33], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[34], 0, 0, 0, 0},
+  {2, 0, 0, "lex.lua", 0, 0, 0},
+  {3, &_FilTypS[188], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[36], 0, 0, 0, 0},
+  {3, &_FilTypS[193], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[193], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[193], 0, 0, 0, 0, 0},
+  {2, 0, 0, "yacc.lua", 0, 0, 0},
+  {3, &_FilTypS[190], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[36], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[38], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[37], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[27], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[39], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[40], 0, 0, 0, 0},
+  {1, 0, 0, "ODIN_SYS5", 1, 0, 0},
+  {1, 0, 0, "ODIN_YACC", 1, 0, 0},
+  {1, 0, 0, "ODIN_YACC_FLAGS", 1, 0, 0},
+  {3, &_FilTypS[201], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[201], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[201], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[201], 0, 0, 0, 0, 0},
+  {2, 0, 0, "ygt.lua", 0, 0, 0},
+  {3, &_FilTypS[197], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[36], 0, 0, 0, 0},
+  {2, 0, 0, "tregrm.exe", 0, 0, 0},
+  {3, &_FilTypS[210], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[210], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[210], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[210], 0, 0, 0, 0, 0},
+  {2, 0, 0, "dg_out.lua", 0, 0, 0},
+  {2, 0, 0, "dg.exe", 0, 0, 0},
+  {3, &_FilTypS[206], 0, 0, 0, 0, &_InpSpcS[354]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, &_InpSpcS[355]},
+  {6, 0, 0, "..", 0, 0, 0},
+  {4, 0, &_PrmTypS[41], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[41], 0, 0, 0, &_InpSpcS[358]},
+  {4, 0, &_PrmTypS[42], 0, 0, &_InpSpcS[359], &_InpSpcS[362]},
+  {3, &_FilTypS[206], 0, 0, 0, 0, &_InpSpcS[360]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, &_InpSpcS[361]},
+  {6, 0, 0, "..", 0, 0, 0},
+  {4, 0, &_PrmTypS[43], ".*/\\/&\\/&.dg", 0, 0, &_InpSpcS[363]},
+  {3, &_FilTypS[215], 0, 0, 0, 0, &_InpSpcS[364]},
+  {3, &_FilTypS[109], 0, 0, 0, 0, 0},
+  {2, 0, 0, "idl_inc.lua", 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, &_InpSpcS[368]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[26], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[23], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[24], 0, 0, 0, 0},
+  {1, 0, 0, "ODIN_IDL_I", 1, 0, 0},
+  {1, 0, 0, "ODIN_IGNORE", 1, 0, 0},
+  {3, &_FilTypS[217], 0, 0, 0, 0, &_InpSpcS[375]},
+  {3, &_FilTypS[54], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[218], 0, 0, 0, 0, &_InpSpcS[377]},
+  {3, &_FilTypS[231], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[218], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[232], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[232], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[232], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[232], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[232], 0, 0, 0, 0, 0},
+  {2, 0, 0, "idl.lua", 0, 0, 0},
+  {3, &_FilTypS[216], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[216], 0, 0, 0, 0, &_InpSpcS[388]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[23], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[44], 0, 0, 0, 0},
+  {3, &_FilTypS[216], 0, 0, 0, 0, &_InpSpcS[392]},
+  {4, 0, &_PrmTypS[26], 0, 0, &_InpSpcS[393], &_InpSpcS[395]},
+  {3, &_FilTypS[216], 0, 0, 0, 0, &_InpSpcS[394]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[238], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {1, 0, 0, "ODIN_IDL", 1, 0, 0},
+  {1, 0, 0, "ODIN_IDL_FLAGS", 1, 0, 0},
+  {1, 0, 0, "ODIN_IDL_HOME", 1, 0, 0},
+  {3, &_FilTypS[221], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[224], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[222], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[223], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[226], 0, 0, 0, 0, &_InpSpcS[405]},
+  {4, 0, &_PrmTypS[23], 0, 0, &_InpSpcS[406], &_InpSpcS[407]},
+  {3, &_FilTypS[220], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[113], 0, 0, 0, 0, 0},
+  {2, 0, 0, "idl_tgts.lua", 0, 0, 0},
+  {3, &_FilTypS[216], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[220], 0, 0, 0, 0, &_InpSpcS[411]},
+  {3, &_FilTypS[41], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[225], 0, 0, 0, 0, &_InpSpcS[413]},
+  {3, &_FilTypS[41], 0, 0, 0, 0, 0},
+  {2, 0, 0, "profile.lua", 0, 0, 0},
+  {3, &_FilTypS[134], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[45], 0, 0, 0, &_InpSpcS[417]},
+  {3, &_FilTypS[44], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[46], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[45], 0, 0, 0, 0},
+  {3, &_FilTypS[247], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[247], 0, 0, 0, 0, 0},
+  {2, 0, 0, "lint1.lua", 0, 0, 0},
+  {3, &_FilTypS[133], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[133], 0, 0, 0, 0, &_InpSpcS[425]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[23], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[14], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[51], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[49], 0, 0, 0, 0},
+  {3, &_FilTypS[133], 0, 0, 0, 0, &_InpSpcS[431]},
+  {4, 0, &_PrmTypS[26], 0, 0, &_InpSpcS[432], &_InpSpcS[434]},
+  {3, &_FilTypS[133], 0, 0, 0, 0, &_InpSpcS[433]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[151], 0, 0, 0, 0, 0},
+  {1, 0, 0, "ODIN_LINT_FLAGS", 1, 0, 0},
+  {1, 0, 0, "ODIN_LINT_PASS1_FLAG", 1, 0, 0},
+  {2, 0, 0, "lint.lua", 0, 0, 0},
+  {3, &_FilTypS[117], 0, 0, 0, 0, &_InpSpcS[439]},
+  {3, &_FilTypS[251], 0, 0, 0, 0, &_InpSpcS[441]},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[44], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[117], 0, 0, 0, 0, &_InpSpcS[443]},
+  {3, &_FilTypS[252], 0, 0, 0, 0, &_InpSpcS[445]},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[44], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[48], 0, 0, 0, &_InpSpcS[447]},
+  {3, &_FilTypS[251], 0, 0, 0, 0, &_InpSpcS[448]},
+  {3, &_FilTypS[44], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[47], 0, 0, 0, &_InpSpcS[450]},
+  {3, &_FilTypS[44], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[51], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[49], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[50], 0, 0, 0, 0},
+  {3, &_FilTypS[117], 0, 0, 0, 0, &_InpSpcS[455]},
+  {3, &_FilTypS[251], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[117], 0, 0, 0, 0, &_InpSpcS[457]},
+  {3, &_FilTypS[252], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[48], 0, 0, 0, &_InpSpcS[459]},
+  {3, &_FilTypS[251], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[47], 0, 0, 0, 0},
+  {1, 0, 0, "ODIN_LINT_FLAGS", 1, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {2, 0, 0, "redo.lua", 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, &_InpSpcS[465]},
+  {3, &_FilTypS[41], 0, 0, 0, 0, 0},
+  {2, 0, 0, "redo_errs.lua", 0, 0, 0},
+  {3, &_FilTypS[38], 0, 0, 0, 0, 0},
+  {2, 0, 0, "boot.lua", 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[52], 0, 0, 0, 0},
+  {3, &_FilTypS[255], 0, 0, 0, 0, 0},
+  {2, 0, 0, "diff.lua", 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[53], 0, 0, 0, 0},
+  {2, 0, 0, "rcp.lua", 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[54], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[55], 0, 0, 0, 0},
+  {2, 0, 0, "so_inc.lua", 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[26], 0, 0, 0, 0},
+  {3, &_FilTypS[269], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[270], 0, 0, 0, 0, &_InpSpcS[484]},
+  {3, &_FilTypS[279], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[270], 0, 0, 0, 0, 0},
+  {2, 0, 0, "eqn.lua", 0, 0, 0},
+  {1, 0, 0, "eqn", 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {2, 0, 0, "eqn.lua", 0, 0, 0},
+  {1, 0, 0, "gnc.eqn", 0, 0, 0},
+  {3, &_FilTypS[266], 0, 0, 0, 0, 0},
+  {2, 0, 0, "tbl.lua", 0, 0, 0},
+  {3, &_FilTypS[267], 0, 0, 0, 0, 0},
+  {2, 0, 0, "nroff.lua", 0, 0, 0},
+  {3, &_FilTypS[268], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[268], 0, 0, 0, 0, &_InpSpcS[498]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[56], 0, 0, 0, 0},
+  {3, &_FilTypS[268], 0, 0, 0, 0, &_InpSpcS[501]},
+  {4, 0, &_PrmTypS[26], 0, 0, &_InpSpcS[502], &_InpSpcS[504]},
+  {3, &_FilTypS[268], 0, 0, 0, 0, &_InpSpcS[503]},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[284], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {2, 0, 0, "oneTex.lua", 0, 0, 0},
+  {3, &_FilTypS[285], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[47], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[307], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[307], 0, 0, 0, 0, 0},
+  {2, 0, 0, "root.lua", 0, 0, 0},
+  {3, &_FilTypS[292], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[59], 0, 0, 0, 0},
+  {3, &_FilTypS[292], 0, 0, 0, 0, &_InpSpcS[515]},
+  {3, &_FilTypS[28], 0, 0, 0, 0, 0},
+  {2, 0, 0, "texsp.lua", 0, 0, 0},
+  {3, &_FilTypS[292], 0, 0, 0, 0, &_InpSpcS[518]},
+  {3, &_FilTypS[29], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[40], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[60], 0, 0, 0, 0},
+  {3, &_FilTypS[313], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[313], 0, 0, 0, 0, &_InpSpcS[523]},
+  {3, &_FilTypS[314], 0, 0, 0, 0, &_InpSpcS[525]},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[315], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[294], 0, 0, 0, 0, &_InpSpcS[528]},
+  {4, 0, &_PrmTypS[63], 0, 0, &_InpSpcS[529], &_InpSpcS[530]},
+  {3, &_FilTypS[296], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[311], 0, 0, 0, 0, 0},
+  {2, 0, 0, "tex_view.lua", 0, 0, 0},
+  {3, &_FilTypS[295], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[63], 0, 0, 0, 0},
+  {2, 0, 0, "texscan.lua", 0, 0, 0},
+  {2, 0, 0, "texscan.c", 0, 0, &_InpSpcS[536]},
+  {3, &_FilTypS[134], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[285], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[318], 0, 0, 0, 0, &_InpSpcS[539]},
+  {3, &_FilTypS[54], 0, 0, 0, 0, 0},
+  {2, 0, 0, "fmtcmd.lua", 0, 0, 0},
+  {3, &_FilTypS[294], 0, 0, 0, 0, &_InpSpcS[542]},
+  {4, 0, &_PrmTypS[63], 0, 0, &_InpSpcS[543], &_InpSpcS[544]},
+  {3, &_FilTypS[296], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[313], 0, 0, 0, 0, &_InpSpcS[545]},
+  {3, &_FilTypS[44], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[57], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[58], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[64], 0, 0, 0, 0},
+  {3, &_FilTypS[324], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[324], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[324], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[324], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[324], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[324], 0, 0, 0, 0, 0},
+  {2, 0, 0, "tex.lua", 0, 0, 0},
+  {3, &_FilTypS[322], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[293], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[296], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[292], 0, 0, 0, 0, &_InpSpcS[560]},
+  {3, &_FilTypS[303], 0, 0, 0, 0, &_InpSpcS[561]},
+  {3, &_FilTypS[29], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[316], 0, 0, 0, 0, &_InpSpcS[563]},
+  {3, &_FilTypS[314], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[316], 0, 0, 0, 0, &_InpSpcS[565]},
+  {3, &_FilTypS[331], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[316], 0, 0, 0, 0, &_InpSpcS[568]},
+  {3, &_FilTypS[332], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[292], 0, 0, 0, 0, &_InpSpcS[571]},
+  {3, &_FilTypS[303], 0, 0, 0, 0, &_InpSpcS[572]},
+  {3, &_FilTypS[28], 0, 0, 0, 0, 0},
+  {2, 0, 0, "bibtex.lua", 0, 0, 0},
+  {3, &_FilTypS[300], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[296], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[316], 0, 0, 0, 0, &_InpSpcS[577]},
+  {3, &_FilTypS[335], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[316], 0, 0, 0, 0, &_InpSpcS[580]},
+  {3, &_FilTypS[336], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[337], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[337], 0, 0, 0, 0, 0},
+  {2, 0, 0, "makeindex.lua", 0, 0, 0},
+  {3, &_FilTypS[301], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[62], 0, 0, 0, 0},
+  {2, 0, 0, "texauxin.lua", 0, 0, 0},
+  {3, &_FilTypS[293], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[302], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[333], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[338], 0, 0, 0, 0, 0},
+  {2, 0, 0, "dvips.lua", 0, 0, 0},
+  {3, &_FilTypS[297], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[296], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[61], 0, 0, 0, 0},
+  {3, &_FilTypS[316], 0, 0, 0, 0, &_InpSpcS[597]},
+  {3, &_FilTypS[344], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[1], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[292], 0, 0, 0, 0, &_InpSpcS[600]},
+  {4, 0, &_PrmTypS[64], 0, 0, 0, &_InpSpcS[601]},
+  {3, &_FilTypS[298], 0, 0, 0, 0, 0},
+  {2, 0, 0, "dbx.lua", 0, 0, 0},
+  {3, &_FilTypS[134], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[65], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[27], 0, 0, 0, 0},
+  {2, 0, 0, "run.lua", 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[66], 0, 0, 0, &_InpSpcS[609]},
+  {3, &_FilTypS[44], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[66], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[68], 0, 0, 0, 0},
+  {3, &_FilTypS[356], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[356], 0, 0, 0, 0, 0},
+  {2, 0, 0, "pipe.run.lua", 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[66], 0, 0, 0, &_InpSpcS[617]},
+  {3, &_FilTypS[44], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[66], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[68], 0, 0, 0, 0},
+  {2, 0, 0, "lua_run.lua", 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[66], 0, 0, 0, &_InpSpcS[623]},
+  {3, &_FilTypS[44], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[66], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[68], 0, 0, 0, 0},
+  {3, &_FilTypS[360], 0, 0, 0, 0, 0},
+  {3, &_FilTypS[360], 0, 0, 0, 0, 0},
+  {2, 0, 0, "pipe.lua_run.lua", 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[66], 0, 0, 0, &_InpSpcS[631]},
+  {3, &_FilTypS[44], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[67], 0, 0, 0, &_InpSpcS[633]},
+  {3, &_FilTypS[44], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[66], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[68], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[67], 0, 0, 0, 0},
+  {2, 0, 0, "regsub.lua", 0, 0, 0},
+  {1, 0, 0, "regsub", 0, 0, 0},
+  {3, &_FilTypS[2], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[69], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[70], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[43], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[71], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[42], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[72], 0, 0, 0, 0},
+  {2, 0, 0, "regsub.lua", 0, 0, 0},
+  {1, 0, 0, "gnc.regsub", 0, 0, 0},
+  {3, &_FilTypS[363], 0, 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[69], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[70], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[43], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[71], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[42], 0, 0, 0, 0},
+  {4, 0, &_PrmTypS[72], 0, 0, 0, 0} };
diff -ruNx autom4te.cache -x 'config*' pkg/odin/boot/stub-in.c pkg/odin/boot/stub-in.c
--- pkg/odin/boot/stub-in.c	1969-12-31 18:00:00.000000000 -0600
+++ pkg/odin/boot/stub-in.c	2016-09-08 11:04:03.717628597 -0500
@@ -0,0 +1,1033 @@
+#include "inc/GMC.h"
+#include "inc/Str.h"
+
+extern boolean IPC_Do_Return;
+extern int *IPC_IArg1, *IPC_IArg2, *IPC_IArg3;
+extern tp_Str IPC_SArg1, IPC_SArg2, IPC_SArg3;
+
+
+#ifndef SERVER_ONLY
+static void
+Add_BuildArg_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str FileName;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Str(IPC_AbortPtr, FileName);
+   if (*IPC_AbortPtr) return;
+   Local_Add_BuildArg(FileName);
+}
+#endif
+
+#ifndef SERVER_ONLY
+static void
+Do_Build_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   int JobID;
+   tps_Str JobDirName;
+   tps_Str LogFileName;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Int(IPC_AbortPtr, &JobID);
+   if (*IPC_AbortPtr) return;
+   IPC_Read_Str(IPC_AbortPtr, JobDirName);
+   if (*IPC_AbortPtr) return;
+   IPC_Read_Str(IPC_AbortPtr, LogFileName);
+   if (*IPC_AbortPtr) return;
+   Local_Do_Build(JobID, JobDirName, LogFileName);
+}
+#endif
+
+#ifndef SERVER_ONLY
+static void
+Abort_Build_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   int JobID;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Int(IPC_AbortPtr, &JobID);
+   if (*IPC_AbortPtr) return;
+   Local_Abort_Build(JobID);
+}
+#endif
+
+#ifndef SERVER_ONLY
+static void
+Do_MakeReadOnly_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str FileName;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Str(IPC_AbortPtr, FileName);
+   if (*IPC_AbortPtr) return;
+   Local_Do_MakeReadOnly(FileName);
+}
+#endif
+
+#ifndef SERVER_ONLY
+static void
+ErrMessage_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str Message;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Str(IPC_AbortPtr, Message);
+   if (*IPC_AbortPtr) return;
+   Local_ErrMessage(Message);
+}
+#endif
+
+#ifndef SERVER_ONLY
+static void
+LogMessage_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str Message;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Str(IPC_AbortPtr, Message);
+   if (*IPC_AbortPtr) return;
+   Local_LogMessage(Message);
+}
+#endif
+
+#ifndef SERVER_ONLY
+static void
+FileErrMessage_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str FileName;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Str(IPC_AbortPtr, FileName);
+   if (*IPC_AbortPtr) return;
+   Local_FileErrMessage(FileName);
+}
+#endif
+
+#ifndef SERVER_ONLY
+static void
+Next_OdinFile_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str OdinExpr;
+   int ID;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Str(IPC_AbortPtr, OdinExpr);
+   if (*IPC_AbortPtr) return;
+   IPC_Read_Int(IPC_AbortPtr, &ID);
+   if (*IPC_AbortPtr) return;
+   Local_Next_OdinFile(OdinExpr, ID);
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Get_UseCount_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   int CountPtr;
+
+   *IPC_AbortPtr = FALSE;
+   Local_Get_UseCount(&CountPtr);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+   IPC_Write_Int(IPC_AbortPtr, CountPtr);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Get_CurSize_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   int SizePtr;
+
+   *IPC_AbortPtr = FALSE;
+   Local_Get_CurSize(&SizePtr);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+   IPC_Write_Int(IPC_AbortPtr, SizePtr);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+ShutDown_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+
+   *IPC_AbortPtr = FALSE;
+   Local_ShutDown();
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Get_Banner_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str Str;
+
+   *IPC_AbortPtr = FALSE;
+   Local_Get_Banner(Str);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+   IPC_Write_Str(IPC_AbortPtr, Str);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Do_Interrupt_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   int InterruptFlag;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Int(IPC_AbortPtr, &InterruptFlag);
+   if (*IPC_AbortPtr) return;
+   Local_Do_Interrupt(InterruptFlag);
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Do_Alias_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str FileName;
+   int ForceFlag;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Str(IPC_AbortPtr, FileName);
+   if (*IPC_AbortPtr) return;
+   IPC_Read_Int(IPC_AbortPtr, &ForceFlag);
+   if (*IPC_AbortPtr) return;
+   Local_Do_Alias(FileName, ForceFlag);
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Get_Alias_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str OutFileName;
+   tps_Str FileName;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Str(IPC_AbortPtr, FileName);
+   if (*IPC_AbortPtr) return;
+   Local_Get_Alias(OutFileName, FileName);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+   IPC_Write_Str(IPC_AbortPtr, OutFileName);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Job_Done_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   int JobID;
+   int Abort;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Int(IPC_AbortPtr, &JobID);
+   if (*IPC_AbortPtr) return;
+   IPC_Read_Int(IPC_AbortPtr, &Abort);
+   if (*IPC_AbortPtr) return;
+   Local_Job_Done(JobID, Abort);
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Test_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str FileName;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Str(IPC_AbortPtr, FileName);
+   if (*IPC_AbortPtr) return;
+   Local_Test(FileName);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Test_All_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+
+   *IPC_AbortPtr = FALSE;
+   Local_Test_All();
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Get_OdinFile_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str OdinExpr;
+   int NeedsData;
+
+   IPC_Read_Str(IPC_AbortPtr, OdinExpr);
+   if (*IPC_AbortPtr) return;
+   IPC_Read_Int(IPC_AbortPtr, &NeedsData);
+   if (*IPC_AbortPtr) return;
+   Local_Get_OdinFile(OdinExpr, NeedsData);
+}
+
+void
+LocalEnd_Get_OdinFile(
+   tp_FileName FileName,
+   tp_Status StatusPtr,
+   boolean ExecFlagPtr
+   )
+{
+   boolean IPC_Abort;
+
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      (void)strcpy(IPC_SArg1, FileName);
+      *IPC_IArg2 = StatusPtr;
+      *IPC_IArg3 = ExecFlagPtr;
+      FORBIDDEN(IPC_Do_Return);
+
+      IPC_Do_Return = TRUE;
+
+      return; }
+
+   IPC_Write_Int(&IPC_Abort, 1);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, FileName);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, StatusPtr);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, ExecFlagPtr);
+   if (IPC_Abort) IPC_Do_Abort();
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Set_CWD_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str FileName;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Str(IPC_AbortPtr, FileName);
+   if (*IPC_AbortPtr) return;
+   Local_Set_CWD(FileName);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Push_Context_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str DirName;
+   tps_Str FileName;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Str(IPC_AbortPtr, FileName);
+   if (*IPC_AbortPtr) return;
+   Local_Push_Context(DirName, FileName);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+   IPC_Write_Str(IPC_AbortPtr, DirName);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Pop_Context_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str DirName;
+
+   *IPC_AbortPtr = FALSE;
+   Local_Pop_Context(DirName);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+   IPC_Write_Str(IPC_AbortPtr, DirName);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Set_KeepGoing_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   int Flag;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Int(IPC_AbortPtr, &Flag);
+   if (*IPC_AbortPtr) return;
+   Local_Set_KeepGoing(Flag);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Set_ErrLevel_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   int ErrLevel;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Int(IPC_AbortPtr, &ErrLevel);
+   if (*IPC_AbortPtr) return;
+   Local_Set_ErrLevel(ErrLevel);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Set_WarnLevel_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   int WarnLevel;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Int(IPC_AbortPtr, &WarnLevel);
+   if (*IPC_AbortPtr) return;
+   Local_Set_WarnLevel(WarnLevel);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Set_LogLevel_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   int LogLevel;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Int(IPC_AbortPtr, &LogLevel);
+   if (*IPC_AbortPtr) return;
+   Local_Set_LogLevel(LogLevel);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Set_HelpLevel_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   int HelpLevel;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Int(IPC_AbortPtr, &HelpLevel);
+   if (*IPC_AbortPtr) return;
+   Local_Set_HelpLevel(HelpLevel);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Set_Debug_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str DebugName;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Str(IPC_AbortPtr, DebugName);
+   if (*IPC_AbortPtr) return;
+   Local_Set_Debug(DebugName);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Set_MaxJobs_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   int MaxJobs;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Int(IPC_AbortPtr, &MaxJobs);
+   if (*IPC_AbortPtr) return;
+   Local_Set_MaxJobs(MaxJobs);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Redo_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str OdinExpr;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Str(IPC_AbortPtr, OdinExpr);
+   if (*IPC_AbortPtr) return;
+   Local_Redo(OdinExpr);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+OdinExpr_ID_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   int IDPtr;
+   tps_Str OdinExpr;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Str(IPC_AbortPtr, OdinExpr);
+   if (*IPC_AbortPtr) return;
+   Local_OdinExpr_ID(&IDPtr, OdinExpr);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+   IPC_Write_Int(IPC_AbortPtr, IDPtr);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+ID_OdinExpr_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str OdinExpr;
+   int ID;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Int(IPC_AbortPtr, &ID);
+   if (*IPC_AbortPtr) return;
+   Local_ID_OdinExpr(OdinExpr, ID);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+   IPC_Write_Str(IPC_AbortPtr, OdinExpr);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+ID_LongOdinExpr_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str OdinExpr;
+   int ID;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Int(IPC_AbortPtr, &ID);
+   if (*IPC_AbortPtr) return;
+   Local_ID_LongOdinExpr(OdinExpr, ID);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+   IPC_Write_Str(IPC_AbortPtr, OdinExpr);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Get_Status_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   int StatusPtr;
+   int ElmStatusPtr;
+   int ID;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Int(IPC_AbortPtr, &ID);
+   if (*IPC_AbortPtr) return;
+   Local_Get_Status(&StatusPtr, &ElmStatusPtr, ID);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+   IPC_Write_Int(IPC_AbortPtr, StatusPtr);
+   if (*IPC_AbortPtr) return;
+   IPC_Write_Int(IPC_AbortPtr, ElmStatusPtr);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Get_Elements_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   int ID;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Int(IPC_AbortPtr, &ID);
+   if (*IPC_AbortPtr) return;
+   Local_Get_Elements(ID);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Get_ElementsOf_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   int ID;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Int(IPC_AbortPtr, &ID);
+   if (*IPC_AbortPtr) return;
+   Local_Get_ElementsOf(ID);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Get_Inputs_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   int ID;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Int(IPC_AbortPtr, &ID);
+   if (*IPC_AbortPtr) return;
+   Local_Get_Inputs(ID);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Get_Outputs_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   int ID;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Int(IPC_AbortPtr, &ID);
+   if (*IPC_AbortPtr) return;
+   Local_Get_Outputs(ID);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+
+#ifndef CLIENT_ONLY
+static void
+Get_DPath_Msg(
+   boolean*  IPC_AbortPtr
+   )
+   
+{
+   tps_Str OdinExpr;
+
+   *IPC_AbortPtr = FALSE;
+   IPC_Read_Str(IPC_AbortPtr, OdinExpr);
+   if (*IPC_AbortPtr) return;
+   Local_Get_DPath(OdinExpr);
+   IPC_Write_Int(IPC_AbortPtr, 1);
+   if (*IPC_AbortPtr) return;
+}
+#endif
+void
+IPC_Do_Msg(
+   boolean*  IPC_AbortPtr,
+   int  MsgType
+   )
+   
+   
+{
+   switch (MsgType) {
+      case 1: {
+         IPC_Do_Return = TRUE;
+         *IPC_AbortPtr = FALSE;
+         break; }
+      case 2: {
+#ifndef SERVER_ONLY
+         Add_BuildArg_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 3: {
+#ifndef SERVER_ONLY
+         Do_Build_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 4: {
+#ifndef SERVER_ONLY
+         Abort_Build_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 5: {
+#ifndef SERVER_ONLY
+         Do_MakeReadOnly_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 6: {
+#ifndef SERVER_ONLY
+         ErrMessage_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 7: {
+#ifndef SERVER_ONLY
+         LogMessage_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 8: {
+#ifndef SERVER_ONLY
+         FileErrMessage_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 9: {
+#ifndef SERVER_ONLY
+         Next_OdinFile_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 10: {
+#ifndef CLIENT_ONLY
+         Get_UseCount_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 11: {
+#ifndef CLIENT_ONLY
+         Get_CurSize_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 12: {
+#ifndef CLIENT_ONLY
+         ShutDown_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 13: {
+#ifndef CLIENT_ONLY
+         Get_Banner_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 14: {
+#ifndef CLIENT_ONLY
+         Do_Interrupt_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 15: {
+#ifndef CLIENT_ONLY
+         Do_Alias_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 16: {
+#ifndef CLIENT_ONLY
+         Get_Alias_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 17: {
+#ifndef CLIENT_ONLY
+         Job_Done_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 18: {
+#ifndef CLIENT_ONLY
+         Test_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 19: {
+#ifndef CLIENT_ONLY
+         Test_All_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 20: {
+#ifndef CLIENT_ONLY
+         Get_OdinFile_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 21: {
+#ifndef CLIENT_ONLY
+         Set_CWD_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 22: {
+#ifndef CLIENT_ONLY
+         Push_Context_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 23: {
+#ifndef CLIENT_ONLY
+         Pop_Context_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 24: {
+#ifndef CLIENT_ONLY
+         Set_KeepGoing_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 25: {
+#ifndef CLIENT_ONLY
+         Set_ErrLevel_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 26: {
+#ifndef CLIENT_ONLY
+         Set_WarnLevel_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 27: {
+#ifndef CLIENT_ONLY
+         Set_LogLevel_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 28: {
+#ifndef CLIENT_ONLY
+         Set_HelpLevel_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 29: {
+#ifndef CLIENT_ONLY
+         Set_Debug_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 30: {
+#ifndef CLIENT_ONLY
+         Set_MaxJobs_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 31: {
+#ifndef CLIENT_ONLY
+         Redo_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 32: {
+#ifndef CLIENT_ONLY
+         OdinExpr_ID_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 33: {
+#ifndef CLIENT_ONLY
+         ID_OdinExpr_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 34: {
+#ifndef CLIENT_ONLY
+         ID_LongOdinExpr_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 35: {
+#ifndef CLIENT_ONLY
+         Get_Status_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 36: {
+#ifndef CLIENT_ONLY
+         Get_Elements_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 37: {
+#ifndef CLIENT_ONLY
+         Get_ElementsOf_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 38: {
+#ifndef CLIENT_ONLY
+         Get_Inputs_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 39: {
+#ifndef CLIENT_ONLY
+         Get_Outputs_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      case 40: {
+#ifndef CLIENT_ONLY
+         Get_DPath_Msg(IPC_AbortPtr);
+#else
+         *IPC_AbortPtr = TRUE;
+#endif
+         break; }
+      default: {
+         FATALERROR("Unexpected message type"); }}
+   }
diff -ruNx autom4te.cache -x 'config*' pkg/odin/boot/stub-out.c pkg/odin/boot/stub-out.c
--- pkg/odin/boot/stub-out.c	1969-12-31 18:00:00.000000000 -0600
+++ pkg/odin/boot/stub-out.c	2016-09-08 11:04:03.717628597 -0500
@@ -0,0 +1,1119 @@
+#include "inc/GMC.h"
+
+extern boolean IPC_Do_Return;
+extern int *IPC_IArg1, *IPC_IArg2, *IPC_IArg3;
+extern tp_Str IPC_SArg1, IPC_SArg2, IPC_SArg3;
+
+#ifndef CLIENT_ONLY
+void
+Add_BuildArg(
+   tp_FileName FileName
+   )
+{
+   boolean IPC_Abort;
+
+#ifndef SERVER_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Add_BuildArg(FileName);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 2);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, FileName);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef SERVER_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef CLIENT_ONLY
+void
+Do_Build(
+   tp_JobID JobID,
+   tp_FileName JobDirName,
+   tp_FileName LogFileName
+   )
+{
+   boolean IPC_Abort;
+
+#ifndef SERVER_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Do_Build(JobID, JobDirName, LogFileName);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 3);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, JobID);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, JobDirName);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, LogFileName);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef SERVER_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef CLIENT_ONLY
+void
+Abort_Build(
+   tp_JobID JobID
+   )
+{
+   boolean IPC_Abort;
+
+#ifndef SERVER_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Abort_Build(JobID);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 4);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, JobID);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef SERVER_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef CLIENT_ONLY
+void
+Do_MakeReadOnly(
+   tp_FileName FileName
+   )
+{
+   boolean IPC_Abort;
+
+#ifndef SERVER_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Do_MakeReadOnly(FileName);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 5);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, FileName);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef SERVER_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef CLIENT_ONLY
+void
+ErrMessage(
+   char* Message
+   )
+{
+   boolean IPC_Abort;
+
+#ifndef SERVER_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_ErrMessage(Message);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 6);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, Message);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef SERVER_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef CLIENT_ONLY
+void
+LogMessage(
+   char* Message
+   )
+{
+   boolean IPC_Abort;
+
+#ifndef SERVER_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_LogMessage(Message);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 7);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, Message);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef SERVER_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef CLIENT_ONLY
+void
+FileErrMessage(
+   tp_FileName FileName
+   )
+{
+   boolean IPC_Abort;
+
+#ifndef SERVER_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_FileErrMessage(FileName);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 8);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, FileName);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef SERVER_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef CLIENT_ONLY
+void
+Next_OdinFile(
+   tp_Str OdinExpr,
+   int ID
+   )
+{
+   boolean IPC_Abort;
+
+#ifndef SERVER_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Next_OdinFile(OdinExpr, ID);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 9);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, OdinExpr);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, ID);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef SERVER_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Get_UseCount(
+   int* CountPtr
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Get_UseCount(CountPtr);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 10);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+   IPC_Read_Int(&IPC_Abort, CountPtr);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Get_CurSize(
+   int* SizePtr
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Get_CurSize(SizePtr);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 11);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+   IPC_Read_Int(&IPC_Abort, SizePtr);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+ShutDown(void)
+{
+   boolean IPC_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_ShutDown();
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 12);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Get_Banner(
+   tp_Str Str
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Get_Banner(Str);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 13);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+   IPC_Read_Str(&IPC_Abort, Str);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Do_Interrupt(
+   boolean InterruptFlag
+   )
+{
+   boolean IPC_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Do_Interrupt(InterruptFlag);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 14);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, InterruptFlag);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Do_Alias(
+   tp_FileName FileName,
+   boolean ForceFlag
+   )
+{
+   boolean IPC_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Do_Alias(FileName, ForceFlag);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 15);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, FileName);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, ForceFlag);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Get_Alias(
+   tp_FileName OutFileName,
+   tp_FileName FileName
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Get_Alias(OutFileName, FileName);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 16);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, FileName);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+   IPC_Read_Str(&IPC_Abort, OutFileName);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Job_Done(
+   tp_JobID JobID,
+   boolean Abort
+   )
+{
+   boolean IPC_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Job_Done(JobID, Abort);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 17);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, JobID);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, Abort);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Test(
+   tp_FileName FileName
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Test(FileName);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 18);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, FileName);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Test_All(void)
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Test_All();
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 19);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Get_OdinFile(
+   tp_FileName FileName,
+   tp_Status* StatusPtr,
+   boolean* ExecFlagPtr,
+   tp_Str OdinExpr,
+   boolean NeedsData
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      FORBIDDEN(IPC_Do_Return);
+      FORBIDDEN(IPC_SArg1 != NIL);
+      IPC_SArg1 = FileName;
+      FORBIDDEN(IPC_IArg2 != NIL);
+      IPC_IArg2 = StatusPtr;
+      FORBIDDEN(IPC_IArg3 != NIL);
+      IPC_IArg3 = ExecFlagPtr;
+      Local_Get_OdinFile(OdinExpr, NeedsData);
+      if (!IPC_Do_Return) {
+         IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+         FORBIDDEN(IPC_Cmd_Abort);
+         FORBIDDEN(!IPC_Do_Return); }
+      IPC_Do_Return = FALSE;
+      IPC_SArg1 = NIL;
+      IPC_IArg2 = NIL;
+      IPC_IArg3 = NIL;
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 20);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, OdinExpr);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, NeedsData);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+   IPC_Read_Str(&IPC_Abort, FileName);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Read_Int(&IPC_Abort, StatusPtr);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Read_Int(&IPC_Abort, ExecFlagPtr);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Set_CWD(
+   tp_FileName FileName
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Set_CWD(FileName);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 21);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, FileName);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Push_Context(
+   tp_FileName DirName,
+   tp_FileName FileName
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Push_Context(DirName, FileName);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 22);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, FileName);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+   IPC_Read_Str(&IPC_Abort, DirName);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Pop_Context(
+   tp_FileName DirName
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Pop_Context(DirName);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 23);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+   IPC_Read_Str(&IPC_Abort, DirName);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Set_KeepGoing(
+   int Flag
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Set_KeepGoing(Flag);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 24);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, Flag);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Set_ErrLevel(
+   int ErrLevel
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Set_ErrLevel(ErrLevel);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 25);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, ErrLevel);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Set_WarnLevel(
+   int WarnLevel
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Set_WarnLevel(WarnLevel);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 26);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, WarnLevel);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Set_LogLevel(
+   tp_LogLevel LogLevel
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Set_LogLevel(LogLevel);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 27);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, LogLevel);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Set_HelpLevel(
+   int HelpLevel
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Set_HelpLevel(HelpLevel);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 28);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, HelpLevel);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Set_Debug(
+   tp_Str DebugName
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Set_Debug(DebugName);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 29);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, DebugName);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Set_MaxJobs(
+   int MaxJobs
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Set_MaxJobs(MaxJobs);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 30);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, MaxJobs);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Redo(
+   tp_Str OdinExpr
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Redo(OdinExpr);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 31);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, OdinExpr);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+OdinExpr_ID(
+   int* IDPtr,
+   tp_Str OdinExpr
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_OdinExpr_ID(IDPtr, OdinExpr);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 32);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, OdinExpr);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+   IPC_Read_Int(&IPC_Abort, IDPtr);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+ID_OdinExpr(
+   tp_Str OdinExpr,
+   int ID
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_ID_OdinExpr(OdinExpr, ID);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 33);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, ID);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+   IPC_Read_Str(&IPC_Abort, OdinExpr);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+ID_LongOdinExpr(
+   tp_Str OdinExpr,
+   int ID
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_ID_LongOdinExpr(OdinExpr, ID);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 34);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, ID);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+   IPC_Read_Str(&IPC_Abort, OdinExpr);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Get_Status(
+   tp_Status* StatusPtr,
+   tp_Status* ElmStatusPtr,
+   int ID
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Get_Status(StatusPtr, ElmStatusPtr, ID);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 35);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, ID);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+   IPC_Read_Int(&IPC_Abort, StatusPtr);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Read_Int(&IPC_Abort, ElmStatusPtr);
+   if (IPC_Abort) IPC_Do_Abort();
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Get_Elements(
+   int ID
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Get_Elements(ID);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 36);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, ID);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Get_ElementsOf(
+   int ID
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Get_ElementsOf(ID);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 37);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, ID);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Get_Inputs(
+   int ID
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Get_Inputs(ID);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 38);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, ID);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Get_Outputs(
+   int ID
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Get_Outputs(ID);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 39);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Int(&IPC_Abort, ID);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
+
+#ifndef SERVER_ONLY
+void
+Get_DPath(
+   tp_Str OdinExpr
+   )
+{
+   boolean IPC_Abort;
+
+   boolean IPC_Cmd_Abort;
+
+#ifndef CLIENT_ONLY
+   if (IsServer && Is_LocalClient(CurrentClient)) {
+      Local_Get_DPath(OdinExpr);
+   }else{
+#endif
+   IPC_Write_Int(&IPC_Abort, 40);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Write_Str(&IPC_Abort, OdinExpr);
+   if (IPC_Abort) IPC_Do_Abort();
+   IPC_Get_Commands(&IPC_Cmd_Abort, (char *)NIL);
+   FORBIDDEN(IPC_Cmd_Abort);
+   FORBIDDEN(!IPC_Do_Return);
+   IPC_Do_Return = FALSE;
+#ifndef CLIENT_ONLY
+   }
+#endif
+   }
+#endif
diff -ruNx autom4te.cache -x 'config*' pkg/odin/inc/odin_builtin.lua.h pkg/odin/inc/odin_builtin.lua.h
--- pkg/odin/inc/odin_builtin.lua.h	1969-12-31 18:00:00.000000000 -0600
+++ pkg/odin/inc/odin_builtin.lua.h	2016-09-08 11:04:06.583592567 -0500
@@ -0,0 +1,839 @@
+"-- GLib provides portable setenv, basename, and others\n"
+"glib = require 'glib'\n"
+"\n"
+"-- some convenient aliases for often-used functions\n"
+"\n"
+"pathcat = glib.build_filename\n"
+"getcwd = glib.get_current_dir\n"
+"chdir = glib.chdir\n"
+"mkdir = glib.mkdir_with_parents\n"
+"mv = glib.rename\n"
+"exists = glib.exists\n"
+"is_dir = glib.is_dir\n"
+"is_file = glib.is_file\n"
+"is_exec = glib.is_exec\n"
+"is_link = glib.is_symlink\n"
+"\n"
+"-- 5.2 compatibility\n"
+"if unpack == nil then unpack = table.unpack end\n"
+"\n"
+"--- inverse of pathcat\n"
+"dir_separator_charclass = '[' .. glib.regex_escape_string(glib.dir_separator) .. ']'\n"
+"dir_separator_regex = glib.regex_new(dir_separator_charclass)\n"
+"dir_separator_all_regex = glib.regex_new('^' .. dir_separator_charclass .. '+$')\n"
+"--dir_separator_end_regex = glib.regex_new('^((?!' ..  dir_separator_charclass .. ').*?)' ..\n"
+"--					dir_separator_charclass .. '+$')\n"
+"function split_filename(f)\n"
+"   local res = {}\n"
+"   local r\n"
+"   r, f = glib.path_split_root(f)\n"
+"   if r and dir_separator_all_regex:match(r) then\n"
+"      r = glib.dir_separator:sub(1, 1)\n"
+"   end\n"
+"   -- not sure if trimming trailing dir_separators from r is safe, so don't.\n"
+"   -- if r then dir_separator_end_regex:gsub(r, '\\\\1') end\n"
+"   local i, e, laste\n"
+"   for i, e in ipairs(dir_separator_regex:split(f)) do\n"
+"      if e ~= '' then table.insert(res, e) end\n"
+"      laste = e \n"
+"   end\n"
+"   if laste == '' then table.insert(res, '') end\n"
+"   return r, res\n"
+"end\n"
+"\n"
+"-- split/merge path lists\n"
+"function build_path(a1, ...)\n"
+"   local i, v\n"
+"   local ret = ''\n"
+"   local p\n"
+"   if type(a1) == 'table' then\n"
+"      p = a1\n"
+"   else\n"
+"      p = {a1, ...}\n"
+"   end\n"
+"   local sep = glib.searchpath_separator\n"
+"   for i, v in ipairs(p) do\n"
+"      if i > 1 then ret = ret .. sep end\n"
+"      ret = ret .. v\n"
+"   end\n"
+"   return ret\n"
+"end\n"
+"\n"
+"function split_path(p)\n"
+"    return glib.regex_new(glib.regex_escape_string(glib.searchpath_separator)):split(p)\n"
+"end\n"
+"\n"
+"function glob_to_regex(g)\n"
+"   local escall = glib.regex_escape_string(g)\n"
+"   local s, e, pos, re, brnest, brloc, skip, com, incc\n"
+"   local dirsep = glib.regex_escape_string(glib.dir_separator)\n"
+"   pos = 1\n"
+"   re = ''\n"
+"   brnest = 0\n"
+"   com = {}\n"
+"   brloc = {}\n"
+"   for s, e, what in glib.regex_new('\\\\\\\\(.)'):gfind(escall) do\n"
+"      if s > pos then\n"
+"	 local unesc = escall:sub(pos, s - 1)\n"
+"	 if brnest > 0 then\n"
+"	    local anycom\n"
+"	    if skip then\n"
+"	       local comsub\n"
+"	       comsub, anycom = unesc:sub(2):gsub(',', '|')\n"
+"	       unesc = unesc:sub(1, 1) .. comsub\n"
+"	    else\n"
+"	       unesc, anycom = unesc:gsub(',', '|')\n"
+"	    end\n"
+"	    com[brnest] = com[brnest] + anycom\n"
+"	 end\n"
+"	 re = re .. unesc\n"
+"	 skip = false\n"
+"      end\n"
+"      pos = e + 1\n"
+"      if skip then\n"
+"	 skip = false\n"
+"      elseif not incc and what == '*' then\n"
+"	 re = re .. '[^' .. dirsep .. ']*'\n"
+"      elseif not incc and what == '?' then\n"
+"	 re = re .. '[^' .. dirsep .. ']'\n"
+"      elseif not incc and what == '[' then\n"
+"	 re = re .. '(?![' .. dirsep .. '])['\n"
+"	 incc = true\n"
+"      elseif what == ']' then\n"
+"	 re = re .. what\n"
+"	 incc = false\n"
+"      elseif not incc and what == '{' then\n"
+"	 brnest = brnest + 1\n"
+"	 com[brnest] = 0\n"
+"	 brloc[brnest] = #re\n"
+"	 re = re .. '(?:'\n"
+"      elseif not incc and brnest > 0 and what == '}' then\n"
+"	 if com[brnest] == 0 then\n"
+"	    re = re:sub(1, brloc[brnest]) .. '\\\\{' .. re:sub(brloc[brnest] + 4)\n"
+"	    re = re .. '\\\\}'\n"
+"	 else\n"
+"	    re = re .. ')'\n"
+"	 end\n"
+"	 brnest = brnest - 1\n"
+"      else\n"
+"	 re = re .. '\\\\' .. what\n"
+"      end\n"
+"   end\n"
+"   re = re .. escall:sub(pos)\n"
+"   while brnest > 0 do\n"
+"      re = re:sub(1, brloc[brnest]) .. '\\\\{' .. re:sub(brloc[brnest] + 4)\n"
+"      brnest = brnest - 1\n"
+"   end\n"
+"   -- let regex library detect mismatched []\n"
+"   return '^' .. re .. '$'\n"
+"end\n"
+"\n"
+"-- this only applies a pattern to files in one directory\n"
+"function dir_regex(dir, regex)\n"
+"   if regex == nil then\n"
+"      regex = dir\n"
+"      dir = glib.get_current_dir()\n"
+"   end\n"
+"   if type(regex) == 'string' then\n"
+"      local cf\n"
+"      if glib.os ~= 'unix' then\n"
+"	 -- probably unsafe to assume all non-UNIX are insensitive\n"
+"	 -- but how else can it be determined w/o running tests?\n"
+"	 cf = {'caseless'}\n"
+"      end\n"
+"      local msg\n"
+"      regex, msg = glib.regex_new(regex, cf)\n"
+"      if not regex then\n"
+"	 return function() return nil end\n"
+"      end\n"
+"   end\n"
+"   local d = glib.dir(dir)\n"
+"   return function()\n"
+"      while true do\n"
+"	 local n = d()\n"
+"	 if n == nil then return nil end\n"
+"	 if regex:find(n) then\n"
+"	    return n\n"
+"	 end\n"
+"      end\n"
+"   end\n"
+"end\n"
+"\n"
+"-- this only applies a pattern to files in one directory\n"
+"function dir_glob(dir, glob)\n"
+"   if glob == nil then\n"
+"      glob = dir\n"
+"      dir = glib.get_current_dir()\n"
+"   end\n"
+"   return dir_regex(dir, glob_to_regex(glob))\n"
+"end\n"
+"\n"
+"-- this only works for relative paths, but allows pat to have directory\n"
+"-- separators\n"
+"-- there is no way to do absolute path patterns on Windows in any sane\n"
+"-- portable manner\n"
+"-- also, it's too much trouble to efficiently handle non-glob path elements\n"
+"-- properly (i.e., access them directly instead of scanning the directory)\n"
+"function relative_glob(path, pat)\n"
+"   if not pat then\n"
+"      pat = path\n"
+"      path = glib.get_current_dir()\n"
+"   end\n"
+"   local cf\n"
+"   if glib.os ~= 'unix' then\n"
+"      -- probably unsafe to assume all non-UNIX are insensitive\n"
+"      -- but how else can it be determined w/o running tests?\n"
+"      cf = {'caseless'}\n"
+"   end\n"
+"   local rx = glib.regex_new(glob_to_regex(pat), cf, {'partial'})\n"
+"   return coroutine.wrap(function()\n"
+"      local function process_dir(p, match)\n"
+"         local de\n"
+"	 local di = glib.dir(p)\n"
+"	 if di then\n"
+"	    for de in di do\n"
+"	       local fm\n"
+"	       if match then fm = pathcat(match, de) else fm = de end\n"
+"	       local m = rx:find(fm)\n"
+"	       if m then coroutine.yield(fm) end\n"
+"	       if m ~= nil and rx:find(fm .. glib.dir_separator:sub(1,1)) ~= nil then\n"
+"		  process_dir(pathcat(p, de), fm)\n"
+"	       end\n"
+"	    end\n"
+"	 end\n"
+"      end\n"
+"      process_dir(path, nil)\n"
+"   end)\n"
+"end\n"
+"\n"
+"-- just expand curly braces in a shell-like manner\n"
+"function shell_expand_braces(pat)\n"
+"   local s\n"
+"   local pref = {''}\n"
+"   local entries = {{}}\n"
+"   local com = {{0}}\n"
+"   local nest = 1\n"
+"   local o, c\n"
+"   -- for each brace or comma, and its preceeding text...\n"
+"   for o, c in glib.regex_new('((?:[^\\\\\\\\{},[]|\\\\\\\\.|\\\\[(?:[^\\\\\\\\\\\\]]|\\\\\\\\.)*\\\\])*)' ..\n"
+"			      '([{},])'):gmatch(pat) do\n"
+"      if c == '{' then\n"
+"	 -- open brace: save prefix and start a new group\n"
+"	 nest = nest + 1\n"
+"	 entries[nest] = {}\n"
+"	 pref[nest] = o\n"
+"	 com[nest] = {0}\n"
+"      elseif nest > 1 and c == ',' then\n"
+"	 -- comma: tack prefix to any text accumulated for this group\n"
+"	 -- entry so far.  This may be nothing, or more than one entry if\n"
+"	 -- it contained nested brace expansion\n"
+"	 local ocom = com[nest][1]\n"
+"	 local ent = entries[nest]\n"
+"	 local nent = #ent\n"
+"	 if ocom ~= nent then\n"
+"	    local i\n"
+"	    for i = ocom + 1, nent do\n"
+"	       ent[i] = ent[i] .. o\n"
+"	    end\n"
+"	 else\n"
+"	    nent = nent + 1\n"
+"	    ent[ocom + 1] = o\n"
+"	 end\n"
+"	 table.insert(com[nest], 1, nent)\n"
+"      elseif nest > 1 and c == '}' then\n"
+"	 -- end brace: tack prefix to any text accumulated for this group\n"
+"	 -- entry so far.  This may be nothing, or more than one entry if\n"
+"	 -- it contained nested brace expansion\n"
+"	 local ocom = com[nest][1]\n"
+"	 local ent = entries[nest]\n"
+"	 local nent = #ent\n"
+"	 local i\n"
+"	 if ocom ~= nent then\n"
+"	    for i = ocom + 1, nent do\n"
+"	       ent[i] = ent[i] .. o\n"
+"	    end\n"
+"	 else\n"
+"	    nent = nent + 1\n"
+"	    ent[ocom + 1] = o\n"
+"	 end\n"
+"	 -- if there were no commas, restore open and close brace for all\n"
+"	 -- text so far (due to above, at least one piece exists)\n"
+"	 if ocom == 0 then\n"
+"	    for i = 1, nent do\n"
+"	       ent[i] = '{' .. ent[i] .. '}'\n"
+"	    end\n"
+"	 end\n"
+"	 -- now, prefix all text with {'s prefix and then append to\n"
+"	 -- all elements in parent group entry\n"
+"	 local pre = pref[nest]\n"
+"	 -- for easier debugging, clear out no-long-needed entries\n"
+"	 entries[nest] = nil\n"
+"	 pref[nest] = nil\n"
+"	 com[nest] = nil\n"
+"	 nest = nest - 1\n"
+"	 local oent = entries[nest]\n"
+"	 ocom = com[nest][1] + 1\n"
+"	 local noent = #oent\n"
+"	 if noent < ocom then\n"
+"	    noent = noent + 1\n"
+"	    oent[noent] = ''\n"
+"	 end\n"
+"	 for i = ocom, noent do\n"
+"	    local j\n"
+"	    local otxt = oent[ocom] .. pre\n"
+"	    table.remove(oent, ocom)\n"
+"	    for j = 1, nent do\n"
+"	       table.insert(oent, otxt .. ent[j])\n"
+"	    end\n"
+"	 end\n"
+"      end\n"
+"   end\n"
+"   -- now deal with unmatched open braces\n"
+"   while nest > 1 do\n"
+"      local ent = entries[nest]\n"
+"      local nent = #ent\n"
+"      local i\n"
+"      local ocom = com[nest]\n"
+"      local ncom = #ocom - 1\n"
+"      -- prepend stripped { and its prefix\n"
+"      local pre = pref[nest] .. '{'\n"
+"      if ncom > 0 then\n"
+"	 -- for comma entries, also tack on stripped comma\n"
+"	 for i = 1, ocom[ncom] do\n"
+"	    ent[i] = pre .. ent[i] .. ','\n"
+"	 end\n"
+"	 for i = ocom[ncom] + 1, ocom[1] do\n"
+"	    ent[i] = ent[i] .. ','\n"
+"	 end\n"
+"	 -- next, merge comma groups\n"
+"	 for i = 1, ncom do\n"
+"	    local j, j1, k, k1, km\n"
+"	    j1 = ocom[i + 1] + 1\n"
+"	    k1 = ocom[i] + 1\n"
+"	    km = #ent\n"
+"	    -- create new last group by merging all text in\n"
+"	    -- 2nd-to-last group (j1 .. k1 - 1) with last group (k1 .. km)\n"
+"	    -- at same time, remove 2nd-to-last group\n"
+"	    if km >= k1 then\n"
+"	       for j = j1, ocom[i] do\n"
+"		  for k = k1, km do\n"
+"		     table.insert(ent, ent[j1] .. ent[k])\n"
+"		  end\n"
+"		  table.remove(ent, j1)\n"
+"		  k1 = k1 - 1\n"
+"		  km = km - 1\n"
+"	       end\n"
+"	       -- remove old last group\n"
+"	       for k = k1, km do\n"
+"		  table.remove(ent, k1)\n"
+"	       end\n"
+"	    end\n"
+"	 end\n"
+"      elseif nent > 0 then\n"
+"	 for i = 1, nent do\n"
+"	    ent[i] = pre .. ent[i]\n"
+"	 end\n"
+"      else\n"
+"	 ent[1] = pre\n"
+"      end\n"
+"      -- now that all commas and braces are restored, merge with parent as\n"
+"      -- if a close brace had occurred (but ignore prefix, since it's already\n"
+"      -- been merged)\n"
+"      entries[nest] = nil\n"
+"      pref[nest] = nil\n"
+"      com[nest] = nil\n"
+"      nest = nest - 1\n"
+"      local oent = entries[nest]\n"
+"      ocom = com[nest][1] + 1\n"
+"      local noent = #oent\n"
+"      if noent < ocom then\n"
+"	 noent = noent + 1\n"
+"	 oent[noent] = ''\n"
+"      end\n"
+"      for i = ocom, noent do\n"
+"	 local j\n"
+"	 local otxt = oent[ocom]\n"
+"	 table.remove(oent, ocom)\n"
+"	 for j = 1, #ent do\n"
+"	    table.insert(oent, otxt .. ent[j])\n"
+"	 end\n"
+"      end\n"
+"   end\n"
+"   -- finally, append any non-brace text at end to all entries and return\n"
+"   local app = glib.regex_new('(?:[^\\\\\\\\{},[]|\\\\\\\\.|\\\\[(?:[^\\\\\\\\\\\\]]|\\\\\\\\.)*\\\\])*$'):match(pat)\n"
+"   local ret = entries[1]\n"
+"   if #ret == 0 then\n"
+"      ret = {app}\n"
+"   else\n"
+"      local i\n"
+"      for i = 1, #ret do\n"
+"	 ret[i] = ret[i] .. app\n"
+"      end\n"
+"   end\n"
+"   return ret\n"
+"end	 \n"
+"	    \n"
+"\n"
+"-- here's one way to handle the const path issue: split off paths until a\n"
+"-- potentially special char is found.  No special chars are allowed in\n"
+"-- the \"root\" prefix (not enforced, but it won't work otherwise).\n"
+"-- note that although it expands the braces shell-like, it still rejects\n"
+"-- non-glob paths that do not exist\n"
+"function glob(pat)\n"
+"   local ent = shell_expand_braces(pat)\n"
+"   local i, v\n"
+"   return coroutine.wrap(function()\n"
+"      for i, v in ipairs(ent) do\n"
+"	 local s = 1\n"
+"	 while true do\n"
+"	    s = v:find('[*?{}%[%]\\\\]', s)\n"
+"	    if not s or v:sub(s, s) ~= '\\\\' then break end\n"
+"	    s = s + 2\n"
+"	 end\n"
+"	 if not s then\n"
+"	    if exists(v) then\n"
+"	       coroutine.yield(v)\n"
+"	    end\n"
+"	 else\n"
+"	    local const = v:sub(1, s - 1):gsub('\\\\(.)', '%1')\n"
+"	    local dir = glib.path_get_dirname(const)\n"
+"	    local de\n"
+"	    local var\n"
+"	    if v:sub(s - 1, s - 1):match(\"[\" .. glib.dir_separator .. \"]\") then\n"
+"	       var = v:sub(s)\n"
+"	    else\n"
+"	       var = basename(v:sub(1, s - 1)) .. v:sub(s)\n"
+"	    end\n"
+"	    for de in relative_glob(const, var) do\n"
+"	       coroutine.yield(pathcat(const, de))\n"
+"	    end\n"
+"	 end\n"
+"      end\n"
+"   end)\n"
+"end\n"
+"\n"
+"-- common uses of stat\n"
+"function is_empty(f)\n"
+"   local t, s = glib.stat(f, 'type', 'size')\n"
+"   return not t or (t == 'file' and s == 0)\n"
+"end\n"
+"\n"
+"-- recursive delete\n"
+"function rm(f)\n"
+"   local ok, msg, err, gmsg\n"
+"   if not is_link(f) and is_dir(f) then\n"
+"      local e\n"
+"      for e in glib.dir(f) do\n"
+"	 ok, msg = rm(pathcat(f, e))\n"
+"	 if not ok and not err then\n"
+"	    err = true\n"
+"	    gmsg = msg\n"
+"	 end\n"
+"      end\n"
+"   end\n"
+"   ok, msg = glib.remove(f)\n"
+"   if not ok and not err then\n"
+"      err = true\n"
+"      gmsg = msg\n"
+"   end\n"
+"   if err then\n"
+"      return false, gmsg\n"
+"   else\n"
+"      return true\n"
+"   end\n"
+"end\n"
+"\n"
+"-- touch the way it's supposed to be\n"
+"function touch(f, date)\n"
+"   if not exists(f) then\n"
+"      local fd = io.open(f, 'w')\n"
+"      if fd then fd:close() end\n"
+"   end\n"
+"   glib.utime(f, nil, date)\n"
+"end\n"
+"\n"
+"-- apr-style basename\n"
+"function basename(n, split)\n"
+"   local ret = glib.path_get_basename(n)\n"
+"   if not split then\n"
+"      return ret\n"
+"   end\n"
+"   return glib.regex_new('^(.+?)(|\\\\.[^.]*)$'):match(ret)\n"
+"end\n"
+"\n"
+"-- shell-style getenv: undef returns empty string\n"
+"-- that way you don't have to check for both blank and nil\n"
+"function getenv(v)\n"
+"   return glib.getenv(v) or ''\n"
+"end\n"
+"\n"
+"function setenv(name, val)\n"
+"   return glib.setenv(name, val, true)\n"
+"end\n"
+"\n"
+"-- for subsequent functions: return a file descriptor for file/name arg\n"
+"function fopen(f, mode)\n"
+"   if io.type(f) == 'file' then\n"
+"      return f\n"
+"   else\n"
+"      return io.open(f, mode)\n"
+"   end\n"
+"end\n"
+"\n"
+"-- close f if f was opened above\n"
+"function fclose(f, n)\n"
+"   if io.type(n) ~= 'file' and f ~= nil then\n"
+"      return f:close()\n"
+"   else\n"
+"      return true\n"
+"   end\n"
+"end\n"
+"\n"
+"local builtin_io_bufsize = 16384\n"
+"\n"
+"-- copy a file\n"
+"-- note that although Lua will eventually garbage collect files, it's\n"
+"-- better to close them as soon as possible\n"
+"function cp(src, dest, mode)\n"
+"   local s = fopen(src, 'rb')\n"
+"   if not s then\n"
+"      return false, \"Can't open \" .. src\n"
+"   end\n"
+"   local d = fopen(dest, 'wb')\n"
+"   if not d then\n"
+"      fclose(s, src)\n"
+"      return false, \"Can't open \" .. dest\n"
+"   end\n"
+"   local buf\n"
+"   while true do\n"
+"      buf = s:read(builtin_io_bufsize)\n"
+"      if not buf then break end\n"
+"      if not d:write(buf) then\n"
+"	 fclose(s, src)\n"
+"	 fclose(d, dest)\n"
+"	 return false, \"I/O error writing to \" .. tostring(dest)\n"
+"      end\n"
+"   end\n"
+"   fclose(s, src)\n"
+"   if not fclose(d, dest) then\n"
+"      return false, \"I/O error writing to \" .. tostring(dest)\n"
+"   end\n"
+"   if not mode and io.type(src) == 'file' then\n"
+"      mode = glib.stat(src, 'perm')\n"
+"   end\n"
+"   if mode and io.type(dest) ~= 'file' then\n"
+"      glib.chmod(dest, mode)\n"
+"   end\n"
+"   return true\n"
+"end\n"
+"\n"
+"-- recursive file comparison\n"
+"function cmp(f1, f2)\n"
+"   if is_dir(f1) then\n"
+"      if not is_dir(f2) then return false end\n"
+"      for p in glib.dir(f1) do\n"
+"	 if not cmp(pathcat(f1, p), pathcat(f2, p)) then\n"
+"	    return false\n"
+"	 end\n"
+"      end\n"
+"      for p in glib.dir(f2) do\n"
+"	 if not exists(pathcat(f1, p)) then\n"
+"	    return false\n"
+"	 end\n"
+"      end\n"
+"      return true\n"
+"   end\n"
+"   if not is_file(f1) or not is_file(f2) then\n"
+"      return false\n"
+"   end\n"
+"   local f1d, f2d\n"
+"   f1d = io.open(f1, 'rb')\n"
+"   f2d = io.open(f2, 'rb')\n"
+"   if not f1d or not f2d then return false end\n"
+"   local f1b, f2b\n"
+"   repeat\n"
+"      f1b = f1d:read(builtin_io_bufsize)\n"
+"      f2b = f2d:read(builtin_io_bufsize)\n"
+"   until f1b ~= f2b or f1b == nil\n"
+"   f1d:close()\n"
+"   f2d:close()\n"
+"   return f1b == f2b\n"
+"end\n"
+"\n"
+"-- recursive file copy (cp -RpL)\n"
+"-- note that specials (sockets, pipes, etc.) can't possibly be copied portably\n"
+"-- if plus_w is true, add user write permission\n"
+"-- if d_to_d is true, assume src and dest are existing directories\n"
+"-- returns true on success, or (nil, err) on error\n"
+"function cp_RpL(src, dest, plus_w, d_to_d)\n"
+"   local t, m\n"
+"   local st, msg\n"
+"   if not d_to_d then\n"
+"      -- this dereferences any link (-L)\n"
+"      local t, m = glib.stat(src, 'type', 'perm')\n"
+"      if plus_w then\n"
+"	 m = m + 128 -- 0200 == 2 * 8^2 == 2 * 64\n"
+"      end\n"
+"      if t == 'dir' then\n"
+"	 st, msg = mkdir(dest, m)\n"
+"	 if not st then\n"
+"	    return nil, \"Error writing \" .. dest .. \": \" .. msg\n"
+"	 end\n"
+"	 -- drop through to d_to_d code\n"
+"      elseif t == 'file' then\n"
+"	 st, msg = cp(src, dest, m)\n"
+"	 if not st then\n"
+"	    return nil, \"Error writing \" .. dest .. \": \" .. msg\n"
+"	 end\n"
+"	 return true\n"
+"      else\n"
+"	 return nil, 'Copy attempt on special ' .. src\n"
+"      end\n"
+"   end\n"
+"   local n\n"
+"   for n in glib.dir(src) do\n"
+"      local p = pathcat(src, n)\n"
+"      -- this dereferences any link (-L)\n"
+"      t, m = glib.stat(p, 'type', 'perm')\n"
+"      if plus_w then\n"
+"	 m = m + 128 -- 0200 == 2 * 8^2 == 2 * 64\n"
+"      end\n"
+"      local d = pathcat(dest, n)\n"
+"      if t == 'dir' then\n"
+"	 st, msg = mkdir(d, m)\n"
+"	 if not st then\n"
+"	    return nil, \"Error writing \" .. d .. \": \" .. msg\n"
+"	 end\n"
+"	 st, msg = cp_RpL(p, d, plus_w, true)\n"
+"	 if not st then return st, msg end\n"
+"      elseif t == 'file' then\n"
+"	 st, msg = cp(p, d, m)\n"
+"	 if not st then\n"
+"	    return nil, \"Error writing \" .. d .. \": \" .. msg\n"
+"	 end\n"
+"      else\n"
+"	 return nil, 'Copy attempt on special ' .. p\n"
+"      end\n"
+"   end\n"
+"   return true\n"
+"end\n"
+"\n"
+"-- there is no portable ln -s, so try hard link then copy\n"
+"function ln(s, d)\n"
+"   if not glib.link(s, d, true) and not glib.link(s, d, false) then\n"
+"      return cp_RpL(s, d)\n"
+"   end\n"
+"end\n"
+"\n"
+"-- shell-style backtick-cat-as-args: get words from file (iterator)\n"
+"-- could probably be improved by not sucking entire file into memory\n"
+"function words(fn)\n"
+"   local f = fopen(fn)\n"
+"   if not f then return nil end\n"
+"   local s = f:read('*a')\n"
+"   fclose(f, fn)\n"
+"   return s:gmatch('%S+')\n"
+"end\n"
+"\n"
+"-- shell-style backtick-cat-as args for making cmdline\n"
+"-- grab whole file, and collapse intervening spaces\n"
+"function wholefile(fn)\n"
+"   local f = fopen(fn)\n"
+"   if not f then return '' end\n"
+"   local s = f:read('*a'):gsub('%s+', ' '):gsub(' $', '')\n"
+"   fclose(f, fn)\n"
+"   return s\n"
+"end\n"
+"\n"
+"-- append a message plus a newline to a file\n"
+"function append_line(f, msg)\n"
+"    local fd = fopen(f, 'a')\n"
+"    if fd ~= nil then\n"
+"	fd:write(msg .. '\\n')\n"
+"    end\n"
+"    fclose(fd, f)\n"
+"end\n"
+"\n"
+"-- simple echo to error file (and maybe exit)\n"
+"function odin_error(msg, ret)\n"
+"    append_line(\"ERRORS\", msg)\n"
+"    if ret ~= nil then os.exit(ret) end\n"
+"end\n"
+"\n"
+"-- print a file to standard output without reading entire file into mem\n"
+"function cat(f)\n"
+"    local fd = fopen(f)\n"
+"    if fd ~= nil then\n"
+"	local s = fd:read(4096)\n"
+"	while s ~= nil do\n"
+"	    io.write(s)\n"
+"	    s = fd:read(4096)\n"
+"	end\n"
+"    end\n"
+"end\n"
+"\n"
+"-- running a command portably takes more effort\n"
+"-- than just building a string and passing it to execute\n"
+"-- plus there are common post-processing steps to do:\n"
+"--   write stderr to WARNINGS if return code == 0\n"
+"--   write stdout/stderr to ERRORS instead if return code ~= 0 (unless .ignret)\n"
+"-- cmd is parsed like shell, and moreargs[array] are appended\n"
+"-- moreargs also sets options:\n"
+"--  .ignret = true -> ignore return code (assume success)\n"
+"--  .chdir = <dir> -> change to <dir> before exec\n"
+"--  .stdout = <name> -> capture stdout in file <name>\n"
+"--  .stdin = <name> -> input from file <name>\n"
+"function runcmd(cmd, moreargs)\n"
+"   if moreargs == nil then moreargs = {} end\n"
+"   local args = glib.shell_parse_argv(cmd)\n"
+"   local i, v\n"
+"   for i,v in ipairs(moreargs) do table.insert(args, v) end\n"
+"   args.chdir = moreargs.chdir\n"
+"   args.stderr = 'WARNINGS'\n"
+"   args.stdout = 'MESSAGES'\n"
+"   args.stdin = moreargs.stdin\n"
+"   local ret, err\n"
+"--   io.write('running')\n"
+"--   for i, v in ipairs(args) do\n"
+"--       io.write(' ' .. glib.shell_quote(v))\n"
+"--   end\n"
+"   io.write('\\n')\n"
+"   ret, err = glib.spawn(args)\n"
+"   if ret then\n"
+"      ret = ret:wait()\n"
+"   else\n"
+"      append_line('WARNINGS', err)\n"
+"      ret = -1\n"
+"   end\n"
+"   if ret ~= 0 then\n"
+"      -- on error, merge all captured output into single 'ERRORS' file\n"
+"      local mf = io.open('MESSAGES', 'a')\n"
+"      cp('WARNINGS', mf)\n"
+"      mf:close()\n"
+"      rm('WARNINGS')\n"
+"      mv('MESSAGES', 'ERRORS')\n"
+"      odin_error(args[1] .. ' failed')\n"
+"   elseif moreargs.stdout then\n"
+"      if moreargs.stdout ~= 'MESSAGES' then\n"
+"	 mv('MESSAGES', moreargs.stdout)\n"
+"      end\n"
+"   else\n"
+"      cat('MESSAGES')\n"
+"      rm('MESSAGES')\n"
+"   end\n"
+"   -- reduce clutter a tiny bit\n"
+"   if is_empty('WARNINGS') then\n"
+"      rm('WARNINGS')\n"
+"   end\n"
+"   return ret\n"
+"end\n"
+"\n"
+"-- simplify logging messages\n"
+"ODINVERBOSE = getenv(\"ODINVERBOSE\") ~= \"\"\n"
+"ODINRBSHOST = getenv(\"ODINRBSHOST\")\n"
+"function odin_log(msg)\n"
+"    if ODINVERBOSE then\n"
+"	io.write(ODINRBSHOST .. msg .. '\\n')\n"
+"	io.flush()\n"
+"    end\n"
+"end\n"
+"\n"
+"-- for in-line +cmd strings\n"
+"-- e.g. +cmd='... trim([['(%files)']]) .... '\n"
+"function trim(s)\n"
+"    return s:gsub(\"^[\\t\\n ]*\", \"\"):gsub(\"[ \\t\\n]*$\", \"\")\n"
+"end\n"
+"\n"
+"-- return a string escaped as an Odin token\n"
+"function odin_quote(s)\n"
+"    return \"'\" .. s:gsub(\"'\", \"'\\\\''\") .. \"'\"\n"
+"end\n"
+"\n"
+"-- return a string with parts between slashes escaped\n"
+"function odin_quote_file(s, virt)\n"
+"    if virt then\n"
+"	return (s:gsub(\"[^/%]+\", odin_quote))\n"
+"    else\n"
+"	return (s:gsub(\"[^/]+\", odin_quote))\n"
+"    end\n"
+"end\n"
+"\n"
+"-- configuration support\n"
+"-- parse output from a configuration program as ldflags\n"
+"-- any options other than -L and -l are returned in +ld_flags\n"
+"function parse_ldflags(fl)\n"
+"    local a = glib.shell_parse_argv(fl)\n"
+"    local i, v, ret\n"
+"    ret = ''\n"
+"    for i, v in ipairs(a) do\n"
+"	if v:sub(1, 2) == 'L' then\n"
+"	    ret = ret .. \"+lib_sp=\" .. odin_quote(v:sub(3))\n"
+"	elseif v:sub(1, 2) == '-l' then\n"
+"	    ret = ret .. \"+lib=\" .. odin_quote(v:sub(3))\n"
+"	else\n"
+"	    ret = ret .. \"+ld_flags=\" .. odin_quote(v)\n"
+"	end\n"
+"    end\n"
+"    return ret\n"
+"end\n"
+"\n"
+"-- parse output from a configuration program as cflags\n"
+"-- any options other than -I and -D are returned in +cc_flags\n"
+"-- -O and -g are ignored\n"
+"function parse_cflags(fl)\n"
+"    local a = glib.shell_parse_argv(fl)\n"
+"    local i, v, ret\n"
+"    ret = ''\n"
+"    for i, v in ipairs(a) do\n"
+"	if v:sub(1, 2) == '-I' then\n"
+"	    ret = ret .. \"+inc_sp=\" .. odin_quote(v:sub(3))\n"
+"	elseif v:sub(1, 2) == '-D' then\n"
+"	    ret = ret .. \"+define=\" .. odin_quote(v:sub(3))\n"
+"	elseif v:sub(1, 2) ~= '-O' and v:sub(1, 2) ~= '-g' then\n"
+"	    ret = ret .. \"+cc_flags=\" .. odin_quote(v)\n"
+"	end\n"
+"    end\n"
+"    return ret\n"
+"end\n"
+"\n"
+"-- there is no portable way to find pkg-config, so just use an env var\n"
+"-- if not in path\n"
+"pkgconfig = getenv(\"PKGCONFIG\")\n"
+"if pkgconfig == '' then\n"
+"   pkgconfig = glib.find_program_in_path('pkg-config') or 'pkg-config'\n"
+"end\n"
+"\n"
+"-- run pkg-config for pkg; optionally requiring min/max version\n"
+"-- arg is usually --cflags or --libs\n"
+"function get_pkgconfig(arg, pkg, vermin, vermax)\n"
+"    local cmd = pkgconfig .. ' ' .. arg\n"
+"    if vermin then\n"
+"	cmd = cmd .. ' --atleast-version=' .. vermin\n"
+"    end\n"
+"    if vermax then\n"
+"	cmd = cmd .. ' --max-version=' .. vermax\n"
+"    end\n"
+"    cmd = cmd .. ' ' .. pkg\n"
+"    local p, msg = glib.spawn{cmd = cmd, stderr = true}\n"
+"    if not p then return p, msg end\n"
+"    local ret, stdout, stderr = p:wait()\n"
+"    if ret ~= 0 then return nil, stderr end\n"
+"    return stdout\n"
+"end\n"
+"\n"
+"-- run pkg-config for ldflags\n"
+"pkgconfig_libs = '--libs'\n"
+"function pkg_libs(...)\n"
+"    local fl = get_pkgconfig(pkgconfig_libs, ...)\n"
+"    if not fl then return nil end\n"
+"    return parse_ldflags(fl)\n"
+"end\n"
+"\n"
+"-- run pkg-config for cflags *and* ldflags\n"
+"-- this is done with two runs so generic flags are separated properly\n"
+"pkgconfig_cflags = '--cflags'\n"
+"function pkg_cflags(...)\n"
+"    local fl = get_pkgconfig(pkgconfig_cflags, ...)\n"
+"    if not fl then return nil end\n"
+"    return parse_cflags(fl) .. pkg_libs(...)\n"
+"end\n"
diff -ruNx autom4te.cache -x 'config*' pkg/odin/ipcgen/inc/Func.hh pkg/odin/ipcgen/inc/Func.hh
--- pkg/odin/ipcgen/inc/Func.hh	1969-12-31 18:00:00.000000000 -0600
+++ pkg/odin/ipcgen/inc/Func.hh	2016-09-08 11:04:06.221597118 -0500
@@ -0,0 +1,109 @@
+/* /home/darktjm/.ODIN/darktjm/FILES/b/l/ipcgen.ygi.3884090.c */
+extern tp_Nod YY_Parse(void);
+extern void yyerror(char *);
+extern int yylex(void);
+extern int yyparse(void);
+/* pkg/odin/ipcgen/ig-main.c */
+extern int main(void);
+/* pkg/odin/ipcgen/ig-gen.c */
+extern void Gen_InStub(tp_FilDsc, tp_Nod);
+extern void Gen_OutStub(tp_FilDsc, tp_Nod);
+extern void Write_InMsg(tp_FilDsc, tp_Nod);
+extern void Write_SplitInMsg(tp_FilDsc, tp_Nod);
+extern void Write_OutMsg(tp_FilDsc, tp_Nod, int, boolean);
+extern void Get_MsgNod(tp_Nod *, boolean *, tp_Nod);
+extern void Write_ServerIfDef(tp_FilDsc, boolean);
+extern void Write_Args(tp_FilDsc, tp_Nod);
+extern void Write_NodSym(tp_FilDsc, tp_Nod);
+/* pkg/odin/ipcgen/ig-yylex.c */
+extern int Init_Lex(void);
+extern int YY_Lex(void);
+extern boolean YY_IsWordChr(char);
+extern void EndLex(void);
+extern void ParseError(tp_Str);
+/* pkg/odin/if-err.c */
+extern void Init_Err(void);
+extern void Set_IPC_Err(boolean);
+extern void Set_ErrFile(tp_FileName, boolean, tp_FilDsc);
+extern void Save_ErrFile(tp_FileName *, boolean *, tp_FilDsc *);
+extern boolean IsErr(void);
+extern void Reset_Err(void);
+extern void Increment_Errors(void);
+extern int Num_Errors(void);
+extern void SysCallError(tp_FilDsc, char *);
+extern void FatalError(char *, char *, int);
+extern void SystemError(char *, ...);
+extern void Local_ErrMessage(tp_Str);
+extern void fatal_err(char *);
+/* pkg/odin/if-file.c */
+extern void Set_ModeMask(tp_FileName);
+extern void MakePlnFile(boolean *, tp_FileName);
+extern void MakeDirFile(boolean *, tp_FileName);
+extern void GetWorkingDir(boolean *, tp_Str);
+extern void ChangeDir(boolean *, tp_FileName);
+extern boolean IsExecutable(tp_FileName);
+extern void MakeExecutable(tp_FileName);
+extern void MakeReadOnly(boolean *, tp_FileName);
+extern void SymLink(boolean *, tp_FileName, tp_FileName);
+extern void FileName_SymLinkFileName(tp_FileName, tp_FileName);
+extern boolean IsDirectory_FileName(tp_FileName);
+extern boolean Exists(tp_FileName);
+extern boolean Empty(tp_FileName);
+extern void FileSize(boolean *, int *, tp_FileName);
+extern void Remove(tp_FileName);
+extern void RemoveDir(tp_FileName);
+extern void Rename(boolean *, tp_FileName, tp_FileName);
+/* pkg/odin/if-io.c */
+extern void Init_IO(void);
+extern boolean GetIsTTY(void);
+extern tp_FilDsc FileName_CFilDsc(tp_FileName);
+extern tp_FilDsc FileName_WFilDsc(tp_FileName, boolean);
+extern tp_FilDsc FileName_WBFilDsc(tp_FileName, boolean);
+extern tp_FilDsc FileName_AFilDsc(tp_FileName, boolean);
+extern tp_FilDsc FileName_RFilDsc(tp_FileName, boolean);
+extern tp_FilDsc FileName_RWFilDsc(tp_FileName, boolean);
+extern tp_FilDsc FileName_RWBFilDsc(tp_FileName, boolean);
+extern void Flush(tp_FilDsc);
+extern void Rewind(tp_FilDsc);
+extern void Unwind(tp_FilDsc);
+extern void Close(tp_FilDsc);
+extern boolean EndOfFile(tp_FilDsc);
+extern void Write(tp_FilDsc, tp_Str);
+extern void Writech(tp_FilDsc, char);
+extern void WriteInt(tp_FilDsc, int);
+extern void Writeln(tp_FilDsc, const char *);
+extern void WriteLine(tp_FilDsc, tp_Str);
+extern int Readch(tp_FilDsc);
+extern tp_Str Readln(tp_Str, tp_FilDsc);
+extern tp_Str ReadLine(tp_Str, tp_FilDsc);
+extern boolean Equal(tp_FilDsc, tp_FilDsc);
+extern void FileCopy(tp_FilDsc, tp_FilDsc);
+/* pkg/odin/if-nod.c */
+extern tp_Nod New_Nod(void);
+extern void Ret_Nod(tp_Nod);
+extern tp_NodTyp Nod_NodTyp(tp_Nod);
+extern void Set_Nod_NodTyp(tp_Nod, tp_NodTyp);
+extern tp_Nod Nod_FirstSon(tp_Nod);
+extern void Set_Nod_FirstSon(tp_Nod, tp_Nod);
+extern tp_Nod Nod_Brother(tp_Nod);
+extern void Set_Nod_Brother(tp_Nod, tp_Nod);
+extern int Nod_NumSons(tp_Nod);
+extern tp_Nod Nod_Son(int, tp_Nod);
+extern tp_Sym Nod_Sym(tp_Nod);
+extern void Set_Nod_Sym(tp_Nod, tp_Sym);
+extern void Push_SymStack(tp_Sym);
+extern void Init_ConstructTree(void);
+extern tp_Nod End_ConstructTree(void);
+extern void Action(int, int);
+/* pkg/odin/if-symbol.c */
+extern tp_Str GetEnv(tp_Str);
+extern tp_Str Malloc_Str(const char *);
+extern boolean Is_EmptyStr(tp_Str);
+extern int Str_PosInt(tp_Str);
+extern tp_Str Tail(tp_Str);
+extern void StrShift(tp_Str, int);
+extern tp_Sym Str_Sym(tp_Str);
+extern tp_Str Sym_Str(tp_Sym);
+extern int Sym_Att(tp_Sym);
+extern void Set_Sym_Att(tp_Sym, int);
+extern void Write_Syms(tp_FilDsc);
diff -ruNx autom4te.cache -x 'config*' pkg/odin/ipcgen/inc/NodTyp_.h pkg/odin/ipcgen/inc/NodTyp_.h
--- pkg/odin/ipcgen/inc/NodTyp_.h	1969-12-31 18:00:00.000000000 -0600
+++ pkg/odin/ipcgen/inc/NodTyp_.h	2016-09-08 11:03:50.023800752 -0500
@@ -0,0 +1,22 @@
+#ifndef TP_YYNODTYP
+#define TP_YYNODTYP
+
+#define NOD_ident 1
+#define NOD_stubs 2
+#define NOD_server 3
+#define NOD_client 4
+#define NOD_request 5
+#define NOD_splitrequest 6
+#define NOD_notice 7
+#define NOD_args 8
+#define NOD_argdcls 9
+#define NOD_argdcl 10
+#define NOD_in 11
+#define NOD_out 12
+#define NOD_inout 13
+#define NOD_int 14
+#define NOD_str 15
+#define NOD_pointer 16
+#define NOD_proc_call 17
+
+#endif
diff -ruNx autom4te.cache -x 'config*' pkg/odin/ipcgen/inc/TokTyp_.h pkg/odin/ipcgen/inc/TokTyp_.h
--- pkg/odin/ipcgen/inc/TokTyp_.h	1969-12-31 18:00:00.000000000 -0600
+++ pkg/odin/ipcgen/inc/TokTyp_.h	2016-09-08 11:03:50.027800701 -0500
@@ -0,0 +1,24 @@
+#ifndef TP_YYTOKTYP
+#define TP_YYTOKTYP
+
+#define TOK_EOF 0
+#define TOK_ERR 1
+#define TOK_ident 2
+#define TOK_server 3
+#define TOK_client 4
+#define TOK_request 5
+#define TOK_splitrequest 6
+#define TOK_notice 7
+#define TOK_in 8
+#define TOK_out 9
+#define TOK_inout 10
+#define TOK_str 11
+#define TOK_int 12
+#define TOK_star 13
+#define TOK_comma 14
+#define TOK_lparen 15
+#define TOK_rparen 16
+#define TOK_lbrkt 17
+#define TOK_rbrkt 18
+
+#endif
diff -ruNx autom4te.cache -x 'config*' pkg/tregrm/inc/Func.hh pkg/tregrm/inc/Func.hh
--- pkg/tregrm/inc/Func.hh	1969-12-31 18:00:00.000000000 -0600
+++ pkg/tregrm/inc/Func.hh	2016-09-08 11:04:06.493593698 -0500
@@ -0,0 +1,137 @@
+/* pkg/tregrm/tg-main.c */
+extern int main(void);
+/* pkg/tregrm/tg-anal.c */
+extern void Analyze(tp_Nod, tp_Nod, tp_Nod);
+/* pkg/tregrm/tg-att.c */
+extern void Reset_Att(tp_AttTyp);
+extern tp_Att Get_Att(tp_AttTyp, tp_Sym);
+extern void Set_Att(tp_AttTyp, tp_Sym, tp_Att);
+/* pkg/tregrm/tg-dummy.c */
+extern boolean Empty_DummyStack(void);
+extern void Push_DummyStack(tp_Nod, int);
+extern void Pop_DummyStack(tp_Nod *, int *);
+/* pkg/tregrm/tg-gen_grm.c */
+extern void Gen_Grammar(tp_FilDsc, tp_Nod, tp_Nod, tp_Nod);
+extern void Gen_LHS(tp_FilDsc, tp_Sym, int);
+extern void Gen_Rule(tp_FilDsc, tp_Nod, tp_Sym, int *, int *);
+extern void Gen_Seq(tp_FilDsc, tp_Nod, tp_Sym, boolean, int *, int *);
+extern void Gen_Token(tp_FilDsc, tp_Nod, tp_Sym, boolean, int *, int *);
+extern void Gen_DummySym(tp_FilDsc, tp_Sym, int);
+extern void Gen_Act(tp_FilDsc, tp_Nod, int);
+extern void Write_Act(tp_FilDsc, int, int);
+/* pkg/tregrm/tg-gen_lex.c */
+extern void Gen_LexTypes(tp_FilDsc, tp_Nod);
+extern boolean Is_UserLeafDef(tp_Nod);
+/* pkg/tregrm/tg-gen_nod.c */
+extern void Gen_NodeTypes(tp_FilDsc, tp_Nod);
+/* pkg/tregrm/tg-nod_grm.c */
+extern void Write_Node_Grammar(tp_FilDsc, tp_Nod);
+extern tp_Nod Create_Node_Grammar(tp_Nod);
+extern void Write_Node(tp_FilDsc, tp_Nod);
+extern tp_Nod Append_Seq(tp_Nod, tp_Nod);
+extern tp_Nod Union_Alternative(tp_Nod, tp_Nod);
+extern tp_Nod NUnion(tp_Nod, tp_Nod);
+extern tp_Nod NConc(tp_Nod, tp_Nod);
+extern tp_Nod Create_StarNod(tp_Nod);
+extern tp_Nod Create_PlusNod(tp_Nod);
+extern tp_Nod Copy_Nod(tp_Nod);
+extern tp_Nod Make_Nod(tp_NodTyp, tp_Nod);
+extern tp_Nod Make_SymNod(tp_NodTyp, tp_Sym);
+/* pkg/tregrm/tg-yylex.c */
+extern int GetChar(void);
+extern void Init_Lex(void);
+extern void EndLex(void);
+extern int YY_Lex(void);
+extern boolean IsNameChr(char);
+extern void ParseError(tp_Str);
+/* pkg/tregrm/tregrm-yacc.c */
+extern tp_Nod YY_Parse(void);
+extern void yyerror(char *);
+extern int yylex(void);
+extern int yyparse(void);
+/* pkg/odin/if-err.c */
+extern void Init_Err(void);
+extern void Set_IPC_Err(boolean);
+extern void Set_ErrFile(tp_FileName, boolean, tp_FilDsc);
+extern void Save_ErrFile(tp_FileName *, boolean *, tp_FilDsc *);
+extern boolean IsErr(void);
+extern void Reset_Err(void);
+extern void Increment_Errors(void);
+extern int Num_Errors(void);
+extern void SysCallError(tp_FilDsc, char *);
+extern void FatalError(char *, char *, int);
+extern void SystemError(char *, ...);
+extern void Local_ErrMessage(tp_Str);
+extern void fatal_err(char *);
+/* pkg/odin/if-file.c */
+extern void Set_ModeMask(tp_FileName);
+extern void MakePlnFile(boolean *, tp_FileName);
+extern void MakeDirFile(boolean *, tp_FileName);
+extern void GetWorkingDir(boolean *, tp_Str);
+extern void ChangeDir(boolean *, tp_FileName);
+extern boolean IsExecutable(tp_FileName);
+extern void MakeExecutable(tp_FileName);
+extern void MakeReadOnly(boolean *, tp_FileName);
+extern void SymLink(boolean *, tp_FileName, tp_FileName);
+extern void FileName_SymLinkFileName(tp_FileName, tp_FileName);
+extern boolean IsDirectory_FileName(tp_FileName);
+extern boolean Exists(tp_FileName);
+extern boolean Empty(tp_FileName);
+extern void FileSize(boolean *, int *, tp_FileName);
+extern void Remove(tp_FileName);
+extern void RemoveDir(tp_FileName);
+extern void Rename(boolean *, tp_FileName, tp_FileName);
+/* pkg/odin/if-io.c */
+extern void Init_IO(void);
+extern boolean GetIsTTY(void);
+extern tp_FilDsc FileName_CFilDsc(tp_FileName);
+extern tp_FilDsc FileName_WFilDsc(tp_FileName, boolean);
+extern tp_FilDsc FileName_WBFilDsc(tp_FileName, boolean);
+extern tp_FilDsc FileName_AFilDsc(tp_FileName, boolean);
+extern tp_FilDsc FileName_RFilDsc(tp_FileName, boolean);
+extern tp_FilDsc FileName_RWFilDsc(tp_FileName, boolean);
+extern tp_FilDsc FileName_RWBFilDsc(tp_FileName, boolean);
+extern void Flush(tp_FilDsc);
+extern void Rewind(tp_FilDsc);
+extern void Unwind(tp_FilDsc);
+extern void Close(tp_FilDsc);
+extern boolean EndOfFile(tp_FilDsc);
+extern void Write(tp_FilDsc, tp_Str);
+extern void Writech(tp_FilDsc, char);
+extern void WriteInt(tp_FilDsc, int);
+extern void Writeln(tp_FilDsc, const char *);
+extern void WriteLine(tp_FilDsc, tp_Str);
+extern int Readch(tp_FilDsc);
+extern tp_Str Readln(tp_Str, tp_FilDsc);
+extern tp_Str ReadLine(tp_Str, tp_FilDsc);
+extern boolean Equal(tp_FilDsc, tp_FilDsc);
+extern void FileCopy(tp_FilDsc, tp_FilDsc);
+/* pkg/odin/if-nod.c */
+extern tp_Nod New_Nod(void);
+extern void Ret_Nod(tp_Nod);
+extern tp_NodTyp Nod_NodTyp(tp_Nod);
+extern void Set_Nod_NodTyp(tp_Nod, tp_NodTyp);
+extern tp_Nod Nod_FirstSon(tp_Nod);
+extern void Set_Nod_FirstSon(tp_Nod, tp_Nod);
+extern tp_Nod Nod_Brother(tp_Nod);
+extern void Set_Nod_Brother(tp_Nod, tp_Nod);
+extern int Nod_NumSons(tp_Nod);
+extern tp_Nod Nod_Son(int, tp_Nod);
+extern tp_Sym Nod_Sym(tp_Nod);
+extern void Set_Nod_Sym(tp_Nod, tp_Sym);
+extern void Push_SymStack(tp_Sym);
+extern void Init_ConstructTree(void);
+extern tp_Nod End_ConstructTree(void);
+extern void Action(int, int);
+/* pkg/odin/if-symbol.c */
+extern tp_Str GetEnv(tp_Str);
+extern tp_Str Malloc_Str(const char *);
+extern boolean Is_EmptyStr(tp_Str);
+extern int Str_PosInt(tp_Str);
+extern tp_Str Tail(tp_Str);
+extern void StrShift(tp_Str, int);
+extern tp_Sym Str_Sym(tp_Str);
+extern tp_Str Sym_Str(tp_Sym);
+extern int Sym_Att(tp_Sym);
+extern void Set_Sym_Att(tp_Sym, int);
+extern void Write_Syms(tp_FilDsc);
diff -ruNx autom4te.cache -x 'config*' pkg/tregrm/inc/NodTyp_.h pkg/tregrm/inc/NodTyp_.h
--- pkg/tregrm/inc/NodTyp_.h	1969-12-31 18:00:00.000000000 -0600
+++ pkg/tregrm/inc/NodTyp_.h	2016-09-08 11:03:50.058800312 -0500
@@ -0,0 +1,27 @@
+#ifndef TP_YYNODTYP
+#define TP_YYNODTYP
+
+#define PROGRM 1
+#define NOD_Include 2
+#define SCANNR 3
+#define EOFLDF 4
+#define ERRLDF 5
+#define NONLDF 6
+#define LEAFDF 7
+#define NODES 8
+#define RULES 9
+#define RULE 10
+#define ALTLST 11
+#define ALTRNT 12
+#define SEQ 13
+#define LIST 14
+#define PLUS 15
+#define STAR 16
+#define QUESTION 17
+#define OPTNAL 18
+#define OUTNOD 19
+#define NAME 20
+#define DSTRNG 21
+#define KSTRNG 22
+
+#endif
diff -ruNx autom4te.cache -x 'config*' pkg/tregrm/inc/TokTyp_.h pkg/tregrm/inc/TokTyp_.h
--- pkg/tregrm/inc/TokTyp_.h	1969-12-31 18:00:00.000000000 -0600
+++ pkg/tregrm/inc/TokTyp_.h	2016-09-08 11:03:50.064800236 -0500
@@ -0,0 +1,26 @@
+#ifndef TP_YYTOKTYP
+#define TP_YYTOKTYP
+
+#define TOK_EOF 0
+#define TOK_ERR 1
+#define TOK_EOF_ 2
+#define TOK_ERR_ 3
+#define TOK_INCLUDE 4
+#define TOK_SCANNER 5
+#define TOK_NODES 6
+#define TOK_RULES 7
+#define TOK_Name 8
+#define TOK_AString 9
+#define TOK_QString 10
+#define TOK_Equals 11
+#define TOK_DoubleArrow 12
+#define TOK_SingleArrow 13
+#define TOK_Plus 14
+#define TOK_Star 15
+#define TOK_DoubleSlash 16
+#define TOK_SemiColon 17
+#define TOK_Question 18
+#define TOK_LeftParen 19
+#define TOK_RightParen 20
+
+#endif
diff -ruNx autom4te.cache -x 'config*' pkg/tregrm/tregrm-yacc.c pkg/tregrm/tregrm-yacc.c
--- pkg/tregrm/tregrm-yacc.c	1969-12-31 18:00:00.000000000 -0600
+++ pkg/tregrm/tregrm-yacc.c	2016-09-08 11:03:50.402795987 -0500
@@ -0,0 +1,1730 @@
+/* A Bison parser, made by GNU Bison 3.0.4.  */
+
+/* Bison implementation for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "3.0.4"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 1 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:339  */
+
+#include "inc/GMC.h"
+extern int num_ParseErrors;
+tp_Nod YY_Parse() {tp_Nod Nod;
+num_ParseErrors = 0; Init_Lex(); Init_ConstructTree();
+(void)yyparse(); Nod = End_ConstructTree();
+return Nod;}
+void yyerror(char*  s)  
+{num_ParseErrors++; ParseError(s);}
+int yylex() {return YY_Lex();}
+
+#line 78 "y.tab.c" /* yacc.c:339  */
+
+# ifndef YY_NULLPTR
+#  if defined __cplusplus && 201103L <= __cplusplus
+#   define YY_NULLPTR nullptr
+#  else
+#   define YY_NULLPTR 0
+#  endif
+# endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* In a future release of Bison, this section will be replaced
+   by #include "y.tab.h".  */
+#ifndef YY_YY_Y_TAB_H_INCLUDED
+# define YY_YY_Y_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    TOK_EOF_ = 2,
+    TOK_ERR_ = 3,
+    TOK_INCLUDE = 4,
+    TOK_SCANNER = 5,
+    TOK_NODES = 6,
+    TOK_RULES = 7,
+    TOK_Name = 8,
+    TOK_AString = 9,
+    TOK_QString = 10,
+    TOK_Equals = 11,
+    TOK_DoubleArrow = 12,
+    TOK_SingleArrow = 13,
+    TOK_Plus = 14,
+    TOK_Star = 15,
+    TOK_DoubleSlash = 16,
+    TOK_SemiColon = 17,
+    TOK_Question = 18,
+    TOK_LeftParen = 19,
+    TOK_RightParen = 20
+  };
+#endif
+/* Tokens.  */
+#define TOK_EOF_ 2
+#define TOK_ERR_ 3
+#define TOK_INCLUDE 4
+#define TOK_SCANNER 5
+#define TOK_NODES 6
+#define TOK_RULES 7
+#define TOK_Name 8
+#define TOK_AString 9
+#define TOK_QString 10
+#define TOK_Equals 11
+#define TOK_DoubleArrow 12
+#define TOK_SingleArrow 13
+#define TOK_Plus 14
+#define TOK_Star 15
+#define TOK_DoubleSlash 16
+#define TOK_SemiColon 17
+#define TOK_Question 18
+#define TOK_LeftParen 19
+#define TOK_RightParen 20
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef int YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE yylval;
+
+int yyparse (void);
+
+#endif /* !YY_YY_Y_TAB_H_INCLUDED  */
+
+/* Copy the second part of user declarations.  */
+
+#line 171 "y.tab.c" /* yacc.c:358  */
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#else
+typedef signed char yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(Msgid) Msgid
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE
+# if (defined __GNUC__                                               \
+      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
+     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
+#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
+# else
+#  define YY_ATTRIBUTE(Spec) /* empty */
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE_PURE
+# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
+#endif
+
+#ifndef YY_ATTRIBUTE_UNUSED
+# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
+#endif
+
+#if !defined _Noreturn \
+     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
+# if defined _MSC_VER && 1200 <= _MSC_VER
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(E) ((void) (E))
+#else
+# define YYUSE(E) /* empty */
+#endif
+
+#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
+    _Pragma ("GCC diagnostic push") \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+    _Pragma ("GCC diagnostic pop")
+#else
+# define YY_INITIAL_VALUE(Value) Value
+#endif
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
+#endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's 'empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+             && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
+    do                                                                  \
+      {                                                                 \
+        YYSIZE_T yynewbytes;                                            \
+        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
+        Stack = &yyptr->Stack_alloc;                                    \
+        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / sizeof (*yyptr);                          \
+      }                                                                 \
+    while (0)
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from SRC to DST.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+#  else
+#   define YYCOPY(Dst, Src, Count)              \
+      do                                        \
+        {                                       \
+          YYSIZE_T yyi;                         \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
+        }                                       \
+      while (0)
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  11
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   60
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  22
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  30
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  54
+/* YYNSTATES -- Number of states.  */
+#define YYNSTATES  77
+
+/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
+   by yylex, with out-of-bounds checking.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   257
+
+#define YYTRANSLATE(YYX)                                                \
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, without out-of-bounds checking.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     3,     4,     5,     6,     7,     8,     9,    10,
+      11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
+      21,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2
+};
+
+#if YYDEBUG
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+static const yytype_uint8 yyrline[] =
+{
+       0,    37,    37,    44,    49,    52,    56,    59,    63,    65,
+      69,    74,    77,    81,    84,    88,    92,    96,   100,   108,
+     113,   116,   120,   123,   127,   132,   135,   139,   142,   146,
+     152,   156,   159,   163,   170,   172,   176,   180,   183,   187,
+     191,   194,   197,   200,   204,   208,   210,   212,   216,   219,
+     223,   230,   232,   234,   236
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || 0
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "TOK_EOF_", "TOK_ERR_", "TOK_INCLUDE",
+  "TOK_SCANNER", "TOK_NODES", "TOK_RULES", "TOK_Name", "TOK_AString",
+  "TOK_QString", "TOK_Equals", "TOK_DoubleArrow", "TOK_SingleArrow",
+  "TOK_Plus", "TOK_Star", "TOK_DoubleSlash", "TOK_SemiColon",
+  "TOK_Question", "TOK_LeftParen", "TOK_RightParen", "$accept",
+  "xTreeGrammar", "xIncludes", "xIncludes_1", "xIncludes_101",
+  "xIncludeFile", "xScanner", "xScanner_1", "xScanner_101",
+  "xLexicalDefinition", "xNodes", "xNodes_1", "xNodes_101", "xRules",
+  "xRules_1", "xRules_101", "xRule", "xAlternateList", "xAlternateList_1",
+  "xAlternate", "xAlternate_1", "xExpression", "xExpression_1", "xTerm",
+  "xElement", "xTreeSpec", "xNodeName", "TOK_Nameleaf", "TOK_AStringleaf",
+  "TOK_QStringleaf", YY_NULLPTR
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[NUM] -- (External) token number corresponding to the
+   (internal) symbol number NUM (which must be that of a token).  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,     2,     3,     4,     5,     6,     7,     8,
+       9,    10,    11,    12,    13,    14,    15,    16,    17,    18,
+      19,    20
+};
+# endif
+
+#define YYPACT_NINF -18
+
+#define yypact_value_is_default(Yystate) \
+  (!!((Yystate) == (-18)))
+
+#define YYTABLE_NINF -1
+
+#define yytable_value_is_error(Yytable_value) \
+  0
+
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+static const yytype_int8 yypact[] =
+{
+      14,    10,    17,    21,   -18,   -18,   -18,    10,   -18,   -18,
+     -18,   -18,    12,    22,   -18,   -18,    18,    19,    12,   -18,
+      24,    25,    23,    30,   -18,    33,    33,   -18,    33,    33,
+      23,   -18,    33,   -18,   -18,   -18,   -18,   -18,   -18,    20,
+     -18,    33,   -18,    31,    23,   -18,   -18,    26,    31,   -18,
+     -18,    34,    -7,   -18,   -18,    -6,   -18,   -18,   -18,   -18,
+       9,   -18,   -18,   -18,    23,    27,   -18,    28,   -18,   -18,
+      -7,   -18,    29,   -18,   -18,   -18,   -18
+};
+
+  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+     Performed when YYTABLE does not specify something else to do.  Zero
+     means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       5,     0,     0,    12,     3,    53,    54,     4,     7,     8,
+       9,     1,     0,    21,    10,     6,     0,     0,    11,    14,
+       0,     0,     0,    26,    19,     0,     0,    13,     0,     0,
+      20,    23,     0,     2,    24,    52,    15,    16,    17,     0,
+      22,    25,    28,     0,     0,    27,    38,     0,    30,    32,
+      18,    35,    36,    29,    31,     0,    33,    34,    38,    37,
+      43,    45,    47,    46,     0,    48,    51,     0,    40,    41,
+       0,    42,     0,    49,    44,    39,    50
+};
+
+  /* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -18,   -18,   -18,   -18,   -18,    32,   -18,   -18,   -18,    36,
+     -18,   -18,   -18,   -18,   -18,   -18,     7,   -18,   -18,     3,
+     -18,    -3,   -18,   -18,   -14,   -18,    -4,   -17,   -11,   -12
+};
+
+  /* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     2,     3,     4,     7,     8,    13,    14,    18,    19,
+      23,    24,    30,    33,    34,    41,    42,    47,    48,    49,
+      56,    51,    52,    59,    60,    57,    65,    43,     9,    10
+};
+
+  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule whose
+     number is the opposite.  If YYTABLE_NINF, syntax error.  */
+static const yytype_uint8 yytable[] =
+{
+      21,    20,    35,     5,     6,     6,    21,    20,    36,    37,
+      31,    38,    39,    58,    64,    16,    17,    11,    40,     1,
+       5,     6,     5,     6,    68,    69,    70,    12,    71,    22,
+      25,    26,    50,    44,     6,    61,    28,    29,    32,    15,
+      63,    62,    35,    66,    53,    46,    73,    55,    45,    74,
+      76,    54,    66,    61,    27,    67,    75,     0,    63,    62,
+      72
+};
+
+static const yytype_int8 yycheck[] =
+{
+      12,    12,     9,    10,    11,    11,    18,    18,    25,    26,
+      22,    28,    29,    20,    20,     3,     4,     0,    30,     5,
+      10,    11,    10,    11,    15,    16,    17,     6,    19,     7,
+      12,    12,    44,    13,    11,    52,    12,    12,     8,     7,
+      52,    52,     9,    55,    18,    14,    19,    13,    41,    21,
+      21,    48,    64,    70,    18,    58,    70,    -1,    70,    70,
+      64
+};
+
+  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+     symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     5,    23,    24,    25,    10,    11,    26,    27,    50,
+      51,     0,     6,    28,    29,    27,     3,     4,    30,    31,
+      50,    51,     7,    32,    33,    12,    12,    31,    12,    12,
+      34,    51,     8,    35,    36,     9,    49,    49,    49,    49,
+      51,    37,    38,    49,    13,    38,    14,    39,    40,    41,
+      51,    43,    44,    18,    41,    13,    42,    47,    20,    45,
+      46,    49,    50,    51,    20,    48,    51,    43,    15,    16,
+      17,    19,    48,    19,    21,    46,    21
+};
+
+  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    22,    23,    24,    25,    25,    26,    26,    27,    27,
+      28,    29,    29,    30,    30,    31,    31,    31,    31,    32,
+      33,    33,    34,    34,    35,    36,    36,    37,    37,    38,
+      39,    40,    40,    41,    42,    42,    43,    44,    44,    45,
+      45,    45,    45,    45,    46,    46,    46,    46,    47,    47,
+      47,    48,    49,    50,    51
+};
+
+  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     4,     1,     2,     0,     2,     1,     1,     1,
+       1,     2,     0,     2,     1,     3,     3,     3,     5,     1,
+       2,     0,     2,     1,     1,     2,     0,     2,     1,     3,
+       1,     2,     1,     3,     1,     0,     1,     2,     0,     3,
+       2,     2,     2,     1,     3,     1,     1,     1,     2,     3,
+       4,     1,     1,     1,     1
+};
+
+
+#define yyerrok         (yyerrstatus = 0)
+#define yyclearin       (yychar = YYEMPTY)
+#define YYEMPTY         (-2)
+#define YYEOF           0
+
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                                  \
+do                                                              \
+  if (yychar == YYEMPTY)                                        \
+    {                                                           \
+      yychar = (Token);                                         \
+      yylval = (Value);                                         \
+      YYPOPSTACK (yylen);                                       \
+      yystate = *yyssp;                                         \
+      goto yybackup;                                            \
+    }                                                           \
+  else                                                          \
+    {                                                           \
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;                                                  \
+    }                                                           \
+while (0)
+
+/* Error token number */
+#define YYTERROR        1
+#define YYERRCODE       256
+
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)                        \
+do {                                            \
+  if (yydebug)                                  \
+    YYFPRINTF Args;                             \
+} while (0)
+
+/* This macro is provided for backward compatibility. */
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif
+
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+do {                                                                      \
+  if (yydebug)                                                            \
+    {                                                                     \
+      YYFPRINTF (stderr, "%s ", Title);                                   \
+      yy_symbol_print (stderr,                                            \
+                  Type, Value); \
+      YYFPRINTF (stderr, "\n");                                           \
+    }                                                                     \
+} while (0)
+
+
+/*----------------------------------------.
+| Print this symbol's value on YYOUTPUT.  |
+`----------------------------------------*/
+
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  FILE *yyo = yyoutput;
+  YYUSE (yyo);
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+  YYUSE (yytype);
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  YYFPRINTF (yyoutput, "%s %s (",
+             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)                            \
+do {                                                            \
+  if (yydebug)                                                  \
+    yy_stack_print ((Bottom), (Top));                           \
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+static void
+yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)
+{
+  unsigned long int yylno = yyrline[yyrule];
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+             yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr,
+                       yystos[yyssp[yyi + 1 - yynrhs]],
+                       &(yyvsp[(yyi + 1) - (yynrhs)])
+                                              );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)          \
+do {                                    \
+  if (yydebug)                          \
+    yy_reduce_print (yyssp, yyvsp, Rule); \
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+yystrlen (const char *yystr)
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+        switch (*++yyp)
+          {
+          case '\'':
+          case ',':
+            goto do_not_strip_quotes;
+
+          case '\\':
+            if (*++yyp != '\\')
+              goto do_not_strip_quotes;
+            /* Fall through.  */
+          default:
+            if (yyres)
+              yyres[yyn] = *yyp;
+            yyn++;
+            break;
+
+          case '"':
+            if (yyres)
+              yyres[yyn] = '\0';
+            return yyn;
+          }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = YY_NULLPTR;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                {
+                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
+                  if (! (yysize <= yysize1
+                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                    return 2;
+                  yysize = yysize1;
+                }
+              }
+        }
+    }
+
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
+
+  {
+    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
+    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+      return 2;
+    yysize = yysize1;
+  }
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
+}
+#endif /* YYERROR_VERBOSE */
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+{
+  YYUSE (yyvaluep);
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+}
+
+
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+int
+yyparse (void)
+{
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       'yyss': related to states.
+       'yyvs': related to semantic values.
+
+       Refer to the stacks through separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yyssp = yyss = yyssa;
+  yyvsp = yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+        /* Give user a chance to reallocate the stack.  Use copies of
+           these so that the &'s don't force the real ones into
+           memory.  */
+        YYSTYPE *yyvs1 = yyvs;
+        yytype_int16 *yyss1 = yyss;
+
+        /* Each stack pointer address is followed by the size of the
+           data in use in that stack, in bytes.  This used to be a
+           conditional around just the two extra args, but that might
+           be undefined if yyoverflow is a macro.  */
+        yyoverflow (YY_("memory exhausted"),
+                    &yyss1, yysize * sizeof (*yyssp),
+                    &yyvs1, yysize * sizeof (*yyvsp),
+                    &yystacksize);
+
+        yyss = yyss1;
+        yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+        goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+        yystacksize = YYMAXDEPTH;
+
+      {
+        yytype_int16 *yyss1 = yyss;
+        union yyalloc *yyptr =
+          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+        if (! yyptr)
+          goto yyexhaustedlab;
+        YYSTACK_RELOCATE (yyss_alloc, yyss);
+        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+        if (yyss1 != yyssa)
+          YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+                  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+        YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = yylex ();
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     '$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 2:
+#line 40 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(1,4);}
+#line 1300 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 3:
+#line 44 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(2,1);}
+#line 1306 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 5:
+#line 52 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,0);}
+#line 1312 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 6:
+#line 57 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1318 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 10:
+#line 69 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(3,1);}
+#line 1324 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 12:
+#line 77 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,0);}
+#line 1330 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 13:
+#line 82 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1336 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 15:
+#line 90 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(4,1);}
+#line 1342 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 16:
+#line 94 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(5,1);}
+#line 1348 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 17:
+#line 98 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(6,2);}
+#line 1354 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 18:
+#line 104 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(7,3);}
+#line 1360 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 19:
+#line 108 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(8,1);}
+#line 1366 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 21:
+#line 116 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,0);}
+#line 1372 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 22:
+#line 121 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1378 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 24:
+#line 127 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(9,1);}
+#line 1384 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 26:
+#line 135 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,0);}
+#line 1390 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 27:
+#line 140 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1396 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 29:
+#line 148 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(10,2);}
+#line 1402 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 30:
+#line 152 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(11,1);}
+#line 1408 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 31:
+#line 157 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1414 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 33:
+#line 165 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(12,2);}
+#line 1420 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 35:
+#line 172 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,0);}
+#line 1426 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 36:
+#line 176 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(-13,1);}
+#line 1432 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 37:
+#line 181 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1438 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 38:
+#line 183 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,0);}
+#line 1444 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 39:
+#line 189 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(14,2);}
+#line 1450 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 40:
+#line 192 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(15,1);}
+#line 1456 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 41:
+#line 195 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(16,1);}
+#line 1462 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 42:
+#line 198 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(17,1);}
+#line 1468 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 49:
+#line 221 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(18,1);}
+#line 1474 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 50:
+#line 226 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(19,1);}
+#line 1480 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 52:
+#line 232 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(20,-1);}
+#line 1486 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 53:
+#line 234 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(21,-1);}
+#line 1492 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 54:
+#line 236 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(22,-1);}
+#line 1498 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+
+#line 1502 "y.tab.c" /* yacc.c:1646  */
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now 'shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*--------------------------------------.
+| yyerrlab -- here on detecting error.  |
+`--------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+         error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+          /* Return failure if at end of input.  */
+          if (yychar == YYEOF)
+            YYABORT;
+        }
+      else
+        {
+          yydestruct ("Error: discarding",
+                      yytoken, &yylval);
+          yychar = YYEMPTY;
+        }
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+        {
+          yyn += YYTERROR;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+            {
+              yyn = yytable[yyn];
+              if (0 < yyn)
+                break;
+            }
+        }
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+        YYABORT;
+
+
+      yydestruct ("Error: popping",
+                  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined yyoverflow || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
+    }
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+                  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  return yyresult;
+}
+#line 238 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1906  */
+
diff -ruNx autom4te.cache -x 'config*' pkg/tregrm/tregrm-yacc.c.dflt pkg/tregrm/tregrm-yacc.c.dflt
--- pkg/tregrm/tregrm-yacc.c.dflt	1969-12-31 18:00:00.000000000 -0600
+++ pkg/tregrm/tregrm-yacc.c.dflt	2016-09-08 11:03:50.405795949 -0500
@@ -0,0 +1,1730 @@
+/* A Bison parser, made by GNU Bison 3.0.4.  */
+
+/* Bison implementation for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "3.0.4"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 1 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:339  */
+
+#include "inc/GMC.h"
+extern int num_ParseErrors;
+tp_Nod YY_Parse() {tp_Nod Nod;
+num_ParseErrors = 0; Init_Lex(); Init_ConstructTree();
+(void)yyparse(); Nod = End_ConstructTree();
+return Nod;}
+void yyerror(char*  s)  
+{num_ParseErrors++; ParseError(s);}
+int yylex() {return YY_Lex();}
+
+#line 78 "y.tab.c" /* yacc.c:339  */
+
+# ifndef YY_NULLPTR
+#  if defined __cplusplus && 201103L <= __cplusplus
+#   define YY_NULLPTR nullptr
+#  else
+#   define YY_NULLPTR 0
+#  endif
+# endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* In a future release of Bison, this section will be replaced
+   by #include "y.tab.h".  */
+#ifndef YY_YY_Y_TAB_H_INCLUDED
+# define YY_YY_Y_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    TOK_EOF_ = 2,
+    TOK_ERR_ = 3,
+    TOK_INCLUDE = 4,
+    TOK_SCANNER = 5,
+    TOK_NODES = 6,
+    TOK_RULES = 7,
+    TOK_Name = 8,
+    TOK_AString = 9,
+    TOK_QString = 10,
+    TOK_Equals = 11,
+    TOK_DoubleArrow = 12,
+    TOK_SingleArrow = 13,
+    TOK_Plus = 14,
+    TOK_Star = 15,
+    TOK_DoubleSlash = 16,
+    TOK_SemiColon = 17,
+    TOK_Question = 18,
+    TOK_LeftParen = 19,
+    TOK_RightParen = 20
+  };
+#endif
+/* Tokens.  */
+#define TOK_EOF_ 2
+#define TOK_ERR_ 3
+#define TOK_INCLUDE 4
+#define TOK_SCANNER 5
+#define TOK_NODES 6
+#define TOK_RULES 7
+#define TOK_Name 8
+#define TOK_AString 9
+#define TOK_QString 10
+#define TOK_Equals 11
+#define TOK_DoubleArrow 12
+#define TOK_SingleArrow 13
+#define TOK_Plus 14
+#define TOK_Star 15
+#define TOK_DoubleSlash 16
+#define TOK_SemiColon 17
+#define TOK_Question 18
+#define TOK_LeftParen 19
+#define TOK_RightParen 20
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef int YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE yylval;
+
+int yyparse (void);
+
+#endif /* !YY_YY_Y_TAB_H_INCLUDED  */
+
+/* Copy the second part of user declarations.  */
+
+#line 171 "y.tab.c" /* yacc.c:358  */
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#else
+typedef signed char yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(Msgid) Msgid
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE
+# if (defined __GNUC__                                               \
+      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
+     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
+#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
+# else
+#  define YY_ATTRIBUTE(Spec) /* empty */
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE_PURE
+# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
+#endif
+
+#ifndef YY_ATTRIBUTE_UNUSED
+# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
+#endif
+
+#if !defined _Noreturn \
+     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
+# if defined _MSC_VER && 1200 <= _MSC_VER
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(E) ((void) (E))
+#else
+# define YYUSE(E) /* empty */
+#endif
+
+#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
+    _Pragma ("GCC diagnostic push") \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+    _Pragma ("GCC diagnostic pop")
+#else
+# define YY_INITIAL_VALUE(Value) Value
+#endif
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
+#endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's 'empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+             && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
+    do                                                                  \
+      {                                                                 \
+        YYSIZE_T yynewbytes;                                            \
+        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
+        Stack = &yyptr->Stack_alloc;                                    \
+        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / sizeof (*yyptr);                          \
+      }                                                                 \
+    while (0)
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from SRC to DST.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+#  else
+#   define YYCOPY(Dst, Src, Count)              \
+      do                                        \
+        {                                       \
+          YYSIZE_T yyi;                         \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
+        }                                       \
+      while (0)
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  11
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   60
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  22
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  30
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  54
+/* YYNSTATES -- Number of states.  */
+#define YYNSTATES  77
+
+/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
+   by yylex, with out-of-bounds checking.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   257
+
+#define YYTRANSLATE(YYX)                                                \
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, without out-of-bounds checking.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     3,     4,     5,     6,     7,     8,     9,    10,
+      11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
+      21,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2
+};
+
+#if YYDEBUG
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+static const yytype_uint8 yyrline[] =
+{
+       0,    37,    37,    44,    49,    52,    56,    59,    63,    65,
+      69,    74,    77,    81,    84,    88,    92,    96,   100,   108,
+     113,   116,   120,   123,   127,   132,   135,   139,   142,   146,
+     152,   156,   159,   163,   170,   172,   176,   180,   183,   187,
+     191,   194,   197,   200,   204,   208,   210,   212,   216,   219,
+     223,   230,   232,   234,   236
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || 0
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "TOK_EOF_", "TOK_ERR_", "TOK_INCLUDE",
+  "TOK_SCANNER", "TOK_NODES", "TOK_RULES", "TOK_Name", "TOK_AString",
+  "TOK_QString", "TOK_Equals", "TOK_DoubleArrow", "TOK_SingleArrow",
+  "TOK_Plus", "TOK_Star", "TOK_DoubleSlash", "TOK_SemiColon",
+  "TOK_Question", "TOK_LeftParen", "TOK_RightParen", "$accept",
+  "xTreeGrammar", "xIncludes", "xIncludes_1", "xIncludes_101",
+  "xIncludeFile", "xScanner", "xScanner_1", "xScanner_101",
+  "xLexicalDefinition", "xNodes", "xNodes_1", "xNodes_101", "xRules",
+  "xRules_1", "xRules_101", "xRule", "xAlternateList", "xAlternateList_1",
+  "xAlternate", "xAlternate_1", "xExpression", "xExpression_1", "xTerm",
+  "xElement", "xTreeSpec", "xNodeName", "TOK_Nameleaf", "TOK_AStringleaf",
+  "TOK_QStringleaf", YY_NULLPTR
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[NUM] -- (External) token number corresponding to the
+   (internal) symbol number NUM (which must be that of a token).  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,     2,     3,     4,     5,     6,     7,     8,
+       9,    10,    11,    12,    13,    14,    15,    16,    17,    18,
+      19,    20
+};
+# endif
+
+#define YYPACT_NINF -18
+
+#define yypact_value_is_default(Yystate) \
+  (!!((Yystate) == (-18)))
+
+#define YYTABLE_NINF -1
+
+#define yytable_value_is_error(Yytable_value) \
+  0
+
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+static const yytype_int8 yypact[] =
+{
+      14,    10,    17,    21,   -18,   -18,   -18,    10,   -18,   -18,
+     -18,   -18,    12,    22,   -18,   -18,    18,    19,    12,   -18,
+      24,    25,    23,    30,   -18,    33,    33,   -18,    33,    33,
+      23,   -18,    33,   -18,   -18,   -18,   -18,   -18,   -18,    20,
+     -18,    33,   -18,    31,    23,   -18,   -18,    26,    31,   -18,
+     -18,    34,    -7,   -18,   -18,    -6,   -18,   -18,   -18,   -18,
+       9,   -18,   -18,   -18,    23,    27,   -18,    28,   -18,   -18,
+      -7,   -18,    29,   -18,   -18,   -18,   -18
+};
+
+  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+     Performed when YYTABLE does not specify something else to do.  Zero
+     means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       5,     0,     0,    12,     3,    53,    54,     4,     7,     8,
+       9,     1,     0,    21,    10,     6,     0,     0,    11,    14,
+       0,     0,     0,    26,    19,     0,     0,    13,     0,     0,
+      20,    23,     0,     2,    24,    52,    15,    16,    17,     0,
+      22,    25,    28,     0,     0,    27,    38,     0,    30,    32,
+      18,    35,    36,    29,    31,     0,    33,    34,    38,    37,
+      43,    45,    47,    46,     0,    48,    51,     0,    40,    41,
+       0,    42,     0,    49,    44,    39,    50
+};
+
+  /* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -18,   -18,   -18,   -18,   -18,    32,   -18,   -18,   -18,    36,
+     -18,   -18,   -18,   -18,   -18,   -18,     7,   -18,   -18,     3,
+     -18,    -3,   -18,   -18,   -14,   -18,    -4,   -17,   -11,   -12
+};
+
+  /* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     2,     3,     4,     7,     8,    13,    14,    18,    19,
+      23,    24,    30,    33,    34,    41,    42,    47,    48,    49,
+      56,    51,    52,    59,    60,    57,    65,    43,     9,    10
+};
+
+  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule whose
+     number is the opposite.  If YYTABLE_NINF, syntax error.  */
+static const yytype_uint8 yytable[] =
+{
+      21,    20,    35,     5,     6,     6,    21,    20,    36,    37,
+      31,    38,    39,    58,    64,    16,    17,    11,    40,     1,
+       5,     6,     5,     6,    68,    69,    70,    12,    71,    22,
+      25,    26,    50,    44,     6,    61,    28,    29,    32,    15,
+      63,    62,    35,    66,    53,    46,    73,    55,    45,    74,
+      76,    54,    66,    61,    27,    67,    75,     0,    63,    62,
+      72
+};
+
+static const yytype_int8 yycheck[] =
+{
+      12,    12,     9,    10,    11,    11,    18,    18,    25,    26,
+      22,    28,    29,    20,    20,     3,     4,     0,    30,     5,
+      10,    11,    10,    11,    15,    16,    17,     6,    19,     7,
+      12,    12,    44,    13,    11,    52,    12,    12,     8,     7,
+      52,    52,     9,    55,    18,    14,    19,    13,    41,    21,
+      21,    48,    64,    70,    18,    58,    70,    -1,    70,    70,
+      64
+};
+
+  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+     symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     5,    23,    24,    25,    10,    11,    26,    27,    50,
+      51,     0,     6,    28,    29,    27,     3,     4,    30,    31,
+      50,    51,     7,    32,    33,    12,    12,    31,    12,    12,
+      34,    51,     8,    35,    36,     9,    49,    49,    49,    49,
+      51,    37,    38,    49,    13,    38,    14,    39,    40,    41,
+      51,    43,    44,    18,    41,    13,    42,    47,    20,    45,
+      46,    49,    50,    51,    20,    48,    51,    43,    15,    16,
+      17,    19,    48,    19,    21,    46,    21
+};
+
+  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    22,    23,    24,    25,    25,    26,    26,    27,    27,
+      28,    29,    29,    30,    30,    31,    31,    31,    31,    32,
+      33,    33,    34,    34,    35,    36,    36,    37,    37,    38,
+      39,    40,    40,    41,    42,    42,    43,    44,    44,    45,
+      45,    45,    45,    45,    46,    46,    46,    46,    47,    47,
+      47,    48,    49,    50,    51
+};
+
+  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     4,     1,     2,     0,     2,     1,     1,     1,
+       1,     2,     0,     2,     1,     3,     3,     3,     5,     1,
+       2,     0,     2,     1,     1,     2,     0,     2,     1,     3,
+       1,     2,     1,     3,     1,     0,     1,     2,     0,     3,
+       2,     2,     2,     1,     3,     1,     1,     1,     2,     3,
+       4,     1,     1,     1,     1
+};
+
+
+#define yyerrok         (yyerrstatus = 0)
+#define yyclearin       (yychar = YYEMPTY)
+#define YYEMPTY         (-2)
+#define YYEOF           0
+
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                                  \
+do                                                              \
+  if (yychar == YYEMPTY)                                        \
+    {                                                           \
+      yychar = (Token);                                         \
+      yylval = (Value);                                         \
+      YYPOPSTACK (yylen);                                       \
+      yystate = *yyssp;                                         \
+      goto yybackup;                                            \
+    }                                                           \
+  else                                                          \
+    {                                                           \
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;                                                  \
+    }                                                           \
+while (0)
+
+/* Error token number */
+#define YYTERROR        1
+#define YYERRCODE       256
+
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)                        \
+do {                                            \
+  if (yydebug)                                  \
+    YYFPRINTF Args;                             \
+} while (0)
+
+/* This macro is provided for backward compatibility. */
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif
+
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+do {                                                                      \
+  if (yydebug)                                                            \
+    {                                                                     \
+      YYFPRINTF (stderr, "%s ", Title);                                   \
+      yy_symbol_print (stderr,                                            \
+                  Type, Value); \
+      YYFPRINTF (stderr, "\n");                                           \
+    }                                                                     \
+} while (0)
+
+
+/*----------------------------------------.
+| Print this symbol's value on YYOUTPUT.  |
+`----------------------------------------*/
+
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  FILE *yyo = yyoutput;
+  YYUSE (yyo);
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+  YYUSE (yytype);
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  YYFPRINTF (yyoutput, "%s %s (",
+             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)                            \
+do {                                                            \
+  if (yydebug)                                                  \
+    yy_stack_print ((Bottom), (Top));                           \
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+static void
+yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)
+{
+  unsigned long int yylno = yyrline[yyrule];
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+             yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr,
+                       yystos[yyssp[yyi + 1 - yynrhs]],
+                       &(yyvsp[(yyi + 1) - (yynrhs)])
+                                              );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)          \
+do {                                    \
+  if (yydebug)                          \
+    yy_reduce_print (yyssp, yyvsp, Rule); \
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+yystrlen (const char *yystr)
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+        switch (*++yyp)
+          {
+          case '\'':
+          case ',':
+            goto do_not_strip_quotes;
+
+          case '\\':
+            if (*++yyp != '\\')
+              goto do_not_strip_quotes;
+            /* Fall through.  */
+          default:
+            if (yyres)
+              yyres[yyn] = *yyp;
+            yyn++;
+            break;
+
+          case '"':
+            if (yyres)
+              yyres[yyn] = '\0';
+            return yyn;
+          }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = YY_NULLPTR;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                {
+                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
+                  if (! (yysize <= yysize1
+                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                    return 2;
+                  yysize = yysize1;
+                }
+              }
+        }
+    }
+
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
+
+  {
+    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
+    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+      return 2;
+    yysize = yysize1;
+  }
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
+}
+#endif /* YYERROR_VERBOSE */
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+{
+  YYUSE (yyvaluep);
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+}
+
+
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+int
+yyparse (void)
+{
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       'yyss': related to states.
+       'yyvs': related to semantic values.
+
+       Refer to the stacks through separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yyssp = yyss = yyssa;
+  yyvsp = yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+        /* Give user a chance to reallocate the stack.  Use copies of
+           these so that the &'s don't force the real ones into
+           memory.  */
+        YYSTYPE *yyvs1 = yyvs;
+        yytype_int16 *yyss1 = yyss;
+
+        /* Each stack pointer address is followed by the size of the
+           data in use in that stack, in bytes.  This used to be a
+           conditional around just the two extra args, but that might
+           be undefined if yyoverflow is a macro.  */
+        yyoverflow (YY_("memory exhausted"),
+                    &yyss1, yysize * sizeof (*yyssp),
+                    &yyvs1, yysize * sizeof (*yyvsp),
+                    &yystacksize);
+
+        yyss = yyss1;
+        yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+        goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+        yystacksize = YYMAXDEPTH;
+
+      {
+        yytype_int16 *yyss1 = yyss;
+        union yyalloc *yyptr =
+          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+        if (! yyptr)
+          goto yyexhaustedlab;
+        YYSTACK_RELOCATE (yyss_alloc, yyss);
+        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+        if (yyss1 != yyssa)
+          YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+                  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+        YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = yylex ();
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     '$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 2:
+#line 40 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(1,4);}
+#line 1300 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 3:
+#line 44 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(2,1);}
+#line 1306 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 5:
+#line 52 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,0);}
+#line 1312 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 6:
+#line 57 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1318 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 10:
+#line 69 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(3,1);}
+#line 1324 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 12:
+#line 77 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,0);}
+#line 1330 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 13:
+#line 82 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1336 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 15:
+#line 90 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(4,1);}
+#line 1342 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 16:
+#line 94 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(5,1);}
+#line 1348 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 17:
+#line 98 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(6,2);}
+#line 1354 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 18:
+#line 104 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(7,3);}
+#line 1360 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 19:
+#line 108 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(8,1);}
+#line 1366 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 21:
+#line 116 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,0);}
+#line 1372 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 22:
+#line 121 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1378 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 24:
+#line 127 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(9,1);}
+#line 1384 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 26:
+#line 135 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,0);}
+#line 1390 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 27:
+#line 140 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1396 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 29:
+#line 148 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(10,2);}
+#line 1402 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 30:
+#line 152 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(11,1);}
+#line 1408 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 31:
+#line 157 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1414 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 33:
+#line 165 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(12,2);}
+#line 1420 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 35:
+#line 172 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,0);}
+#line 1426 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 36:
+#line 176 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(-13,1);}
+#line 1432 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 37:
+#line 181 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,2);}
+#line 1438 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 38:
+#line 183 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(0,0);}
+#line 1444 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 39:
+#line 189 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(14,2);}
+#line 1450 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 40:
+#line 192 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(15,1);}
+#line 1456 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 41:
+#line 195 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(16,1);}
+#line 1462 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 42:
+#line 198 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(17,1);}
+#line 1468 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 49:
+#line 221 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(18,1);}
+#line 1474 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 50:
+#line 226 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(19,1);}
+#line 1480 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 52:
+#line 232 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(20,-1);}
+#line 1486 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 53:
+#line 234 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(21,-1);}
+#line 1492 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 54:
+#line 236 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1646  */
+    {Action(22,-1);}
+#line 1498 "y.tab.c" /* yacc.c:1646  */
+    break;
+
+
+#line 1502 "y.tab.c" /* yacc.c:1646  */
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now 'shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*--------------------------------------.
+| yyerrlab -- here on detecting error.  |
+`--------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+         error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+          /* Return failure if at end of input.  */
+          if (yychar == YYEOF)
+            YYABORT;
+        }
+      else
+        {
+          yydestruct ("Error: discarding",
+                      yytoken, &yylval);
+          yychar = YYEMPTY;
+        }
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+        {
+          yyn += YYTERROR;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+            {
+              yyn = yytable[yyn];
+              if (0 < yyn)
+                break;
+            }
+        }
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+        YYABORT;
+
+
+      yydestruct ("Error: popping",
+                  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined yyoverflow || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
+    }
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+                  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  return yyresult;
+}
+#line 238 "/home/darktjm/.ODIN/darktjm/FILES/b/l/tregrm.ygi.3831454.y" /* yacc.c:1906  */
+
